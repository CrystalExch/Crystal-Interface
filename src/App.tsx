// import libraries
import {
  getBlockNumber,
  readContracts,
  waitForTransactionReceipt,
  getTransactionCount
} from '@wagmi/core';
import React, {
  KeyboardEvent as ReactKeyboardEvent,
  useCallback,
  useEffect,
  useLayoutEffect,
  useMemo,
  useRef,
  useState,
  useReducer
} from 'react';
import {
  Link,
  Navigate,
  Route,
  Routes,
  useLocation,
  useNavigate,
  useSearchParams,
  useParams,
  matchPath
} from 'react-router-dom';
import { TransactionExecutionError, encodeFunctionData, maxUint256, decodeFunctionResult, decodeEventLog } from 'viem';
import { useLanguage } from './contexts/LanguageContext';
import getAddress from './utils/getAddress.ts';
import { loadWalletsFromStorage, deduplicateWallets } from './utils/walletUtils';
import { config } from './wagmi.ts';
import {
  useLogout,
  useSmartAccountClient,
  useSendUserOperation,
  useAlchemyAccountContext,
  useUser,
  AuthCard,
  useSignTypedData,
  useSignMessage
} from "@account-kit/react";
import { Wallet, keccak256 } from 'ethers'
import { useQuery } from '@tanstack/react-query';
import {
  DEV_TOKENS_QUERY,
  HOLDERS_QUERY,
  POSITIONS_QUERY,
  SIMILAR_TOKENS_BY_NAME_QUERY,
  SIMILAR_TOKENS_BY_SYMBOL_QUERY,
  TOP_TRADERS_QUERY,
} from './components/MemeInterface/graphql';

// import css
import './App.css';

// import scripts
import approve from './scripts/approve';
import limitOrder from './scripts/limitOrder';
import multiBatchOrders from './scripts/multiBatchOrders';
import cancelOrder from './scripts/cancelOrder';
import sendeth from './scripts/sendeth';
import sendtokens from './scripts/sendtokens';
import _swap from './scripts/swap';
import swapETHForExactTokens from './scripts/swapETHForExactTokens';
import swapExactETHForTokens from './scripts/swapExactETHForTokens';
import swapExactTokensForETH from './scripts/swapExactTokensForETH';
import swapExactTokensForTokens from './scripts/swapExactTokensForTokens';
import swapTokensForExactETH from './scripts/swapTokensForExactETH';
import swapTokensForExactTokens from './scripts/swapTokensForExactTokens';
import unwrapeth from './scripts/unwrapeth';
import wrapeth from './scripts/wrapeth';
import stake from './scripts/stake.ts';
import { fetchLatestPrice } from './utils/getPrice.ts';
import replaceOrder from './scripts/replaceOrder';
// import utils
import customRound from './utils/customRound';
import { formatTime } from './utils/formatTime.ts';
import { formatCommas, formatSubscript } from './utils/numberDisplayFormat';
import { formatDisplay, formatSig } from './components/OrderCenter/utils/formatDisplay.ts';

// import abis
import { CrystalDataHelperAbi } from './abis/CrystalDataHelperAbi';
import { CrystalRouterAbi } from './abis/CrystalRouterAbi';
import { CrystalReferralAbi } from './abis/CrystalReferralAbi.ts';
import { TokenAbi } from './abis/TokenAbi';
import { shMonadAbi } from './abis/shMonadAbi.ts';
import { CrystalVaultsAbi } from "./abis/CrystalVaultsAbi";

// import types
import { DataPoint } from './components/Chart/utils/chartDataGenerator.ts';

// import svg graphics
import tradearrow from './assets/arrow.svg';
import closebutton from './assets/close_button.png';
import sendSwitch from './assets/send_arrow.svg';
import walleticon from './assets/wallet_icon.svg';
import infoicon from './assets/icon.png';
import refreshicon from './assets/circulararrow.png';
import Xicon from './assets/Xicon.svg';
import reset from './assets/reset.svg';
import walletbackpack from './assets/walletbackpack.jpg'
import walletcoinbase from './assets/walletcoinbase.png'
import walletconnect from './assets/walletconnect.png'
import walletinjected from './assets/walletinjected.png'
import walletmetamask from './assets/walletmetamask.svg'
import walletphantom from './assets/walletphantom.svg'
import walletrabby from './assets/walletrabby.png'
import warningicon from './assets/warning_icon.png'
import walletsafe from './assets/walletsafe.png'
import wallettomo from './assets/wallettomo.jpg'
import wallethaha from './assets/wallethaha.png'
import crystalxp from './assets/CrystalX.png';
import part1image from './assets/part1intro.png';
import topright from './assets/topright.png';
import veryleft from './assets/veryleft.png';
import topmiddle from './assets/topmiddle.png';
import veryright from './assets/veryright.png';
import topleft from './assets/topleft.png';
import circleleft from './assets/circleleft.png';
import lbstand from './assets/lbstand.png';
import firstPlacePfp from './assets/leaderboard_first.png';
import secondPlacePfp from './assets/leaderboard_second.png';
import thirdPlacePfp from './assets/leaderboard_third.png';
import defaultPfp from './assets/leaderboard_default.png';
import iconusdc from './assets/iconusdc.png';
import edgeX from './assets/edgeX.svg';
import switchicon from './assets/switch.svg';

//audio
import stepaudio from './assets/step_audio.mp3';
import backaudio from './assets/back_audio.mp3';

// import routes
import Portfolio from './components/Portfolio/Portfolio.tsx';

// import main app components
import ChartComponent from './components/Chart/Chart.tsx';
import TokenInfoPopupContent from './components/Header/ChartHeader/TokenInfo/TokenInfoPopup/TokenInfoPopupContent.tsx';
import ChartOrderbookPanel from './components/ChartOrderbookPanel/ChartOrderbookPanel.tsx';
import Header from './components/Header/Header.tsx';
import LoadingOverlay from './components/loading/LoadingComponent.tsx';
import FullScreenOverlay from './components/loading/LoadingScreen.tsx';
import NavigationProgress from './components/NavigationProgress.tsx';
import OrderCenter from './components/OrderCenter/OrderCenter.tsx';
import SortArrow from './components/OrderCenter/SortArrow/SortArrow.tsx';
import PortfolioContent from './components/Portfolio/BalancesContent/BalancesContent.tsx';
import PortfolioPopupGraph from './components/Portfolio/PortfolioGraph/PortfolioGraph.tsx';
import ToggleSwitch from './components/ToggleSwitch/ToggleSwitch.tsx';
import TooltipLabel from './components/TooltipLabel/TooltipLabel.tsx';
import TransactionPopupManager from './components/TransactionPopupManager/TransactionPopupManager';
import MiniChart from './components/Header/ChartHeader/TokenInfo/MiniChart/MiniChart.tsx';
import Leaderboard from './components/Leaderboard/Leaderboard.tsx';
import SimpleOrdersContainer from './components/SimpleOrdersContainer/SimpleOrdersContainer';
import SidebarNav from './components/SidebarNav/SidebarNav';
import EarnVaults from './components/EarnVaults/EarnVaults.tsx';
import Launchpad from './components/Launchpad/Launchpad.tsx';
import TokenExplorer from './components/TokenExplorer/TokenExplorer.tsx';
import MemeInterface from './components/MemeInterface/MemeInterface.tsx';
import MemeTransactionPopupManager from './components/MemeTransactionPopup/MemeTransactionPopupManager';
import TokenBoard from './components/DegenToken/TokenBoard';
import TokenDetail from './components/DegenToken/TokenDetail';
import Tracker from './components/Tracker/Tracker.tsx';
import Earn from './components/Earn/Earn.tsx';
import Perps from './components/Perps/Perps.tsx';
import PNLComponent from './components/PNLComponent/PNLComponent.tsx';
import ImportWalletsPopup from './components/Tracker/ImportWalletsPopup.tsx';
import TradingPresetsPopup from './components/Tracker/TradingPresetsPopup/TradingPresetsPopup';
import LiveTradesSettingsPopup from './components/Tracker/ LiveTradesSettingsPopup/LiveTradesSettingsPopup.tsx';
import MemeSearch from './components/MemeSearch/MemeSearch.tsx';
import { showLoadingPopup, updatePopup } from './components/MemeTransactionPopup/MemeTransactionPopupManager';
import TrackerWidget from './components/TrackerWidget/TrackerWidget.tsx';

// import config
import { ChevronDown, SearchIcon } from 'lucide-react';
import { usePortfolioData } from './components/Portfolio/PortfolioGraph/usePortfolioData.ts';
import { settings } from './settings.ts';
import { useSharedContext } from './contexts/SharedContext.tsx';
import { QRCodeSVG } from 'qrcode.react';
import CopyButton from './components/CopyButton/CopyButton.tsx';
import { sMonAbi } from './abis/sMonAbi.ts';
import { defaultMetrics } from './components/TokenExplorer/TokenData.ts';

type LaunchpadTrade = {
  id: string;
  timestamp: number;
  isBuy: boolean;
  price: number;
  tokenAmount: number;
  nativeAmount: number;
  caller: string;
};

type Holder = {
  address: string;
  balance: number;
  tokenNet: number;
  valueNet: number;
  amountBought: number;
  amountSold: number;
  valueBought: number;
  valueSold: number;
};

interface Token {
  id: string;
  tokenAddress: string;
  dev: string;
  name: string;
  symbol: string;
  image: string;
  price: number;
  marketCap: number;
  change24h: number;
  volume24h: number;
  holders: number;
  proTraders: number;
  sniperHolding: number;
  devHolding: number;
  bundleHolding: number;
  insiderHolding: number;
  top10Holding: number;
  buyTransactions: number;
  sellTransactions: number;
  globalFeesPaid: number;
  website: string;
  twitterHandle: string;
  progress: number;
  status: 'new' | 'graduating' | 'graduated';
  description: string;
  created: number;
  bondingAmount: number;
  volumeDelta: number;
  telegramHandle: string;
  discordHandle: string;
  graduatedTokens: number;
  launchedTokens: number;
}

type AudioGroups = 'swap' | 'order' | 'transfer' | 'approve';

interface AudioGroupSettings {
  swap: boolean;
  order: boolean;
  transfer: boolean;
  approve: boolean;
}

type State = {
  tokensByStatus: Record<Token['status'], Token[]>;
  hidden: Set<string>;
  loading: Set<string>;
};

type Action =
  | { type: 'INIT'; tokens: Token[] }
  | { type: 'ADD_MARKET'; token: Partial<Token> }
  | { type: 'UPDATE_MARKET'; id: string; updates: Partial<Token> }
  | { type: 'GRADUATE_MARKET'; id: string }
  | { type: 'HIDE_TOKEN'; id: string }
  | { type: 'SHOW_TOKEN'; id: string }
  | { type: 'SET_LOADING'; id: string; loading: boolean; buttonType?: 'primary' | 'secondary' }
  | { type: 'ADD_QUEUED_TOKENS'; payload: { status: Token['status']; tokens: Token[] } };

interface AlertSettings {
  soundAlertsEnabled: boolean;
  volume: number;
  sounds: {
    newPairs: string;
    pairMigrating: string;
    migrated: string;
  };
}

const SUBGRAPH_URL = 'https://gateway.thegraph.com/api/b9cc5f58f8ad5399b2c4dd27fa52d881/subgraphs/id/BJKD3ViFyTeyamKBzC1wS7a3XMuQijvBehgNaSBb197e';
const crystal = '/CrystalLogo.png';

const Loader = () => {
  const [ready, setReady] = useState(false);
  const [stateloading, setstateloading] = useState(true);
  const [addressinfoloading, setaddressinfoloading] = useState(true);

  useEffect(() => {
    (async () => {
      try {
        const query = `
          query {
            markets(first: 100, orderBy: volume, orderDirection: desc, where: {isCanonical:true}) {
              id
              baseAsset
              quoteAsset
              baseDecimals
              quoteDecimals
              baseTicker
              quoteTicker
              baseName
              quoteName
              marketType
              scaleFactor
              tickSize
              minSize
              maxPrice
              takerFee
              makerRebate
              volume
              latestPrice
              metadataCID
              trades(first: 100, orderBy: timestamp, orderDirection: desc) {
                id
                amountIn
                amountOut
                isBuy
                timestamp
                tx
                endPrice
              }
            }
          }
        `;
        const res = await fetch(SUBGRAPH_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query }),
        });
        const json = await res.json();
        const list = Array.isArray(json?.data?.markets) ? [...json.data.markets].reverse() : []

        const ETH_ADDR = settings.chainConfig[activechain].eth;
        const WETH_ADDR = settings.chainConfig[activechain].weth;
        const ETH_TICKER = settings.chainConfig[activechain].ethticker;
        const WETH_TICKER = settings.chainConfig[activechain].wethticker;
        const tokendict: { [key: string]: any } =
          settings.chainConfig[activechain].tokendict;
        const newMarkets: Record<string, any> = settings.chainConfig[activechain].markets;
        for (const m of list) {
          const baseAddr0 = getAddress(String(m.baseAsset || ''));
          const quoteAddr0 = getAddress(String(m.quoteAsset || ''));
          if (!tokendict[baseAddr0]) {
            tokendict[baseAddr0] = {
              address: baseAddr0,
              decimals: BigInt(Number(m.baseDecimals ?? 18)),
              image: m.metadataCID ?? '',
              name: m.baseName,
              ticker: m.baseTicker,
              website: '',
              autofetched: true,
            }
          }
          if (!tokendict[quoteAddr0]) {
            tokendict[quoteAddr0] = {
              address: quoteAddr0,
              decimals: BigInt(Number(m.quoteDecimals ?? 18)),
              image: m.metadataCID ?? '',
              name: m.quoteName,
              ticker: m.quoteTicker,
              website: '',
              autofetched: true,
            }
          }
          const scaleExp = (m.scaleFactor == '21' && m.quoteDecimals == '18') ? 9 : Number(m.scaleFactor ?? 0);
          const scaleFactor = (BigInt(10) ** BigInt(scaleExp));
          const baseDec = Number(m.baseDecimals ?? 18);
          const quoteDec = Number(m.quoteDecimals ?? 18);
          const pfExp = Math.max(0, quoteDec + scaleExp - baseDec);
          const priceFactor = (BigInt(10) ** BigInt(pfExp));

          const common = {
            address: String(m.id ?? '').toLowerCase(),
            marketType: Number(m.marketType ?? 0),
            precision: 5,
            scaleFactor,
            priceFactor,
            tickSize: BigInt(m.tickSize ?? 1),
            minSize: BigInt(m.minSize ?? 0),
            maxPrice: BigInt(m.maxPrice ?? 0),
            fee: BigInt(m.takerFee ?? 100000),
            makerRebate: BigInt(m.makerRebate ?? 100000),
            baseDecimals: BigInt(baseDec),
            quoteDecimals: BigInt(quoteDec),
          };

          const baseIsEthish = baseAddr0 === ETH_ADDR || baseAddr0 === WETH_ADDR;
          const quoteIsEthish = quoteAddr0 === ETH_ADDR || quoteAddr0 === WETH_ADDR;

          const variants: Array<{ baseAddr: string; quoteAddr: string, baseAsset: string, quoteAsset: string }> = [];
          if (baseIsEthish) {
            variants.push({ baseAddr: ETH_ADDR, quoteAddr: quoteAddr0, baseAsset: ETH_TICKER, quoteAsset: m.quoteTicker });
            variants.push({ baseAddr: WETH_ADDR, quoteAddr: quoteAddr0, baseAsset: WETH_TICKER, quoteAsset: m.quoteTicker });
          } else if (quoteIsEthish) {
            variants.push({ baseAddr: baseAddr0, quoteAddr: ETH_ADDR, baseAsset: m.baseTicker, quoteAsset: ETH_TICKER });
            variants.push({ baseAddr: baseAddr0, quoteAddr: WETH_ADDR, baseAsset: m.baseTicker, quoteAsset: WETH_TICKER });
          } else {
            variants.push({ baseAddr: baseAddr0, quoteAddr: quoteAddr0, baseAsset: m.baseTicker, quoteAsset: m.quoteTicker });
          }

          for (const v of variants) {
            const bTok = tokendict[v.baseAddr];

            const marketKey = `${v.baseAsset}${v.quoteAsset}`;
            const image = (bTok?.image ?? settings.chainConfig[activechain].image ?? null);
            const website = (bTok?.website ?? '');
            newMarkets[marketKey] = {
              baseAsset: v.baseAsset,
              quoteAsset: v.quoteAsset,
              baseAddress: v.baseAddr,
              quoteAddress: v.quoteAddr,
              path: [v.quoteAddr, v.baseAddr],
              image,
              website,
              marketKey,
              ...common,
            };
          }
        }
        settings.chainConfig[activechain].markets = newMarkets;
        const newAddrToMarket: Record<string, string> = {};
        Object.values(newMarkets).reverse().forEach((m: any) => {
          if (m?.address) newAddrToMarket[String(m.address).toLowerCase()] = m.marketKey;
        });
        settings.chainConfig[activechain].addresstomarket = newAddrToMarket;

        const temptradesByMarket: Record<string, any[]> = {};
        Object.keys(newMarkets).forEach((k) => { temptradesByMarket[k] = []; });

        const addrToKey: Record<string, string> = {};
        Object.values(newMarkets).forEach((m: any) => {
          if (m?.address) addrToKey[String(m.address).toLowerCase()] = m.marketKey;
        });
      } catch (error) {
        console.error("Error fetching data:", error);
      }
      finally {
        setReady(true)
      }
    })();
  }, []);

  return (
    <>
      {<FullScreenOverlay isVisible={(stateloading || addressinfoloading)} />}
      {ready && <App stateloading={stateloading} setstateloading={setstateloading} addressinfoloading={addressinfoloading} setaddressinfoloading={setaddressinfoloading} />}
    </>
  );
}

function App({ stateloading, setstateloading, addressinfoloading, setaddressinfoloading }: { stateloading: any, setstateloading: any, addressinfoloading: any, setaddressinfoloading: any }) {
  // constants
  useEffect(() => {
    if (!localStorage.getItem("noSSR")) {
      localStorage.setItem("noSSR", "true");
    }
  }, []);

  const { config: alchemyconfig } = useAlchemyAccountContext() as any;
  const { client, address: scaAddress } = useSmartAccountClient({}) as { client: any; address: any };
  const { sendUserOperationAsync: rawSendUserOperationAsync } = useSendUserOperation({
    client,
    waitForTxn: false,
  });

  const { signTypedDataAsync } = useSignTypedData({ client })
  const { signMessageAsync } = useSignMessage({ client })
  const user = useUser();
  const { logout } = useLogout();
  const { t, language, setLanguage } = useLanguage();
  const [searchParams, setSearchParams] = useSearchParams();
  const { activechain, percentage, setPercentage, favorites } = useSharedContext();
  const userchain = alchemyconfig?._internal?.wagmiConfig?.state?.connections?.entries()?.next()?.value?.[1]?.chainId || client?.chain?.id
  const location = useLocation();
  const navigate = useNavigate();
  const [isTrackerWidgetOpen, setIsTrackerWidgetOpen] = useState(true); 
const [trackerWidgetSnap, setTrackerWidgetSnap] = useState<'left' | 'right' | null>(null);
const [trackerWidgetWidth, setTrackerWidgetWidth] = useState(400);

const handleTrackerWidgetSnapChange = useCallback((snapSide: 'left' | 'right' | null, width: number) => {
  setTrackerWidgetSnap(snapSide);
  setTrackerWidgetWidth(width);
}, []);
  const [windowWidth, setWindowWidth] = useState(window.innerWidth);
  const TOTAL_SUPPLY = 1e9;
  const HTTP_URL = settings.chainConfig[activechain].httpurl;
  const WS_URL = settings.chainConfig[activechain].wssurl;
  const eth = settings.chainConfig[activechain].eth as `0x${string}`;
  const weth = settings.chainConfig[activechain].weth as `0x${string}`;
  const usdc = settings.chainConfig[activechain].usdc as `0x${string}`;
  const ethticker = settings.chainConfig[activechain].ethticker;
  const wethticker = settings.chainConfig[activechain].wethticker;
  const balancegetter = settings.chainConfig[activechain].balancegetter;
  const router = settings.chainConfig[activechain].router;
  const crystalVaults = settings.chainConfig[activechain].crystalVaults;
  const markets: { [key: string]: any } =
    settings.chainConfig[activechain].markets;
  const tokendict: { [key: string]: any } =
    settings.chainConfig[activechain].tokendict;
  const addresstoMarket: { [key: string]: any } =
    settings.chainConfig[activechain].addresstomarket;
  const graph: Record<string, string[]> = (() => {
    let g: Record<string, string[]> = {};
    for (const [, market] of Object.entries(markets)) {
      const baseAddress = market.baseAddress;
      const quoteAddress = market.quoteAddress;

      if (!g[baseAddress]) g[baseAddress] = [];
      if (!g[quoteAddress]) g[quoteAddress] = [];

      g[baseAddress].push(quoteAddress);
      g[quoteAddress].push(baseAddress);
    }
    return g;
  })();

  const match =
    matchPath('/meme/:tokenAddress', location.pathname) ||
    matchPath('/board/:tokenAddress', location.pathname);
  const tokenAddress = match?.params?.tokenAddress?.toLowerCase();

  const txReceiptResolvers = useRef(new Map<string, () => void>());
  // get market including multihop
  const getMarket = (token1: string, token2: string): any => {
    return (
      markets[`${tokendict[token1].ticker}${tokendict[token2].ticker}`] ||
      markets[`${tokendict[token2].ticker}${tokendict[token1].ticker}`] ||
      (() => {
        if (
          (token1 == eth && token2 == weth) ||
          (token1 == weth && token2 == eth)
        ) {
          let market = { ...getMarket(eth, usdc) };
          market['path'] = [token1, token2];
          market['fee'] = BigInt(10000);
          return market;
        }
      })() ||
      (() => {
        const path = findShortestPath(token1, token2);
        if (path && path.length > 2) {
          let fee = BigInt(1);
          for (let i = 0; i < path.length - 1; i++) {
            fee *= getMarket(path[i], path[i + 1]).fee;
          }
          fee /= BigInt(100000 ** (path.length - 2));
          if (path.at(-1) != usdc) {
            return {
              quoteAsset: getMarket(path.at(-2), path.at(-1)).quoteAsset,
              baseAsset: getMarket(path.at(-2), path.at(-1)).baseAsset,
              path: path,
              quoteAddress: getMarket(path.at(-2), path.at(-1)).quoteAddress,
              baseAddress: getMarket(path.at(-2), path.at(-1)).baseAddress,
              quoteDecimals: getMarket(path.at(-2), path.at(-1)).quoteDecimals,
              baseDecimals: getMarket(path.at(-2), path.at(-1)).baseDecimals,
              address: getMarket(path.at(-2), path.at(-1)).address,
              scaleFactor: getMarket(path.at(-2), path.at(-1)).scaleFactor,
              priceFactor: getMarket(path.at(-2), path.at(-1)).priceFactor,
              tickSize: getMarket(path.at(-2), path.at(-1)).tickSize,
              minSize: getMarket(path.at(-2), path.at(-1)).minSize,
              maxPrice: getMarket(path.at(-2), path.at(-1)).maxPrice,
              fee: fee,
              makerRebate: getMarket(path.at(-2), path.at(-1)).makerRebate,
              image: getMarket(path.at(-2), path.at(-1)).image,
              website: getMarket(path.at(-2), path.at(-1)).website,
            };
          }
          return {
            quoteAsset: getMarket(path.at(0), path.at(1)).quoteAsset,
            baseAsset: getMarket(path.at(0), path.at(1)).baseAsset,
            path: path,
            quoteAddress: getMarket(path.at(0), path.at(1)).quoteAddress,
            baseAddress: getMarket(path.at(0), path.at(1)).baseAddress,
            quoteDecimals: getMarket(path.at(0), path.at(1)).quoteDecimals,
            baseDecimals: getMarket(path.at(0), path.at(1)).baseDecimals,
            address: getMarket(path.at(0), path.at(1)).address,
            scaleFactor: getMarket(path.at(0), path.at(1)).scaleFactor,
            priceFactor: getMarket(path.at(0), path.at(1)).priceFactor,
            tickSize: getMarket(path.at(0), path.at(1)).tickSize,
            minSize: getMarket(path.at(0), path.at(1)).minSize,
            maxPrice: getMarket(path.at(0), path.at(1)).maxPrice,
            fee: fee,
            makerRebate: getMarket(path.at(-2), path.at(-1)).makerRebate,
            image: getMarket(path.at(0), path.at(1)).image,
            website: getMarket(path.at(0), path.at(1)).website,
          };
        }
      })()
    );
  };

  // find path between two tokens
  const findShortestPath = (start: string, end: string): any => {
    const queue: string[][] = [[start]];
    const visited: Set<string> = new Set();

    while (queue.length > 0) {
      const path = queue.shift()!;
      const current = path[path.length - 1];
      if (current === end) {
        return path;
      }
      if (!visited.has(current)) {
        visited.add(current);
        for (const neighbor of graph[current] || []) {
          if (!visited.has(neighbor)) {
            queue.push([...path, neighbor]);
          }
        }
      }
    }
    return null;
  };

  const [activeTradingMode, setActiveTradingMode] = useState<'spot' | 'perps' | 'spectra'>(() => {
    const saved = localStorage.getItem('crystal_trading_mode');
    return (saved === 'perps' || saved === 'spectra') ? saved : 'spot';
  });
  //  const [isWidgetExplorerOpen, setIsWidgetExplorerOpen] = useState(false);
  // const [widgetExplorerSnapSide, setWidgetExplorerSnapSide] = useState<'left' | 'right' | 'none'>('none');
  // const [widgetWidth, setWidgetWidth] = useState(400);

  // const handleOpenWidgetExplorer = useCallback(() => {
  //   setIsWidgetExplorerOpen(true);
  // }, []);

  // const handleCloseWidgetExplorer = useCallback(() => {
  //   setIsWidgetExplorerOpen(false);
  //   setWidgetExplorerSnapSide('none');
  //   setWidgetWidth(400); 
  // }, []);

  // const handleWidgetExplorerSnapToSide = useCallback((side: 'left' | 'right' | 'none') => {
  //   console.log('Widget snapped to:', side); // Debug log
  //   setWidgetExplorerSnapSide(side);
  // }, []);

  // const handleWidgetExplorerResize = useCallback((width) => {
  //   console.log('Widget resized to:', width, 'Snap side:', widgetExplorerSnapSide); 
  //   setWidgetWidth(width);
  // }, [widgetExplorerSnapSide]);

  // const getAppContainerStyle = () => {
  //   const style = {};

  //   if (widgetExplorerSnapSide === 'left') {
  //     style.marginLeft = `${widgetWidth}px`;
  //     console.log('Applying left margin:', widgetWidth);
  //   } else if (widgetExplorerSnapSide === 'right') {
  //     style.marginRight = `${widgetWidth}px`;
  //     console.log('Applying right margin:', widgetWidth); 
  //   }

  //   style.transition = 'margin-left 0.2s ease, margin-right 0.2s ease';

  //   return style;
  // };

  // const getHeaderStyle = () => {
  //   const style = {};

  //   let leftPosition = 55;

  //   if (widgetExplorerSnapSide === 'left') {
  //     leftPosition = 55 + widgetWidth;
  //     console.log('Header left position:', leftPosition);
  //   }

  //   style.left = `${leftPosition}px`;
  //   style.transition = 'left 0.3s ease';

  //   return style;
  // };

  // const getHeaderClassName = () => {
  //   let className = 'app-header';

  //   if (widgetExplorerSnapSide === 'left') {
  //     className += ' widget-left';
  //   } else if (widgetExplorerSnapSide === 'right') {
  //     className += ' widget-right';
  //   }

  //   const isTradeRoute = ['/swap', '/limit', '/send', '/scale', '/market'].includes(location.pathname);
  //   if (isTradeRoute && !simpleView) {
  //   }

  //   return className;
  // };

  const [oneCTSigner, setOneCTSigner] = useState(() => {
    const saved = localStorage.getItem('crystal_active_wallet_private_key');
    return saved ? saved : '';
  });

  const [oneCTSig, setOneCTSig] = useState(() => {
    const saved = localStorage.getItem('crystal_onect_signature');
    return saved ? saved : '';
  });

  const validOneCT = !!oneCTSigner
  const onectclient = validOneCT ? new Wallet(oneCTSigner) : {
    address: '0x0000000000000000000000000000000000000000' as `0x${string}`,
    signTransaction: async () => ''
  };
  const address = validOneCT && scaAddress ? onectclient.address as `0x${string}` : scaAddress as `0x${string}`
  const connected = address != undefined
  const [subWallets, setSubWallets] = useState<Array<{ address: string, privateKey: string }>>(
    loadWalletsFromStorage()
  );
  const [selectedWallets, setSelectedWallets] = useState<Set<string>>(() => {
    try {
      const saved = localStorage.getItem('crystal_selected_wallets');
      if (saved) {
        const addresses = JSON.parse(saved);
        if (Array.isArray(addresses) && addresses.length > 0) {
          return new Set(addresses);
        }
      }
    } catch (error) {
      console.error('Error loading selected wallets:', error);
    }

    return (oneCTSigner ? new Set(
      subWallets
        .filter(w => w.privateKey == oneCTSigner)
        .map(w => w.address)
    ) : subWallets?.[0]?.address ? new Set([subWallets?.[0]?.address]) : new Set())
  });

  useEffect(() => {
    try {
      if (selectedWallets.size > 0) {
        localStorage.setItem(
          'crystal_selected_wallets',
          JSON.stringify(Array.from(selectedWallets))
        );
      }
    } catch (error) {
      console.error('Error saving selected wallets:', error);
    }
  }, [selectedWallets]);

  const getWalletIcon = () => {
    const connectorName = alchemyconfig?._internal?.wagmiConfig?.state?.connections?.entries()?.next()?.value?.[1]?.connector?.name || 'Unknown';

    switch (connectorName) {
      case 'MetaMask':
        return walletmetamask;
      case 'Coinbase Wallet':
        return walletcoinbase;
      case 'WalletConnect':
        return walletconnect;
      case 'Safe':
        return walletsafe;
      case 'Rabby Wallet':
      case 'Rabby':
        return walletrabby;
      case 'Backpack':
        return walletbackpack;
      case 'Phantom':
        return walletphantom;
      case 'Tomo':
        return wallettomo;
      case 'HaHa Wallet':
        return wallethaha;
      default:
        return walleticon;
    }
  };

  const [withdrawPercentage, setWithdrawPercentage] = useState('');
  const [currentWalletIcon, setCurrentWalletIcon] = useState(walleticon);
  // autosend mon
  useEffect(() => {
    if (connected) {
      if (!localStorage.getItem("firstConnect")) {
        localStorage.setItem("firstConnect", "true");
        if (window.location.hostname == 'test.crystal.exchange') {
          (async () => {
            const amountInWei = BigInt(Math.round(10 * 10 ** 18));
            await sendUserOperationAsync({
              uo: {
                target: address as `0x${string}`,
                value: amountInWei,
                data: '0x'
              }
            }, 100000n, 0n, false, '0xb52e8ab1cddc2645f8df7e94578ee0edfce192371feb2633f47e7039f90c67cb', await getTransactionCount(config, { address: ('0x14e60c954f13df0c1cc7e96dd485a245485c8813' as any), }))
          })()
        }
        if (!oneCTSigner) {
          setpopup(28)
        }
      }
    }
  }, [connected]);

  useEffect(() => {
    if (connected) {
      setCurrentWalletIcon(getWalletIcon());
    } else {
      setCurrentWalletIcon(walleticon);
    }
  }, [connected, alchemyconfig?._internal?.wagmiConfig?.state?.connections?.entries()?.next()?.value?.[1]?.connector?.name]);
  const [createVaultStep, setCreateVaultStep] = useState<'idle' | 'validating' | 'approve-quote' | 'approve-base' | 'creating' | 'success'>('idle');
  const [depositVaultStep, setDepositVaultStep] = useState<'idle' | 'validating' | 'approve-quote' | 'approve-base' | 'depositing' | 'success'>('idle');
  const [depositVaultError, setDepositVaultError] = useState<string>('');
  const [withdrawVaultStep, setWithdrawVaultStep] = useState<'idle' | 'validating' | 'withdrawing' | 'success'>('idle');
  const [withdrawVaultError, setWithdrawVaultError] = useState<string>('');
  const [createVaultError, setCreateVaultError] = useState<string>('');
  const [createVaultForm, setCreateVaultForm] = useState({
    name: '',
    description: '',
    selectedMarket: '',
    quoteAsset: '',
    baseAsset: '',
    amountQuote: '',
    amountBase: '',
    social1: '',
    social2: '',
    showMarketDropdown: false,
    marketSearchTerm: ''
  });

  const createSubWallet = async (setMain: boolean = false) => {
    try {
      if (subWallets.length > 9) return;
      let tempsig
      if (oneCTSig) {
        tempsig = oneCTSig
      }
      else {
        tempsig = await signTypedDataAsync({
          typedData: {
            types: {
              CrystalOneCT: [
                { name: 'version', type: 'string' },
                { name: 'account', type: 'uint256' },
              ],
            },
            primaryType: 'CrystalOneCT',
            message: {
              version: 'Crystal v0.0.1 Testnet',
              account: 1,
            }
          }
        })
        localStorage.setItem('crystal_onect_signature', tempsig)
        setOneCTSig(tempsig)
      }

      const privateKey = '0x' + (BigInt(keccak256('0x' + (BigInt(tempsig) + BigInt(subWallets.length + 1)).toString(16))) % BigInt("0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141")).toString(16).padStart(64, "0");

      const tempWallet = new Wallet(privateKey);
      const walletAddress = tempWallet.address as string;

      const newWallet = {
        address: walletAddress,
        privateKey: privateKey
      };

      const updatedWallets = [...subWallets, newWallet];
      setSelectedWallets(p => !p.size ? new Set(p).add(walletAddress) : p);
      lastNonceGroupFetch.current = 0;
      setSubWallets(updatedWallets);
      localStorage.setItem('crystal_sub_wallets', JSON.stringify(updatedWallets));
      if (setMain || (!validOneCT && updatedWallets.length === 1)) {
        setOneCTSigner(privateKey);
        refetch();
      }
      return walletAddress
    } catch (error) {
      console.error('Error creating subwallet:', error);
    }
  };

  const sendUserOperationAsync = useCallback(
    async (params: any, gasLimit: bigint = 0n, prioFee: bigint = 0n, mainWallet: boolean = false, pk: string = '', nonce: number = 0, noReceipt: boolean = false) => {
      let hash: `0x${string}`;
      let err: any;
      if (!!pk) {
        const tx = {
          to: params.uo.target,
          value: params.uo.value,
          data: params.uo.data,
          gasLimit: gasLimit > 0n ? gasLimit : 500000n,
          maxFeePerGas: 120000000000n + (prioFee > 0n ? prioFee : 13000000000n),
          maxPriorityFeePerGas: (prioFee > 0n ? prioFee : 13000000000n),
          nonce: nonce,
          chainId: activechain
        }
        const signedTx = await (new Wallet(pk)).signTransaction(tx);
        hash = keccak256(signedTx) as `0x${string}`;

        const RPC_URLS = [...new Set([
          HTTP_URL,
          'https://testnet-rpc.monad.xyz',
          'https://rpc.ankr.com/monad_testnet',
          'https://monad-testnet.g.alchemy.com/v2/SqJPlMJRSODWXbVjwNyzt6-uY9RMFGng',
          'https://quick-warmhearted-liquid.monad-testnet.quiknode.pro/f6b35b5a851643b1421398dcbccad4ca91ef6a68',
        ])];
        RPC_URLS.forEach(url => {
          fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            mode: 'no-cors',
            body: JSON.stringify({
              jsonrpc: '2.0',
              id: 0,
              method: 'eth_sendRawTransaction',
              params: [signedTx]
            })
          }).catch();
        });
      }
      else if (validOneCT && !mainWallet) {
        const wallet = nonces.current.get(onectclient.address);
        nonce = wallet.nonce
        const tx = {
          to: params.uo.target,
          value: params.uo.value,
          data: params.uo.data,
          gasLimit: gasLimit > 0n ? gasLimit : 500000n,
          maxFeePerGas: 120000000000n + (prioFee > 0n ? prioFee : 13000000000n),
          maxPriorityFeePerGas: (prioFee > 0n ? prioFee : 13000000000n),
          nonce: nonce,
          chainId: activechain
        }
        wallet?.pendingtxs.push([params, gasLimit, prioFee, mainWallet, pk, nonce]);
        if (wallet) wallet.nonce += 1;
        const signedTx = await onectclient.signTransaction(tx);
        hash = keccak256(signedTx) as `0x${string}`;

        const RPC_URLS = [...new Set([
          HTTP_URL,
          'https://testnet-rpc.monad.xyz',
          'https://rpc.ankr.com/monad_testnet',
          'https://monad-testnet.g.alchemy.com/v2/SqJPlMJRSODWXbVjwNyzt6-uY9RMFGng',
          'https://quick-warmhearted-liquid.monad-testnet.quiknode.pro/f6b35b5a851643b1421398dcbccad4ca91ef6a68',
        ])];
        RPC_URLS.forEach(url => {
          fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            mode: 'no-cors',
            body: JSON.stringify({
              jsonrpc: '2.0',
              id: 0,
              method: 'eth_sendRawTransaction',
              params: [signedTx]
            })
          }).catch();
        });
      }
      else {
        hash = (await rawSendUserOperationAsync(params))?.hash
      }
      try {
        await Promise.race([
          new Promise<void>((resolve) => {
            txReceiptResolvers.current.set(hash, resolve);
          }),
          waitForTransactionReceipt(config, { hash, pollingInterval: noReceipt ? 2000 : 500 }).then((r) => {
            txReceiptResolvers.current.delete(hash);
            hash = r.transactionHash;
          }),
          new Promise((_, reject) =>
            setTimeout(() => reject(new Error('transaction timeout')), 5000)
          ),
        ]);
      }
      catch (e) {
        err = e
      } finally {
        if (!pk && validOneCT && !mainWallet) {
          const wallet = nonces.current.get(onectclient.address);
          wallet.pendingtxs = wallet.pendingtxs.filter(
            (p: any) => p[5] != nonce,
          );
        }
      }
      if (err) throw err
      return hash
    },
    [validOneCT]
  );

  const [OneCTDepositAddress, setOneCTDepositAddress] = useState('');
  const [perpsKeystore, setPerpsKeystore] = useState<any>(() => {
    const saved = localStorage.getItem('crystal_perps_signer');
    return saved !== null ? JSON.parse(saved) : {};
  })
  const [perpsDepositAmount, setPerpsDepositAmount] = useState('');
  const [perpsWithdrawAmount, setPerpsWithdrawAmount] = useState('');
  const [perpsLeverage, setPerpsLeverage] = useState<string>(() => {
    const saved = localStorage.getItem('crystal_perps_leverage');
    return saved !== null ? saved : '10.0';
  });
  // state vars
  const [_trackedWallets, setTrackedWallets] = useState<any[]>([]);
  const [showSendDropdown, setShowSendDropdown] = useState(false);
  const sendDropdownRef = useRef<HTMLDivElement | null>(null);
  const sendButtonRef = useRef<HTMLSpanElement | null>(null);
  const [dropdownOpen, setDropdownOpen] = useState(false);
  const [selectedDepositToken, setSelectedDepositToken] = useState(() => Object.keys(tokendict)[0]);
  const [mobileView, setMobileView] = useState('chart');
  const [showTrade, setShowTrade] = useState(false);
  const [showWelcomeScreen, setShowWelcomeScreen] = useState(true);
  const [selectedConnector, setSelectedConnector] = useState<any>(null);
  const [totalAccountValue, setTotalAccountValue] = useState<number | null>(null);
  const [totalVolume, setTotalVolume] = useState(0);
  const [copyTooltipVisible, setCopyTooltipVisible] = useState(false);
  const [isDragging, setIsDragging] = useState(false);
  const [showHoverTooltip, setShowHoverTooltip] = useState(false);
  const [currentProText, setCurrentProText] = useState(location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market' || location.pathname.slice(1) == 'limit' ? 'pro' : t(location.pathname.slice(1).toLowerCase()));
  const [refLink, setRefLink] = useState('');
  const [totalClaimableFees, setTotalClaimableFees] = useState(0);
  const [switched, setswitched] = useState(false);
  const [orderSizePercent, setOrderSizePercent] = useState(100);
  const [originalOrderSize, setOriginalOrderSize] = useState(0);
  const [spotSliderMode, setSpotSliderMode] = useState(() => {
    const saved = localStorage.getItem('crystal_spot_slider_mode');
    return saved || 'slider';
  });
  const [trenchesSliderMode, setTrenchesSliderMode] = useState<'presets' | 'increment' | 'slider'>('presets');
  const [trenchesSliderPresets, setTrenchesSliderPresets] = useState([25, 50, 75, 100]);
  const [trenchesSliderIncrement, setTrenchesSliderIncrement] = useState(5);
  const [spotSliderPresets, setSpotSliderPresets] = useState<number[]>(() => {
    const saved = localStorage.getItem('crystal_spot_slider_presets');
    return saved ? JSON.parse(saved) : [25, 50, 75];
  });
  const [spotSliderIncrement, setSpotSliderIncrement] = useState<number>(() => {
    const saved = localStorage.getItem('crystal__spot_slider_increment');
    return saved ? parseFloat(saved) : 10;
  });
  const [claimableFees, setClaimableFees] = useState<{ [key: string]: number } | undefined>(
    undefined
  );
  const [tokenIn, setTokenIn] = useState(() => {
    if (location.pathname.slice(1) == 'send') {
      const token = searchParams.get('token');
      if (token && tokendict[getAddress(token)]) {
        return getAddress(token);
      }
    } else {
      let token = searchParams.get('tokenIn');
      if (token && tokendict[getAddress(token)]) {
        return getAddress(token);
      } else {
        token = searchParams.get('tokenOut');
        if (token) {
          token = getAddress(token);
          for (const market in markets) {
            if (markets[market].baseAddress == token) {
              return markets[market].quoteAddress;
            }
          }
          for (const market in markets) {
            if (markets[market].quoteAddress == token) {
              return markets[market].baseAddress;
            }
          }
        }
      }
    }
    return usdc;
  });
  const [tokenOut, setTokenOut] = useState(() => {
    let tokenIn =
      location.pathname.slice(1) == 'send'
        ? searchParams.get('token')
        : searchParams.get('tokenIn');
    let tokenOut = searchParams.get('tokenOut');
    if (tokenIn && tokenOut) {
      tokenIn = getAddress(tokenIn);
      tokenOut = getAddress(tokenOut);
      if (tokendict[tokenIn] && tokendict[tokenOut]) {
        if (getMarket(tokenIn, tokenOut)) {
          return tokenOut;
        } else {
          const path = findShortestPath(tokenIn, tokenOut);
          if (path && path.length > 1 && location.pathname.slice(1) == 'swap') {
            return tokenOut;
          } else {
            for (const market in markets) {
              if (markets[market].baseAddress == tokenIn) {
                return markets[market].quoteAddress;
              }
            }
            for (const market in markets) {
              if (markets[market].quoteAddress == tokenIn) {
                return markets[market].baseAddress;
              }
            }
          }
        }
      }
    } else if (tokenIn) {
      tokenIn = getAddress(tokenIn);
      if (tokendict[tokenIn]) {
        for (const market in markets) {
          if (markets[market].baseAddress == tokenIn) {
            return markets[market].quoteAddress;
          }
        }
        for (const market in markets) {
          if (markets[market].quoteAddress == tokenIn) {
            return markets[market].baseAddress;
          }
        }
      }
    } else if (tokenOut) {
      tokenOut = getAddress(tokenOut);
      if (tokendict[tokenOut]) {
        return tokenOut;
      }
    }
    return eth;
  });
  const activeMarket = getMarket(tokenIn, tokenOut);
  const activeMarketKey = (activeMarket.baseAsset + activeMarket.quoteAsset).replace(
    new RegExp(
      `^${wethticker}|${wethticker}$`,
      'g'
    ),
    ethticker
  );
  const multihop = activeMarket.path.length > 2;
  const [usedRefLink, setUsedRefLink] = useState('');
  const [usedRefAddress, setUsedRefAddress] = useState(
    '0x0000000000000000000000000000000000000000' as `0x${string}`,
  );
  const [simpleView, setSimpleView] = useState(false);
  const [hideNotificationPopups, setHideNotificationPopups] = useState(() => {
    return JSON.parse(localStorage.getItem('crystal_hide_notification_popups') || 'false');
  });
  const [rpcUrl, setRpcUrl] = useState(() => localStorage.getItem('crystal_rpc_url') || '')
  const [graphUrl, setGraphUrl] = useState(() => localStorage.getItem('crystal_graph_url') || '')
  const [notificationPosition, setNotificationPosition] = useState(() => {
    const saved = localStorage.getItem('crystal_notification_position');
    return saved || 'bottom-right';
  });
  const [showPreview, setShowPreview] = useState(false);
  const [previewPosition, setPreviewPosition] = useState<string | null>(null);
  const [previewTimer, setPreviewTimer] = useState<NodeJS.Timeout | null>(null);
  const [previewExiting, setPreviewExiting] = useState(false);
  const [selectedToken, setSelectedToken] = useState<any>(null);
  const [onSelectTokenCallback, setOnSelectTokenCallback] = useState<((token: any) => void) | null>(null);
  const [vaultDepositAmounts, setVaultDepositAmounts] = useState<any>({
    shares: 0n,
    quote: 0n,
    base: 0n
  });
  const [vaultQuoteExceedsBalance, setVaultQuoteExceedsBalance] = useState(false);
  const [vaultBaseExceedsBalance, setVaultBaseExceedsBalance] = useState(false);
  const [withdrawShares, setWithdrawShares] = useState('');
  const [withdrawExceedsBalance, setWithdrawExceedsBalance] = useState(false);
  const [withdrawPreview, setWithdrawPreview] = useState<{ amountQuote: bigint, amountBase: bigint } | null>(null);
  const [vaultInputStrings, setVaultInputStrings] = useState<{ quote: string, base: string }>({ quote: '', base: '' });
  const [selectedVault, setselectedVault] = useState<any | null>(null);
  const [isVaultDepositSigning, setIsVaultDepositSigning] = useState(false);
  const [isVaultWithdrawSigning, setIsVaultWithdrawSigning] = useState(false);
  const updateNotificationPosition = (position: string) => {
    if (previewTimer) {
      clearTimeout(previewTimer);
      setPreviewTimer(null);
    }

    if (showPreview && previewPosition !== position) {
      setPreviewExiting(true);

      setTimeout(() => {
        setPreviewExiting(false);
        setShowPreview(false);

        setTimeout(() => {
          setPreviewPosition(position);
          setShowPreview(true);
          setNotificationPosition(position);
          localStorage.setItem('crystal_notification_position', position);

          const newTimer = setTimeout(() => {
            setPreviewExiting(true);
            setTimeout(() => {
              setShowPreview(false);
              setPreviewPosition(null);
              setPreviewExiting(false);
            }, 300);
          }, 3000);

          setPreviewTimer(newTimer);
        }, 50);
      }, 300);
    } else {
      setPreviewPosition(position);
      setShowPreview(true);
      setNotificationPosition(position);
      localStorage.setItem('crystal_notification_position', position);

      const newTimer = setTimeout(() => {
        setPreviewExiting(true);
        setTimeout(() => {
          setShowPreview(false);
          setPreviewPosition(null);
          setPreviewExiting(false);
        }, 300);
      }, 3000);

      setPreviewTimer(newTimer);
    }
  };
  const [hiddenPopupTypes, setHiddenPopupTypes] = useState(() => {
    return JSON.parse(localStorage.getItem('crystal_hidden_popup_types') || '{}');
  });
  const updateHiddenPopupType = (actionType: string, hide: boolean) => {
    const newHiddenTypes = { ...hiddenPopupTypes, [actionType]: hide };
    setHiddenPopupTypes(newHiddenTypes);
    localStorage.setItem('crystal_hidden_popup_types', JSON.stringify(newHiddenTypes));
  };
  const updateMultipleHiddenPopupTypes = (types: string[], hide: boolean) => {
    const newHiddenTypes = { ...hiddenPopupTypes };
    types.forEach(type => {
      newHiddenTypes[type] = hide;
    });
    setHiddenPopupTypes(newHiddenTypes);
    localStorage.setItem('crystal_hidden_popup_types', JSON.stringify(newHiddenTypes));
  };
  const [activeSettingsSection, setActiveSettingsSection] = useState(() => {
    const saved = localStorage.getItem('crystal_active_settings_section');
    return saved || 'general';
  });
  const updateActiveSettingsSection = (section: string) => {
    setActiveSettingsSection(section);
    localStorage.setItem('crystal_active_settings_section', section);
  };
  const [isMarksVisible, setIsMarksVisible] = useState(() => {
    const saved = localStorage.getItem('crystal_marks_visible');
    return saved !== null ? JSON.parse(saved) : true;
  });
  const [isOrdersVisible, setIsOrdersVisible] = useState(() => {
    const saved = localStorage.getItem('crystal_orders_visible');
    return saved !== null ? JSON.parse(saved) : true;
  });
  const [isOrderbookVisible, setIsOrderbookVisible] = useState(() => {
    const saved = localStorage.getItem('crystal_orderbook_visible');
    return saved !== null ? JSON.parse(saved) : true;
  });
  const [isOrderCenterVisible, setIsOrderCenterVisible] = useState(() => {
    const saved = localStorage.getItem('crystal_ordercenter_visible');
    return saved !== null ? JSON.parse(saved) : true;
  });
  const [orderbookWidth, setOrderbookWidth] = useState<number>(() => {
    const saved = localStorage.getItem('orderbookWidth');
    return saved ? parseInt(saved, 10) : 300;
  });
  const [orderCenterHeight, setOrderCenterHeight] = useState<number>(() => {
    const savedHeight = localStorage.getItem('orderCenterHeight');
    if (savedHeight !== null) {
      const parsedHeight = parseFloat(savedHeight);
      if (!isNaN(parsedHeight)) {
        return parsedHeight;
      }
    }

    if (window.innerHeight > 1080) return 367.58;
    if (window.innerHeight > 960) return 324.38;
    if (window.innerHeight > 840) return 282.18;
    if (window.innerHeight > 720) return 239.98;
    return 198.78;
  });
  const [selectedInterval, setSelectedInterval] = useState(() => {
    const savedTimeframe = localStorage.getItem('crystal_chart_timeframe');
    if (savedTimeframe !== null) {
      return (savedTimeframe === '1D'
        ? '1d'
        : savedTimeframe === '240'
          ? '4h'
          : savedTimeframe === '60'
            ? '1h'
            : savedTimeframe + 'm')
    }

    return '5m'
  });
  const [showChartOutliers, setShowChartOutliers] = useState(() => {
    return JSON.parse(localStorage.getItem('crystal_show_chart_outliers') || 'false');
  });
  const [isAudioEnabled, setIsAudioEnabled] = useState(() => {
    return JSON.parse(localStorage.getItem('crystal_audio_notifications') || 'false');
  });

  const [obInterval, setOBInterval] = useState<number>(() => {
    const stored = localStorage.getItem(
      `${activeMarket.baseAsset}_ob_interval`,
    );
    return stored !== null ? JSON.parse(stored) : 0.1;
  });
  // Spot settings
  const [spotOrderbookPosition, setSpotOrderbookPosition] = useState(() => {
    const saved = localStorage.getItem('crystal_spot_orderbook');
    return saved === 'left' ? 'left' : 'right';
  });

  const [spotLayoutSettings, setSpotLayoutSettings] = useState(() => {
    const saved = localStorage.getItem('crystal_spot_layout');
    return saved === 'alternative' ? 'alternative' : 'default';
  });

  // Perps settings
  const [perpsOrderbookPosition, setPerpsOrderbookPosition] = useState(() => {
    const saved = localStorage.getItem('crystal_perps_orderbook');
    return saved === 'left' ? 'left' : 'right';
  });

  const [perpsLayoutSettings, setPerpsLayoutSettings] = useState(() => {
    const saved = localStorage.getItem('crystal_perps_layout');
    return saved === 'alternative' ? 'alternative' : 'default';
  });

  // Spectra settings
  const [spectraOrderbookPosition, setSpectraOrderbookPosition] = useState(() => {
    const saved = localStorage.getItem('crystal_spectra_orderbook');
    return saved === 'left' ? 'left' : 'right';
  });

  const [spectraLayoutSettings, setSpectraLayoutSettings] = useState(() => {
    const saved = localStorage.getItem('crystal_spectra_layout');
    return saved === 'alternative' ? 'alternative' : 'default';
  });

  // Helper functions to get active settings
  const getActiveLayoutSettings = () => {
    switch (activeTradingMode) {
      case 'perps': return perpsLayoutSettings;
      case 'spectra': return spectraLayoutSettings;
      default: return spotLayoutSettings;
    }
  };

  const getActiveOrderbookPosition = () => {
    switch (activeTradingMode) {
      case 'perps': return perpsOrderbookPosition;
      case 'spectra': return spectraOrderbookPosition;
      default: return spotOrderbookPosition;
    }
  };
  const [popup, setpopup] = useState(0);
  const [slippage, setSlippage] = useState(() => {
    const saved = localStorage.getItem('crystal_slippage');
    return saved !== null ? BigInt(saved) : BigInt(9900);
  });
  const [slippageString, setSlippageString] = useState(() => {
    const saved = localStorage.getItem('crystal_slippage_string');
    return saved !== null ? saved : '1';
  });
  const [orderType, setorderType] = useState(() => {
    const saved = localStorage.getItem('crystal_order_type');
    return saved !== null ? JSON.parse(saved) : 1;
  });
  const [isStake, setIsStake] = useState(() => {
    return true
  })
  const [addliquidityonly, setAddLiquidityOnly] = useState(() => {
    const saved = localStorage.getItem('crystal_add_liquidity_only');
    return saved !== null ? JSON.parse(saved) : false;
  });
  const [tokenString, settokenString] = useState('');
  const [amountIn, setamountIn] = useState(() => {
    const amount = searchParams.get('amountIn');
    if (amount) {
      return BigInt(amount);
    }
    return BigInt(0);
  });
  const [amountOutSwap, setamountOutSwap] = useState(() => {
    if (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market') {
      const amount = searchParams.get('amountOut');
      if (amount) {
        setswitched(true);
        return BigInt(amount);
      }
      else if ((tokenIn == eth && tokenOut == weth) ||
        (tokenIn == weth && tokenOut == eth)) {
        return amountIn
      }
    }
    return BigInt(0);
  });
  const [inputString, setInputString] = useState(() => {
    const amount = searchParams.get('amountIn');
    if (amount && Number(amount) > 0) {
      return customRound(
        Number(amount) / 10 ** Number(tokendict[tokenIn].decimals),
        3,
      )
        .toString()
        .replace(/(\.\d*?[1-9])0+$/g, '$1')
        .replace(/\.0+$/, '');
    }
    return '';
  });
  const [outputString, setoutputString] = useState(() => {
    if (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market') {
      const amount = searchParams.get('amountOut');
      if (amount && Number(amount) > 0) {
        return customRound(
          Number(amount) / 10 ** Number(tokendict[tokenOut].decimals),
          3,
        )
          .toString()
          .replace(/(\.\d*?[1-9])0+$/g, '$1')
          .replace(/\.0+$/, '');
      }
      else if ((tokenIn == eth && tokenOut == weth) ||
        (tokenIn == weth && tokenOut == eth)) {
        return inputString
      }
    }
    return '';
  });

  const [quickAmounts, setQuickAmounts] = useState({
    new: localStorage.getItem('explorer-quickbuy-new') ?? '1',
    graduating: localStorage.getItem('explorer-quickbuy-graduating') ?? '1',
    graduated: localStorage.getItem('explorer-quickbuy-graduated') ?? '1',
  });

  const [activePresets, setActivePresets] = useState({
    new: 1,
    graduating: 1,
    graduated: 1
  });

  const buyPresets = {
    1: { slippage: '20', priority: '0.01', amount: '5' },
    2: { slippage: '15', priority: '0.02', amount: '20' },
    3: { slippage: '10', priority: '0.05', amount: '100' }
  };

  const sellPresets = {
    1: { slippage: '15', priority: '0.005' },
    2: { slippage: '12', priority: '0.01' },
    3: { slippage: '8', priority: '0.03' }
  };

  const [monPresets, setMonPresets] = useState(() => {
    try {
      const saved = localStorage.getItem('crystal_mon_presets');
      if (saved) {
        return JSON.parse(saved);
      }
      return [5, 20, 100, 500];
    } catch (error) {
      console.error('Error loading MON presets:', error);
      return [5, 20, 100, 500];
    }
  });

  useEffect(() => {
    try {
      localStorage.setItem('crystal_mon_presets', JSON.stringify(monPresets));
    } catch (error) {
      console.error('Error saving MON presets:', error);
    }
  }, [monPresets]);

  const setQuickAmount = (category: string, amount: string) => {
    setQuickAmounts(prev => ({
      ...prev,
      [category]: amount
    }));
  };

  const setActivePreset = (category: string, preset: number) => {
    setActivePresets(prev => ({
      ...prev,
      [category]: preset
    }));
  };

  const handleInputFocus = () => {
  };
  const [isComposing, setIsComposing] = useState(false);
  const [sendInputString, setsendInputString] = useState('');
  const [limitPriceString, setlimitPriceString] = useState('');
  const [allowance, setallowance] = useState(BigInt(0));
  const [warning, setwarning] = useState(0);
  const [lowestAsk, setlowestAsk] = useState(BigInt(0));
  const [highestBid, sethighestBid] = useState(BigInt(0));
  const [reserveQuote, setReserveQuote] = useState(BigInt(0));
  const [reserveBase, setReserveBase] = useState(BigInt(0));
  const [priceImpact, setPriceImpact] = useState('');
  const [averagePrice, setAveragePrice] = useState('');
  const [tradeFee, setTradeFee] = useState('');
  const [stateIsLoading, setStateIsLoading] = useState(true);
  const [displayValuesLoading, setDisplayValuesLoading] = useState(true);
  const [portfolioColorValue, setPortfolioColorValue] = useState('#00b894');
  const [recipient, setrecipient] = useState('');
  const [limitPrice, setlimitPrice] = useState(BigInt(0));
  const [limitChase, setlimitChase] = useState(true);
  const [isLimitEditing, setLimitIsEditing] = useState(false)
  const [orders, setorders] = useState<any[]>([]);
  const [canceledorders, setcanceledorders] = useState<any[]>([]);
  const [tradehistory, settradehistory] = useState<any[]>([]);
  const [tradesByMarket, settradesByMarket] = useState<any>({});
  const [tokenBalances, setTokenBalances] = useState<any>({});
  const [balanceAddress, setBalanceAddress] = useState<string>('')
  const [transactions, setTransactions] = useState<any[]>([]);
  const [mids, setmids] = useState<any>({});
  const [sliderPercent, setSliderPercent] = useState(0);
  const [displayMode, setDisplayMode] = useState('token');
  const [swapButton, setSwapButton] = useState(5);
  const [swapButtonDisabled, setSwapButtonDisabled] = useState(true);
  const [limitButton, setLimitButton] = useState(8);
  const [limitButtonDisabled, setLimitButtonDisabled] = useState(true);
  const [sendButton, setSendButton] = useState(5);
  const [sendButtonDisabled, setSendButtonDisabled] = useState(true);
  const [sendPopupButton, setSendPopupButton] = useState(5);
  const [sendPopupButtonDisabled, setSendPopupButtonDisabled] = useState(true);
  const [scaleStart, setScaleStart] = useState(BigInt(0));
  const [scaleStartString, setScaleStartString] = useState('');
  const [scaleEnd, setScaleEnd] = useState(BigInt(0));
  const [scaleEndString, setScaleEndString] = useState('');
  const [scaleOrders, setScaleOrders] = useState(BigInt(0));
  const [scaleOrdersString, setScaleOrdersString] = useState('');
  const [scaleSkew, setScaleSkew] = useState(1);
  const [scaleSkewString, setScaleSkewString] = useState('1.00');
  const [scaleButton, setScaleButton] = useState(12)
  const [scaleButtonDisabled, setScaleButtonDisabled] = useState(true)
  const [isBlurred, setIsBlurred] = useState(false);
  const [prevOrderData, setPrevOrderData] = useState<any[]>([])
  const [tradesloading, settradesloading] = useState(true);
  const [chartDays, setChartDays] = useState<number>(1);
  const [marketsData, setMarketsData] = useState<any[]>([]);
  const [chartData, setChartData] = useState<[DataPoint[], string, boolean]>([[], '', showChartOutliers]);
  const [editingOrder, setEditingOrder] = useState<any>(null);
  const [isEditingSigning, setIsEditingSigning] = useState(false);
  const openEditOrderPopup = (order: any) => {
    setEditingOrder(order);
    const currentPrice = order[0] / Number(markets[order[4]].priceFactor);
    setCurrentLimitPrice(currentPrice);
    setpopup(19);
  };
  const openEditOrderSizePopup = (order: any) => {
    setEditingOrderSize(order);

    const marketKey = order[4];
    const market = (markets as any)[marketKey];
    const isBuyOrder = order[3] === 1;

    const scaleFactor = Number(market.scaleFactor);
    const quoteDecimals = Number(market.quoteDecimals);
    const baseDecimals = Number(market.baseDecimals);

    let originalSize;

    if (isBuyOrder) {
      let quotePrice = 1;
      if (market.quoteAsset !== 'USDC') {
        const chainConfig = (settings.chainConfig as any)[activechain];
        const quotePriceKey = (market.quoteAsset == chainConfig?.wethticker ?
          chainConfig.ethticker : market.quoteAsset) + 'USDC';

        quotePrice = (trades as any)[quotePriceKey]?.[0]?.[3] /
          Number((markets as any)[quotePriceKey]?.priceFactor) || 1;
      }

      originalSize = parseFloat((order[8] * quotePrice / (scaleFactor * 10 ** quoteDecimals)).toFixed(2));
    } else {
      originalSize = parseFloat((order[2] / (10 ** baseDecimals)).toFixed(6));
    }

    setOriginalOrderSize(originalSize);
    setCurrentOrderSize(originalSize);
    setOrderSizePercent(100);
    setHasEditedSize(false);
    setpopup(20);
  };
  const handleEditLimitPriceConfirm = async () => {
    if (isEditingSigning || !editingOrder) return;

    try {
      setIsEditingSigning(true);
      await handleSetChain();
      const scaledPrice = Math.round(currentLimitPrice * Number(markets[editingOrder[4]].priceFactor));

      await sendUserOperationAsync({
        uo: replaceOrder(
          router,
          BigInt(0),
          (editingOrder[3] == 1 ? markets[editingOrder[4]].quoteAsset : markets[editingOrder[4]].baseAsset) == settings.chainConfig[activechain].ethticker ? settings.chainConfig[activechain].weth : editingOrder[3] == 1 ? markets[editingOrder[4]].quoteAddress : markets[editingOrder[4]].baseAddress,
          (editingOrder[3] == 1 ? markets[editingOrder[4]].baseAsset : markets[editingOrder[4]].quoteAsset) == settings.chainConfig[activechain].ethticker ? settings.chainConfig[activechain].weth : editingOrder[3] == 1 ? markets[editingOrder[4]].baseAddress : markets[editingOrder[4]].quoteAddress,
          false,
          false,
          BigInt(editingOrder[0]),
          BigInt(editingOrder[1]),
          BigInt(scaledPrice),
          BigInt(0),
          BigInt(Math.floor(Date.now() / 1000) + 900),
          usedRefAddress
        )
      });

      refetch();
      setpopup(0);
      setEditingOrder(null);
    } catch (error) {
      console.error('Error editing order:', error);
      const originalPrice = editingOrder[0] / Number(markets[editingOrder[4]].priceFactor);
      setCurrentLimitPrice(originalPrice);
    } finally {
      setIsEditingSigning(false);
    }
  };
  const [editingOrderSize, setEditingOrderSize] = useState<any>(null);
  const [currentOrderSize, setCurrentOrderSize] = useState<number>(0);
  const [hasEditedSize, setHasEditedSize] = useState(false);
  const [isEditingSizeSigning, setIsEditingSizeSigning] = useState(false);
  const handleEditOrderSizeConfirm = async () => {
    if (isEditingSizeSigning || !editingOrderSize) return;

    try {
      setIsEditingSizeSigning(true);
      await handleSetChain();
      const tokenAddress = editingOrderSize[3] === 1
        ? markets[editingOrderSize[4]].quoteAddress
        : markets[editingOrderSize[4]].baseAddress;
      const tokenDecimals = Number(tokendict[tokenAddress].decimals);
      const scaledSize = BigInt(
        Math.round(currentOrderSize * 10 ** tokenDecimals)
      );
      await sendUserOperationAsync({
        uo: replaceOrder(
          router,
          BigInt(0),
          (
            (editingOrderSize[3] === 1
              ? markets[editingOrderSize[4]].quoteAsset
              : markets[editingOrderSize[4]].baseAsset
            ) === settings.chainConfig[activechain].ethticker
              ? settings.chainConfig[activechain].weth
              : editingOrderSize[3] === 1
                ? markets[editingOrderSize[4]].quoteAddress
                : markets[editingOrderSize[4]].baseAddress
          ),
          (
            (editingOrderSize[3] === 1
              ? markets[editingOrderSize[4]].baseAsset
              : markets[editingOrderSize[4]].quoteAsset
            ) === settings.chainConfig[activechain].ethticker
              ? settings.chainConfig[activechain].weth
              : editingOrderSize[3] === 1
                ? markets[editingOrderSize[4]].baseAddress
                : markets[editingOrderSize[4]].quoteAddress
          ),
          false,
          false,
          BigInt(editingOrderSize[0]),
          BigInt(editingOrderSize[1]),
          BigInt(editingOrderSize[0]),
          scaledSize,
          BigInt(Math.floor(Date.now() / 1000) + 900),
          usedRefAddress
        )
      });

      refetch();
      setpopup(0);
      setEditingOrderSize(null);

    } catch (error) {
      console.error('Error editing order size:', error);
      setCurrentOrderSize(originalOrderSize);
    } finally {
      setIsEditingSizeSigning(false);
    }
  };
  const { chartData: portGraph, portChartLoading } = usePortfolioData(
    address,
    Object.values(tokendict),
    chartDays,
    tokenBalances,
    setTotalAccountValue,
    marketsData,
    stateIsLoading,
    (popup == 4 && connected) || location.pathname.slice(1) == 'portfolio',
    balanceAddress
  );
  const [tokenData, setTokenData] = useState<Partial<Token>>();
  const [isVertDragging, setIsVertDragging] = useState(false);
  const [trades, setTrades] = useState<
    [boolean, string, string, string, string][]
  >([]);
  const [spreadData, setSpreadData] = useState<any>({});
  const [activeSection, setActiveSection] = useState<
    'orders' | 'tradeHistory' | 'orderHistory' | 'balances'
  >(() => {
    const section = localStorage.getItem('crystal_oc_tab');
    return ['orders', 'tradeHistory', 'orderHistory', 'balances'].includes(
      String(section),
    )
      ? (section as 'orders' | 'tradeHistory' | 'orderHistory' | 'balances')
      : 'orders';
  });
  const [filter, setFilter] = useState<'all' | 'buy' | 'sell'>(() => {
    const f = localStorage.getItem('crystal_oc_filter');
    return ['all', 'buy', 'sell'].includes(String(f))
      ? (f as 'all' | 'buy' | 'sell')
      : 'all';
  });
  const [onlyThisMarket, setOnlyThisMarket] = useState<boolean>(() => {
    const only = localStorage.getItem('crystal_only_this_market');
    return only !== null ? JSON.parse(only) : false;
  });
  const [baseInterval, setBaseInterval] = useState<number>(0.1);
  const [viewMode, setViewMode] = useState<'both' | 'buy' | 'sell'>(() => {
    const stored = localStorage.getItem('ob_viewmode');
    return ['both', 'buy', 'sell'].includes(String(stored))
      ? (stored as 'both' | 'buy' | 'sell')
      : 'both';
  });
  const [obTab, setOBTab] = useState<'orderbook' | 'trades'>(() => {
    const stored = localStorage.getItem('ob_active_tab');

    if (['orderbook', 'trades'].includes(stored ?? '')) {
      return stored as 'orderbook' | 'trades';
    }

    return mobileView === 'trades' ? 'trades' : 'orderbook';
  });
  const [amountsQuote, setAmountsQuote] = useState(() => {
    const stored = localStorage.getItem('ob_amounts_quote');

    return ['Quote', 'Base'].includes(String(stored))
      ? (stored as string)
      : 'Quote';
  });
  const [perpsActiveMarketKey, setperpsActiveMarketKey] = useState(
    location.pathname.startsWith("/perps")
      ? location.pathname.split("/").pop()?.toUpperCase() == "PERPS" ? "BTCUSD" : location.pathname.split("/").pop()?.toUpperCase() || "BTCUSD"
      : "BTCUSD"
  );
  const [perpsMarketsData, setPerpsMarketsData] = useState<{ [key: string]: any }>({});
  const [perpsFilterOptions, setPerpsFilterOptions] = useState({});
  const [roundedBuyOrders, setRoundedBuyOrders] = useState<{ orders: any[], key: string, amountsQuote: string }>({ orders: [], key: '', amountsQuote });
  const [roundedSellOrders, setRoundedSellOrders] = useState<{ orders: any[], key: string, amountsQuote: string }>({ orders: [], key: '', amountsQuote });
  const [liquidityBuyOrders, setLiquidityBuyOrders] = useState<{ orders: any[], market: string }>({ orders: [], market: '' });
  const [liquiditySellOrders, setLiquiditySellOrders] = useState<{ orders: any[], market: string }>({ orders: [], market: '' });
  const [processedLogs, setProcessedLogs] = useState<Set<string>>(new Set());
  const [selectedIndex, setSelectedIndex] = useState<number>(0);
  const emptyFunction = useCallback(() => { }, []);
  const memoizedTokenList = useMemo(
    () => Object.values(tokendict),
    [tokendict],
  );
  const memoizedSortConfig = useMemo(() => ({ column: 'balance', direction: 'desc' }), []);
  const [isMobileDragging, setIsMobileDragging] = useState(false);
  const [mobileDragY, setMobileDragY] = useState(0);
  const [mobileStartY, setMobileStartY] = useState(0);
  const [currentLimitPrice, setCurrentLimitPrice] = useState<number>(0);
  const [currentLimitPriceString, setCurrentLimitPriceString] = useState('');
  const [keybindError, setKeybindError] = useState<string | null>(null);
  const [duplicateKeybind, setDuplicateKeybind] = useState<string | null>(null);
  const [keybinds, setKeybinds] = useState(() => {
    const saved = localStorage.getItem('crystal_keybinds');
    return saved ? JSON.parse(saved) : {
      submitTransaction: 'Enter',
      switchTokens: 'KeyZ',
      maxAmount: 'KeyA',
      focusInput: 'KeyF',
      openSettings: 'KeyP',
      openWallet: 'KeyI',
      openTokenInSelect: 'KeyQ',
      openTokenOutSelect: 'KeyE',
      cancelAllOrders: 'KeyC',
      cancelTopOrder: 'KeyX',
      toggleFavorite: 'KeyM',
      toggleSimpleView: 'KeyV',
      refreshQuote: 'KeyR',
    };
  });
  const [editingKeybind, setEditingKeybind] = useState<string | null>(null);
  const [isListeningForKey, setIsListeningForKey] = useState(false);
  const [mainWalletBalances, setMainWalletBalances] = useState<any>({})
  const [selectedTokenIndex, setSelectedTokenIndex] = useState(0);
  const scrollToToken = (index: number) => {
    const tokenListContainer = document.querySelector('.tokenlist');
    if (!tokenListContainer) return;

    const tokenButtons = tokenListContainer.querySelectorAll('.tokenbutton');
    const selectedButton = tokenButtons[index];

    if (selectedButton) {
      selectedButton.scrollIntoView({
        behavior: 'auto',
        block: 'nearest',
      });
    }
  };
  const handleTokenSelectKeyDown = (e: React.KeyboardEvent) => {
    const currentTokenList = Object.values(tokendict).filter(
      (token) =>
        token.ticker.toLowerCase().includes(tokenString.toLowerCase()) ||
        token.name.toLowerCase().includes(tokenString.toLowerCase()) ||
        token.address.toLowerCase().includes(tokenString.toLowerCase())
    );

    if (!currentTokenList || currentTokenList.length === 0) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedTokenIndex((prev) => {
          const newIndex = prev < currentTokenList.length - 1 ? prev + 1 : prev;
          scrollToToken(newIndex);
          return newIndex;
        });
        break;
      case 'ArrowUp':
        e.preventDefault();
        setSelectedTokenIndex((prev) => {
          const newIndex = prev > 0 ? prev - 1 : prev;
          scrollToToken(newIndex);
          return newIndex;
        });
        break;
      case 'Enter':
        e.preventDefault();
        if (currentTokenList[selectedTokenIndex]) {
          const tokenButtons = document.querySelectorAll('.tokenbutton');
          if (tokenButtons[selectedTokenIndex]) {
            (tokenButtons[selectedTokenIndex] as HTMLElement).click();
          }
        }
        break;
      case 'Escape':
        e.preventDefault();
        setpopup(0);
        settokenString('');
        break;
    }
  };
  const [orderSizeString, setOrderSizeString] = useState('');
  const displayValue = hasEditedSize
    ? orderSizeString
    : (originalOrderSize === 0 ? '' : originalOrderSize.toString());
  const [hasEditedPrice, setHasEditedPrice] = useState(false);
  const defaultGroups: AudioGroupSettings = {
    swap: true,
    order: true,
    transfer: true,
    approve: true,
  };

  const [audioGroups, setAudioGroups] = useState<AudioGroupSettings>(() => {
    const saved = localStorage.getItem('crystal_audio_groups');
    return saved ? JSON.parse(saved) : defaultGroups;
  });

  const toggleAudioGroup = (group: AudioGroups) => {
    setAudioGroups(prev => {
      const next = { ...prev, [group]: !prev[group] };
      localStorage.setItem('crystal_audio_groups', JSON.stringify(next));
      return next;
    });
  };

  function getGroupForAction(action: string): AudioGroups {
    if (action === 'swap' || action === 'swapFailed') return 'swap';
    if (['limit', 'fill', 'cancel', 'limitFailed'].includes(action)) return 'order';
    if (['send', 'sendFailed', 'wrap', 'unwrap', 'stake'].includes(action)) return 'transfer';
    if (action === 'approve') return 'approve';
    return 'swap';
  }
  // refs
  const popupref = useRef<HTMLDivElement>(null);
  const searchInputRef = useRef<HTMLInputElement>(null);
  const debounceTimerRef = useRef<NodeJS.Timeout | null>(null);
  const realtimeCallbackRef = useRef<any>({});
  const initialMousePosRef = useRef(0);
  const initialHeightRef = useRef(0);
  const txPending = useRef(false);
  const lastRefGroupFetch = useRef(0);
  const lastNonceGroupFetch = useRef(0);
  const nonces = useRef<any>(new Map())
  const blockNumber = useRef(0n);
  const wsRef = useRef<WebSocket | null>(null);
  const explorerWsRef = useRef<WebSocket | null>(null);
  const pingIntervalRef = useRef<any>(null);
  const reconnectIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const prevAmountsQuote = useRef(amountsQuote)
  const backAudioRef = useRef<HTMLAudioElement>(null);
  // more constants
  const languageOptions = [
    { code: 'EN', name: 'English' },
    { code: 'ES', name: 'Espaol' },
    { code: 'CN', name: '' },
    { code: 'JP', name: '' },
    { code: 'KR', name: '' },
    { code: 'RU', name: '' },
    { code: 'ID', name: 'Indonesia' },
    { code: 'VN', name: 'Ting Vit' },
    { code: 'PH', name: 'Filipino' },
  ];

  const isWrap =
    (tokenIn == eth && tokenOut == weth) ||
    (tokenIn == weth && tokenOut == eth);

  const loading =
    (stateloading ||
      tradesloading ||
      addressinfoloading);

  const monUsdPrice = (Number(tradesByMarket[ethticker + 'USDC']?.[0]?.[3]) / Number(markets[ethticker + 'USDC']?.priceFactor) || 1)

  const [walletTokenBalances, setWalletTokenBalances] = useState({});
  const [walletTotalValues, setWalletTotalValues] = useState({});
  const [walletsLoading, _setWalletsLoading] = useState(false);
  const [isTransitioning, setIsTransitioning] = useState(false);
  const [transitionDirection, setTransitionDirection] = useState('forward');
  const [exitingChallenge, setExitingChallenge] = useState(false);
  const [currentStep, setCurrentStep] = useState(0);
  const [animationStarted, setAnimationStarted] = useState(false);
  const [isUsernameSigning, setIsUsernameSigning] = useState(false);
  const [typedRefCode, setTypedRefCode] = useState(() => searchParams.get('ref') || '');
  const [usernameInput, setUsernameInput] = useState("");
  const [usernameError, setUsernameError] = useState("");
  const [isRefSigning, setIsRefSigning] = useState(false);
  const [error, setError] = useState('');
  const [username, setUsername] = useState('');
  const [isConnectEntering, setIsConnectEntering] = useState(false);
  const [usernameResolved, _setUsernameResolved] = useState(false);
  const [isWelcomeExiting, setIsWelcomeExiting] = useState(false);
  const [animating, setAnimating] = useState(false);
  const [sendAmountIn, setSendAmountIn] = useState(BigInt(0));
  const [sendInputAmount, setSendInputAmount] = useState('');
  const [sendUsdValue, setSendUsdValue] = useState('');
  const [sendTokenIn, setSendTokenIn] = useState(eth);
  const [isSigning, setIsSigning] = useState(false);
  const [isRefreshing, setIsRefreshing] = useState(false);
  const [searchQuery, setSearchQuery] = useState<string>('');
  const [sortField, setSortField] = useState<
    'volume' | 'price' | 'change' | 'favorites' | null
  >('volume');
  const [sortDirection, setSortDirection] = useState<
    'asc' | 'desc' | undefined
  >('desc');
  const { toggleFavorite } = useSharedContext();
  const [selectedVaultStrategy, setSelectedVaultStrategy] = useState<string | null>(null);
  const [vaultList, setVaultList] = useState<any>([]);
  const [isVaultsLoading, setIsVaultsLoading] = useState(true);
  const [depositors, setDepositors] = useState<any[]>([]);
  const [depositHistory, setDepositHistory] = useState<any[]>([]);
  const [withdrawHistory, setWithdrawHistory] = useState<any[]>([]);
  const [openOrders, setOpenOrders] = useState<any[]>([]);
  const [_allOrders, setAllOrders] = useState<any[]>([]);

  const wsCooldownRef = useRef<number>(0);
  const wsTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);

  const ALERT_DEFAULTS: AlertSettings = {
    soundAlertsEnabled: true,
    volume: 100,
    sounds: {
      newPairs: stepaudio,
      pairMigrating: stepaudio,
      migrated: stepaudio,
    },
  };

  const [alertSettings, setAlertSettings] = useState<AlertSettings>(() => {
    const saved = localStorage.getItem('explorer-alert-settings');
    if (!saved) return ALERT_DEFAULTS;
    try {
      const parsed = JSON.parse(saved);
      return {
        ...ALERT_DEFAULTS,
        ...parsed,
        sounds: { ...ALERT_DEFAULTS.sounds, ...(parsed?.sounds || {}) },
      };
    } catch {
      return ALERT_DEFAULTS;
    }
  });
  const [isTokenExplorerLoading, setIsTokenExplorerLoading] = useState(true);
  const initialState: State = {
    tokensByStatus: { new: [], graduating: [], graduated: [] },
    hidden: new Set(),
    loading: new Set(),
  };
  const [{ tokensByStatus, hidden, loading: teLoading }, dispatch] = useReducer(
    reducer,
    initialState,
  );
  const MARKET_UPDATE_EVENT = '0xc367a2f5396f96d105baaaa90fe29b1bb18ef54c712964410d02451e67c19d3e';
  const MARKET_CREATED_EVENT = '0x24ad3570873d98f204dae563a92a783a01f6935a8965547ce8bf2cadd2c6ce3b';
  const TRADE_EVENT = '0x9adcf0ad0cda63c4d50f26a48925cf6405df27d422a39c456b5f03f661c82982';
  const TRANSFER_TOPIC = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';

  const teRef = useRef<WebSocket | null>(null);
  const subIdRef = useRef(1);
  const pausedColumnRef = useRef<any>(null);
  const pausedTokenQueueRef = useRef<{
    new: Token[];
    graduating: Token[];
    graduated: Token[];
  }>({
    new: [],
    graduating: [],
    graduated: []
  });
  const alertSettingsRef = useRef<any>(alertSettings);
  const connectionStateRef = useRef<
    'disconnected' | 'connecting' | 'connected' | 'reconnecting'
  >('disconnected');
  const retryCountRef = useRef(0);
  const reconnectTimerRef = useRef<number | null>(null);
  const connectionAttemptsRef = useRef(0);
  const lastConnectionAttemptRef = useRef(0);
  const consecutiveFailuresRef = useRef(0);
  const memeRealtimeCallbackRef = useRef<any>({});

  const audio = useMemo(() => {
    const a = new Audio(stepaudio);
    a.volume = 1;
    return a;
  }, []);

  const sortedMarkets = (marketsData.sort((a, b) => {
    if (!sortField || !sortDirection) return 0;

    let aValue: number = 0;
    let bValue: number = 0;

    switch (sortField) {
      case 'volume':
        aValue = parseFloat(a.volume.toString().replace(/,/g, ''));
        bValue = parseFloat(b.volume.toString().replace(/,/g, ''));
        break;
      case 'price':
        aValue = parseFloat(a.currentPrice.toString().replace(/,/g, ''));
        bValue = parseFloat(b.currentPrice.toString().replace(/,/g, ''));
        break;
      case 'change':
        aValue = parseFloat(a.priceChange.replace(/[+%]/g, ''));
        bValue = parseFloat(b.priceChange.replace(/[+%]/g, ''));
        break;
      case 'favorites':
        aValue = favorites.includes(a.baseAddress.toLowerCase()) ? 1 : 0;
        bValue = favorites.includes(b.baseAddress.toLowerCase()) ? 1 : 0;
        break;
      default:
        return 0;
    }

    return sortDirection === 'asc' ? aValue - bValue : bValue - aValue;
  }));

  const newTxPopup = useCallback((
    _transactionHash: any,
    _currentAction: any,
    _tokenIn: any,
    _tokenOut: any,
    _amountIn: any,
    _amountOut: any,
    _price: any = 0,
    _address: any = '',
  ) => {
    const shouldPlay = isAudioEnabled && audioGroups[getGroupForAction(_currentAction)];
    if (shouldPlay) {
      audio.currentTime = 0;
      audio.play().catch(console.error);
    }
    setTransactions((prevTransactions) => {
      const newTransaction = {
        explorerLink: `${settings.chainConfig[activechain].explorer}/tx/${_transactionHash}`,
        currentAction: _currentAction,
        tokenIn: _tokenIn,
        tokenOut: _tokenOut,
        amountIn: _amountIn,
        amountOut: _amountOut,
        price: _price,
        address: _address,
        timestamp: Date.now(),
        isNew: true,
        isExiting: false,
        identifier: `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      };

      return [...prevTransactions, newTransaction];
    });
  }, [activechain, audio, isAudioEnabled, audioGroups]);

  const handleSetChain = useCallback(async () => {
    return await alchemyconfig?._internal?.wagmiConfig?.state?.connections?.entries()?.next()?.value?.[1]?.connector?.switchChain({ chainId: activechain as any });
  }, [activechain]);

  const formatDisplayValue = (
    rawAmount: number | bigint,
    decimals = 18,
    precision = 3,
  ) => {
    const actualAmount = customRound(
      Number(rawAmount) / 10 ** Number(decimals),
      precision,
    );

    if (parseFloat(actualAmount) < 1) {
      return actualAmount.toString();
    }

    if (parseFloat(actualAmount) >= 1e12) {
      return `${(parseFloat(actualAmount) / 1e12).toFixed(2)}T`;
    } else if (parseFloat(actualAmount) >= 1e9) {
      return `${(parseFloat(actualAmount) / 1e9).toFixed(2)}B`;
    } else if (parseFloat(actualAmount) >= 1e6) {
      return `${(parseFloat(actualAmount) / 1e6).toFixed(2)}M`;
    }

    return actualAmount.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
  };

  const formatUSDDisplay = (amount: number) => {
    if (amount === 0) return '$0.00';

    const absAmount = Math.abs(amount);
    if (absAmount >= 1e12) {
      return `$${(amount / 1e12).toFixed(2)}T`;
    } else if (absAmount >= 1e9) {
      return `$${(amount / 1e9).toFixed(2)}B`;
    } else if (absAmount >= 1e6) {
      return `$${(amount / 1e6).toFixed(2)}M`;
    }

    if (absAmount >= 1) {
      return `$${amount.toFixed(2).replace(/\B(?=(\d{3})+(?!\d))/g, ',')}`;
    }

    if (absAmount < 0.01) {
      return '<$0.01';
    }
    return `$${amount.toFixed(2)}`;
  };

  const calculateUSDValue = (
    amount: bigint,
    trades: any[],
    tokenAddress: string,
    market: any,
  ) => {
    if (amount === BigInt(0)) return 0;
    if (tokenAddress == market.quoteAddress && tokenAddress == usdc) {
      return Number(amount) / 10 ** 6;
    }
    else if (tokenAddress == market.quoteAddress) {
      return Number(amount) * tradesByMarket[(market.quoteAsset == wethticker ? ethticker : market.quoteAsset) + 'USDC']?.[0]?.[3]
        / Number(markets[(market.quoteAsset == wethticker ? ethticker : market.quoteAsset) + 'USDC']?.priceFactor) / 10 ** 18;
    }
    const latestPrice = fetchLatestPrice(trades, market);
    if (!latestPrice) return 0;
    const quotePrice = market.quoteAsset == 'USDC' ? 1 : tradesByMarket[(market.quoteAsset == wethticker ? ethticker : market.quoteAsset) + 'USDC']?.[0]?.[3]
      / Number(markets[(market.quoteAsset == wethticker ? ethticker : market.quoteAsset) + 'USDC']?.priceFactor)
    const usdValue = (Number(amount) * latestPrice * quotePrice / 10 ** Number(tokendict[tokenAddress].decimals));
    return Number(usdValue);
  };

  // calculate token value of usd
  const calculateTokenAmount = (
    usdValue: string,
    trades: any[],
    tokenAddress: string,
    market: any,
  ): bigint => {
    const usdNumeric = parseFloat(usdValue);
    if (!usdNumeric || usdNumeric == 0) return BigInt(0);

    if (tokenAddress === usdc) {
      return BigInt(Math.round(usdNumeric * 10 ** 6));
    }

    const latestPrice = fetchLatestPrice(trades, market);
    if (!latestPrice) return BigInt(0);
    const quotePrice = market.quoteAsset == 'USDC' ? 1 : tradesByMarket[(market.quoteAsset == wethticker ? ethticker : market.quoteAsset) + 'USDC']?.[0]?.[3]
      / Number(markets[(market.quoteAsset == wethticker ? ethticker : market.quoteAsset) + 'USDC']?.priceFactor)
    return BigInt(
      Math.round(
        (usdNumeric / (latestPrice * quotePrice)) *
        10 ** Number(tokendict[tokenAddress].decimals),
      ),
    );
  };

  const calculateSharesFromPercentage = (percentage: string, userShares: any) => {
    if (!percentage || !userShares) return '0';
    const percentageDecimal = parseFloat(percentage) / 100;
    const sharesToWithdraw = BigInt(Math.floor(Number(userShares) * percentageDecimal));
    return sharesToWithdraw.toString();
  };

  const handleWithdrawPercentageChange = (value: string) => {
    const cleanValue = value.replace(/[^\d.]/g, '');

    const numericValue = parseFloat(cleanValue);
    if (numericValue > 100) {
      setWithdrawPercentage('100');
    } else {
      setWithdrawPercentage(cleanValue);
    }

    setWithdrawExceedsBalance(false);
    const sharesToWithdraw = calculateSharesFromPercentage(cleanValue, selectedVault?.userShares);
    const userSharesBalance = BigInt(selectedVault?.userShares || 0);
    setWithdrawShares(sharesToWithdraw)
    setWithdrawPreview({ amountQuote: selectedVault?.quoteBalance * BigInt(sharesToWithdraw) / selectedVault?.totalShares, amountBase: selectedVault?.baseBalance * BigInt(sharesToWithdraw) / selectedVault?.totalShares });
    if (BigInt(sharesToWithdraw) > userSharesBalance) {
      setWithdrawExceedsBalance(true);
    }
  };

  const handleVaultDepositAmountChange = (type: 'quote' | 'base', value: string) => {
    if (/^\d*\.?\d{0,18}$/.test(value) && selectedVault) {
      const vaultTokenData = type == 'quote' ? tokendict[selectedVault?.quoteAsset] : tokendict[selectedVault?.baseAsset];
      if (vaultTokenData) {
        const tokenDecimals = Number(vaultTokenData.decimals) || 18;
        const enteredAmount = parseFloat(value) || 0;

        if (type === 'quote') {
          const amountBase = BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)) * selectedVault?.baseBalance / selectedVault?.quoteBalance
          const a = BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)) * selectedVault?.totalShares / selectedVault?.quoteBalance;
          const b = amountBase * selectedVault?.totalShares / selectedVault?.baseBalance
          const shares = a > b ? b : a
          setVaultInputStrings({
            [type]: value,
            'base': amountBase == 0n ? '' : customRound(
              Number(amountBase) /
              10 ** Number(tokendict[selectedVault?.baseAsset].decimals),
              3,
            ).toString()
          })
          setVaultDepositAmounts({
            shares,
            [type]: BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)),
            'base': amountBase,
          });
          setVaultQuoteExceedsBalance(BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)) > tokenBalances[vaultTokenData.address]);
          setVaultBaseExceedsBalance(amountBase > tokenBalances[selectedVault?.baseAsset]);
        } else {
          const amountQuote = BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)) * selectedVault?.quoteBalance / selectedVault?.baseBalance
          const a = BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)) * selectedVault?.totalShares / selectedVault?.baseBalance;
          const b = amountQuote * selectedVault?.totalShares / selectedVault?.quoteBalance
          const shares = a > b ? b : a
          setVaultInputStrings({
            [type]: value,
            'quote': amountQuote == 0n ? '' : customRound(
              Number(amountQuote) /
              10 ** Number(tokendict[selectedVault?.quoteAsset].decimals),
              3,
            ).toString()
          })
          setVaultDepositAmounts({
            shares,
            [type]: BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)),
            'quote': amountQuote,
          });
          setVaultBaseExceedsBalance(BigInt(Math.round(enteredAmount * 10 ** tokenDecimals)) > tokenBalances[vaultTokenData.address]);
          setVaultQuoteExceedsBalance(amountQuote > tokenBalances[selectedVault?.quoteAsset]);
        }
      }
    }
  };

  const isVaultDepositEnabled = () => {
    return vaultDepositAmounts.quote > 0n && vaultDepositAmounts.base > 0n &&
      !vaultQuoteExceedsBalance && !vaultBaseExceedsBalance && vaultDepositAmounts;
  };

  const getVaultDepositButtonText = () => {
    if (vaultQuoteExceedsBalance || vaultBaseExceedsBalance) {
      return 'Insufficient Balance';
    }
    if (!vaultDepositAmounts) {
      return 'Enter Amounts';
    }
    return 'Deposit';
  };

  const getWithdrawButtonText = () => {
    if (withdrawExceedsBalance) {
      return 'Insufficient Shares';
    }
    if (!withdrawPreview) {
      return 'Enter Amount';
    }
    return 'Withdraw';
  };

  const handleVaultDeposit = async () => {
    if (!selectedVault || !connected || !vaultDepositAmounts) return;

    const targetChainId = settings.chainConfig[activechain]?.chainId || activechain;
    if (userchain !== targetChainId) {
      handleSetChain();
      return;
    }

    try {
      setIsVaultDepositSigning(true);
      setDepositVaultError('');

      // Step 1: Validating
      setDepositVaultStep('validating');
      await new Promise(resolve => setTimeout(resolve, 500));

      const crystalVaultsAddress = settings.chainConfig[activechain]?.crystalVaults;
      const quoteTokenAddress = selectedVault.quoteAsset;
      const baseTokenAddress = selectedVault.baseAsset;

      const amountQuoteDesired = vaultDepositAmounts.quote;
      const amountBaseDesired = vaultDepositAmounts.base;

      const amountQuoteMin = (amountQuoteDesired * 50n) / 100n;
      const amountBaseMin = (amountBaseDesired * 50n) / 100n;

      // Step 2: Approve Quote Token
      if (quoteTokenAddress !== '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE') {
        setDepositVaultStep('approve-quote');
        const approveQuoteUo = {
          target: quoteTokenAddress as `0x${string}`,
          data: encodeFunctionData({
            abi: [{
              inputs: [
                { name: "spender", type: "address" },
                { name: "amount", type: "uint256" }
              ],
              name: "approve",
              outputs: [{ name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            }],
            functionName: "approve",
            args: [crystalVaultsAddress as `0x${string}`, maxUint256],
          }),
          value: 0n,
        };
        await sendUserOperationAsync({ uo: approveQuoteUo });
      }

      // Step 3: Approve Base Token
      if (baseTokenAddress !== '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE') {
        setDepositVaultStep('approve-base');
        const approveBaseUo = {
          target: baseTokenAddress as `0x${string}`,
          data: encodeFunctionData({
            abi: [{
              inputs: [
                { name: "spender", type: "address" },
                { name: "amount", type: "uint256" }
              ],
              name: "approve",
              outputs: [{ name: "", type: "bool" }],
              stateMutability: "nonpayable",
              type: "function",
            }],
            functionName: "approve",
            args: [crystalVaultsAddress as `0x${string}`, maxUint256],
          }),
          value: 0n,
        };
        await sendUserOperationAsync({ uo: approveBaseUo });
      }

      // Step 4: Deposit into vault
      setDepositVaultStep('depositing');

      const ethValue =
        quoteTokenAddress === '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' ? amountQuoteDesired :
          baseTokenAddress === '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' ? amountBaseDesired : 0n;

      const depositUo = {
        target: crystalVaultsAddress as `0x${string}`,
        data: encodeFunctionData({
          abi: CrystalVaultsAbi,
          functionName: "deposit",
          args: [
            selectedVault.address as `0x${string}`,
            quoteTokenAddress,
            baseTokenAddress,
            amountQuoteDesired,
            amountBaseDesired,
            amountQuoteMin,
            amountBaseMin,
          ],
        }),
        value: ethValue,
      };

      await sendUserOperationAsync({ uo: depositUo });

      // Step 5: Success
      setDepositVaultStep('success');

      setTimeout(() => {
        setVaultDepositAmounts({ shares: 0n, quote: 0n, base: 0n });
        setVaultInputStrings({ quote: '', base: '' });
        setVaultQuoteExceedsBalance(false);
        setVaultBaseExceedsBalance(false);
        setDepositVaultStep('idle');
        setDepositVaultError('');

        refetch();
        setpopup(0);
        setselectedVault(null);
      }, 2000);

    } catch (e: any) {
      console.error('Vault deposit error:', e);
      setDepositVaultError(e?.message || 'An error occurred while depositing. Please try again.');
      setDepositVaultStep('idle');
    } finally {
      setIsVaultDepositSigning(false);
    }
  };

  const handleVaultWithdraw = async () => {
    if (!selectedVault || !connected || !withdrawPreview) return;

    const targetChainId = settings.chainConfig[activechain]?.chainId || activechain;
    if (userchain !== targetChainId) {
      handleSetChain();
      return;
    }

    try {
      setIsVaultWithdrawSigning(true);

      const crystalVaultsAddress = settings.chainConfig[activechain]?.crystalVaults;

      const amountQuoteMin = (withdrawPreview.amountQuote * 50n) / 100n;
      const amountBaseMin = (withdrawPreview.amountBase * 50n) / 100n;

      const withdrawUo = {
        target: crystalVaultsAddress as `0x${string}`,
        data: encodeFunctionData({
          abi: CrystalVaultsAbi,
          functionName: "withdraw",
          args: [
            selectedVault.address as `0x${string}`,
            selectedVault.quoteAsset,
            selectedVault.baseAsset,
            BigInt(withdrawShares),
            amountQuoteMin,
            amountBaseMin,
          ],
        }),
        value: 0n,
      };

      await sendUserOperationAsync({ uo: withdrawUo });

      // Reset form
      setWithdrawShares('');
      setWithdrawExceedsBalance(false);
      setWithdrawPreview(null);

      refetch();
      setpopup(0);
      setselectedVault(null);

    } catch (e: any) {
      console.error('Vault withdraw error:', e);
    } finally {
      setIsVaultWithdrawSigning(false);
    }
  };

  // vaults
  async function fetchVaultBalances(vaults: { id: `0x${string}` }[]) {
    const calls = vaults.map(v => ({
      address: v.id,
      abi: CrystalVaultsAbi,
      functionName: 'getBalances' as const,
      args: [],
    }));

    const res = await readContracts(config, { contracts: calls });
    const out: Record<string, {
      quoteBalance: bigint,
      baseBalance: bigint,
      availableQuote: bigint,
      availableBase: bigint
    }> = {};

    res.forEach((r, i) => {
      const key = vaults[i].id.toLowerCase();
      if (r.status === 'success') {
        const [q, b, aq, ab] = r.result as any;
        out[key] = { quoteBalance: q, baseBalance: b, availableQuote: aq, availableBase: ab };
      } else {
        out[key] = { quoteBalance: 0n, baseBalance: 0n, availableQuote: 0n, availableBase: 0n };
      }
    });

    return out;
  }

  const fetchSubgraph = async (endpoint: string, query: string, variables?: Record<string, any>) => {
    const res = await fetch(endpoint, {
      method: 'POST',
      headers: { 'content-type': 'application/json' },
      body: JSON.stringify({ query, variables }),
    });
    if (!res.ok) throw new Error(`subgraph http ${res.status}`);
    const json = await res.json();
    if (json.errors?.length) throw new Error(json.errors.map((e: any) => e.message).join('; '));
    return json.data;
  };

  const toBigIntSafe = (v: any): bigint => {
    if (v === null || v === undefined) return 0n;
    if (typeof v === 'bigint') return v;
    if (typeof v === 'number') return BigInt(Math.trunc(v));
    return BigInt(String(v));
  };

  // fetch vaults list
  useEffect(() => {
    if (!['earn'].includes(location.pathname.split('/')[1]) || !address) return;
    let cancelled = false;
    (async () => {
      setIsVaultsLoading(true);

      const VAULTS_QUERY = `
          query VaultQuery($acct: Bytes!) {
            userVaultPositions(
              first: 1000,
              where: { account: $acct },
              orderBy: updatedAt,
              orderDirection: desc
            ) {
              vault { id }
              shares
              depositCount
              withdrawCount
              totalDepositedQuote
              totalDepositedBase
              totalWithdrawnQuote
              totalWithdrawnBase
              lastDepositAt
              lastWithdrawAt
              updatedAt
            }
            vaults(first: 1000, orderBy: lastUpdatedAt, orderDirection: desc) {
              id
              owner
              factory
              quoteAsset { id symbol name decimals }
              baseAsset { id symbol name decimals }
              symbol
              name
              description
              social1
              social2
              social3
              lockup
              decreaseOnWithdraw
              locked
              closed
              maxShares
              totalShares
              quoteBalance
              baseBalance
              depositCount
              withdrawalCount
              uniqueDepositors
              createdAt
              createdBlock
              createdTx
              lastUpdatedAt
            }
          }
      `;

      try {
        const dataVaults = await fetchSubgraph(SUBGRAPH_URL, VAULTS_QUERY, { acct: address.toLowerCase() });
        const rawVaults = (dataVaults?.vaults ?? []) as any[];
        const vaultsSlim = rawVaults.map((v: any) => ({
          id: getAddress(v.id) as `0x${string}`,
          quoteAsset: getAddress(v.quoteAsset?.id ?? v.quoteAsset) as `0x${string}`,
          baseAsset: getAddress(v.baseAsset?.id ?? v.baseAsset) as `0x${string}`,
        }));

        const onchainBalances = await fetchVaultBalances(vaultsSlim);

        let userSharesMap: Record<string, bigint> = {};
        if (address) {
          const pos = (dataVaults?.userVaultPositions ?? []) as any[];
          userSharesMap = pos.reduce((m: Record<string, bigint>, p: any) => {
            m[p.vault.id] = toBigIntSafe(p.shares);
            return m;
          }, {});
        }

        const mapped = rawVaults.map((v: any) => {
          const quoteAsset = getAddress(v.quoteAsset?.id?.toLowerCase?.() ?? v.quoteAsset?.id ?? v.quoteAsset);
          const baseAsset = getAddress(v.baseAsset?.id?.toLowerCase?.() ?? v.baseAsset?.id ?? v.baseAsset);
          const quoteTicker = v.quoteAsset.symbol;
          const baseTicker = v.baseAsset.symbol;

          const quoteDecimals = Number(v.quoteAsset?.decimals ?? tokendict[quoteAsset]?.decimals ?? 18);
          const baseDecimals = Number(v.baseAsset?.decimals ?? tokendict[baseAsset]?.decimals ?? 18);
          const vid = getAddress(v.id).toLowerCase();
          const qAddr = getAddress(v.quoteAsset?.id ?? v.quoteAsset) as `0x${string}`;
          const bAddr = getAddress(v.baseAsset?.id ?? v.baseAsset) as `0x${string}`;

          const oc = onchainBalances[vid] ?? { quoteBalance: 0n, baseBalance: 0n };

          return {
            id: v.id,
            address: v.id,
            owner: (v.owner ?? '').toLowerCase(),
            quoteAsset: qAddr,
            baseAsset: bAddr,
            quoteDecimals,
            baseDecimals,
            quoteTicker,
            baseTicker,
            totalShares: toBigIntSafe(v.totalShares),
            maxShares: toBigIntSafe(v.maxShares),
            quoteBalance: oc.quoteBalance,
            baseBalance: oc.baseBalance,
            lockup: Number(v.lockup ?? 0),
            locked: Boolean(v.locked),
            closed: Boolean(v.closed),
            name: v.name || (v.symbol ? `${v.symbol} Vault` : 'Vault'),
            desc: v.description ?? '',
            social1: v.social1 ?? '',
            social2: v.social2 ?? '',
            social3: v.social3 ?? '',
            type: 'Spot',
            userShares: userSharesMap[v.id] ?? 0n,
            decreaseOnWithdraw: Boolean(v.decreaseOnWithdraw),
          };
        });

        if (!cancelled) setVaultList(mapped);
      } catch (err) {
        console.error('subgraph fetch failed:', err);
        if (!cancelled) setVaultList([]);
      } finally {
        if (!cancelled) setIsVaultsLoading(false);
      }
    })();
    return () => { cancelled = true; };
  }, [address, activechain, tokendict, !['earn'].includes(location.pathname.split('/')[1])]);

  // details when a vault is selected
  useEffect(() => {
    if (!['earn'].includes(location.pathname.split('/')[1])) return;
    let cancelled = false;

    const run = async () => {
      if (!selectedVaultStrategy) {
        setDepositors([]);
        setDepositHistory([]);
        setOpenOrders([]);
        setAllOrders([]);
        return;
      }

      try {
        const VAULT_DETAIL_QUERY = `
          query VaultDetail($vault: Bytes!, $acct: ID!) {
            depositors: userVaultPositions(
              first: 1000
              where: { vault: $vault }
              orderBy: shares
              orderDirection: desc
            ) {
              id
              account { id }
              shares
              depositCount
              withdrawCount
              totalDepositedQuote
              totalDepositedBase
              totalWithdrawnQuote
              totalWithdrawnBase
              lastDepositAt
              lastWithdrawAt
              updatedAt
            }

            deposits: deposits(
              first: 1000
              where: { vault: $vault }
              orderBy: timestamp
              orderDirection: desc
            ) {
              id
              account { id }
              shares
              amountQuote
              amountBase
              txHash
              timestamp
            }

            withdrawals: withdrawals(
              first: 1000
              where: { vault: $vault }
              orderBy: timestamp
              orderDirection: desc
            ) {
              id
              account { id }
              shares
              amountQuote
              amountBase
              txHash
              timestamp
            }

            account(id: $acct) {
              id
              openOrderMap {
                shards(first: 1000) {
                  batches(first: 1000) {
                    orders(first: 1000) {
                      id
                      market { id baseAsset quoteAsset }
                      isBuy
                      price
                      originalSize
                      remainingSize
                      status
                      placedAt
                      updatedAt
                      txHash
                    }
                  }
                }
              }
              orderMap {
                shards(first: 1000) {
                  batches(first: 1000) {
                    orders(first: 1000) {
                      id
                      market { id baseAsset quoteAsset }
                      isBuy
                      price
                      originalSize
                      remainingSize
                      status
                      placedAt
                      updatedAt
                      txHash
                    }
                  }
                }
              }
              tradeMap {
                shards(first: 1000) {
                  batches(first: 1000) {
                    trades(first: 1000) {
                      id
                      market { id baseAsset quoteAsset }
                      amountIn
                      amountOut
                      startPrice
                      endPrice
                      isBuy
                      timestamp
                      tx
                    }
                  }
                }
              }
            }
          }
        `;

        const data = await fetchSubgraph(SUBGRAPH_URL, VAULT_DETAIL_QUERY, {
          vault: selectedVaultStrategy,
          acct: selectedVaultStrategy,
        });
        if (cancelled) return;

        const acct = data?.account ?? null;

        const flattenMap = (mapObj: any, key: 'orders' | 'trades') =>
          (mapObj?.shards ?? []).flatMap((s: any) => s?.batches ?? []).flatMap((b: any) => b?.[key] ?? []);
        const _openOrders = flattenMap(acct?.openOrderMap, "orders") || [];
        const _allOrders = flattenMap(acct?.orderMap, "orders") || [];

        setDepositors(data?.depositors ?? []);
        setDepositHistory(data?.deposits ?? []);
        setWithdrawHistory(data?.withdrawals ?? []);
        setOpenOrders(flattenMap(acct?.openOrderMap, 'orders') || []);
        setAllOrders(flattenMap(acct?.orderMap, 'orders') || []);

        const baseVault = (vaultList || []).find(
          (v: any) => (v?.address || '').toLowerCase() === selectedVaultStrategy.toLowerCase()
        );
        if (baseVault) {
          let userShares = baseVault.userShares ?? 0n;
          try {
            const me = (data?.depositors ?? []).find(
              (d: any) => (d?.account?.id || '').toLowerCase() === (address || '').toLowerCase()
            );
            if (me?.shares != null) {
              userShares = typeof me.shares === 'bigint' ? me.shares : BigInt(String(me.shares));
            }
          } catch { }

          if (!cancelled) {
            if (
              !selectedVault ||
              selectedVault.address !== baseVault.address ||
              String(selectedVault.userShares ?? '') !== String(userShares ?? '')
            ) {
              setselectedVault({
                ...baseVault,
                userShares,
              } as any);
            }
          }
        } else {
          if (!cancelled) setselectedVault(null);
        }

        const wssUrl = settings.chainConfig[activechain]?.wssurl;
        const factoryAddress = settings.chainConfig[activechain]?.crystalVaults;
        if (!wssUrl || !factoryAddress) return;

        const DEPOSIT_TOPIC = '0x4e2ca0515ed1aef1395f66b5303bb5d6f1bf9d61a353fa53f73f8ac9973fa9f6';
        const WITHDRAW_TOPIC = '0xebff2602b3f468259e1e99f613fed6691f3a6526effe6ef3e768ba7ae7a36c4f';
        const LOCK_TOPIC = '0x44427e3003a08f22cf803894075ac0297524e09e521fc1c15bc91741ce3dc159';
        const UNLOCK_TOPIC = '0x7e6adfec7e3f286831a0200a754127c171a2da564078722cb97704741bbdb0ea';
        const CLOSE_TOPIC = '0x13607bf9d2dd20e1f3a7daf47ab12856f8aad65e6ae7e2c75ace3d0c424a40e8';

        const vaultAddrLc = selectedVaultStrategy.toLowerCase();
        const quoteLc = (baseVault.quoteAsset || '').toLowerCase();
        const baseLc = (baseVault.baseAsset || '').toLowerCase();
        const factoryLc = (factoryAddress || '').toLowerCase();
        const vaultTopicLc = '0x' + vaultAddrLc.slice(2).padStart(64, '0');

        const ws = new WebSocket(wssUrl);

        const sendSub = (params: any) => {
          try {
            ws.send(JSON.stringify({
              id: Date.now(),
              jsonrpc: '2.0',
              method: 'eth_subscribe',
              params
            }));
          } catch { }
        };

        ws.onopen = () => {
          sendSub(['logs', {
            address: factoryLc,
            topics: [[DEPOSIT_TOPIC, WITHDRAW_TOPIC, LOCK_TOPIC, UNLOCK_TOPIC, CLOSE_TOPIC], vaultTopicLc],
          }]);
        };

        ws.onmessage = async ({ data }) => {
          let msg: any; try { msg = JSON.parse(data as any); } catch { return; }
          if (msg?.method !== 'eth_subscription') return;

          const log = msg.params?.result;
          const topic0 = String(log?.topics?.[0] || '').toLowerCase();

          const isVaultEvent =
            topic0 === DEPOSIT_TOPIC ||
            topic0 === WITHDRAW_TOPIC ||
            topic0 === LOCK_TOPIC ||
            topic0 === UNLOCK_TOPIC ||
            topic0 === CLOSE_TOPIC;

          const matchesVault =
            String(log?.topics?.[1] || '').toLowerCase() === vaultTopicLc ||
            String(log?.topics?.[2] || '').toLowerCase() === vaultTopicLc ||
            String(log?.topics?.[3] || '').toLowerCase() === vaultTopicLc;

          if (!isVaultEvent || !matchesVault) return;

          try {
            const topic1 = String(log?.topics?.[1] || '');
            const topic2 = String(log?.topics?.[2] || '');
            const vaultAddr = ('0x' + topic1.slice(-40)).toLowerCase() as `0x${string}`;
            const userAddr = ('0x' + topic2.slice(-40)).toLowerCase();

            const hex = String(log?.data || '0x');
            const words = hex.startsWith('0x') ? hex.slice(2).match(/.{1,64}/g) || [] : (hex.match(/.{1,64}/g) || []);
            const shares = words[0] ? BigInt('0x' + words[0]) : 0n;
            const amountQuote = words[1] ? BigInt('0x' + words[1]) : 0n;
            const amountBase = words[2] ? BigInt('0x' + words[2]) : 0n;

            const ts = Math.floor(Date.now() / 1000);
            const rowId = `${log.transactionHash}-${log.logIndex}`;

            if (topic0 === DEPOSIT_TOPIC) {
              const newRow = {
                id: rowId,
                account: { id: userAddr },
                shares: shares.toString(),
                amountQuote: amountQuote.toString(),
                amountBase: amountBase.toString(),
                txHash: log.transactionHash,
                timestamp: ts,
              };
              setDepositHistory(prev => {
                if (prev?.some((r: any) => r.id === rowId)) return prev;
                return [newRow, ...(prev || [])];
              });

              setDepositors(prev => {
                const list = Array.isArray(prev) ? [...prev] : [];
                const i = list.findIndex((d: any) => String(d?.account?.id || '').toLowerCase() === userAddr);
                if (i >= 0) {
                  const cur = list[i];
                  const curShares = toBigIntSafe(cur.shares);
                  const curDQ = toBigIntSafe(cur.totalDepositedQuote);
                  const curDB = toBigIntSafe(cur.totalDepositedBase);
                  list[i] = {
                    ...cur,
                    shares: (curShares + shares).toString(),
                    depositCount: Number(cur.depositCount || 0) + 1,
                    totalDepositedQuote: (curDQ + amountQuote).toString(),
                    totalDepositedBase: (curDB + amountBase).toString(),
                    lastDepositAt: ts,
                    updatedAt: ts,
                  };
                } else {
                  list.unshift({
                    id: `${userAddr}-${vaultAddr}`,
                    account: { id: userAddr },
                    shares: shares.toString(),
                    depositCount: 1,
                    withdrawCount: 0,
                    totalDepositedQuote: amountQuote.toString(),
                    totalDepositedBase: amountBase.toString(),
                    totalWithdrawnQuote: '0',
                    totalWithdrawnBase: '0',
                    lastDepositAt: ts,
                    lastWithdrawAt: 0,
                    updatedAt: ts,
                  });
                }
                return list;
              });
            }

            if (topic0 === WITHDRAW_TOPIC) {
              const newRow = {
                id: rowId,
                account: { id: userAddr },
                shares: shares.toString(),
                amountQuote: amountQuote.toString(),
                amountBase: amountBase.toString(),
                txHash: log.transactionHash,
                timestamp: ts,
              };
              setWithdrawHistory(prev => {
                if (prev?.some((r: any) => r.id === rowId)) return prev;
                return [newRow, ...(prev || [])];
              });

              setDepositors(prev => {
                const list = Array.isArray(prev) ? [...prev] : [];
                const i = list.findIndex((d: any) => String(d?.account?.id || '').toLowerCase() === userAddr);
                if (i >= 0) {
                  const cur = list[i];
                  const curShares = toBigIntSafe(cur.shares);
                  const curWQ = toBigIntSafe(cur.totalWithdrawnQuote);
                  const curWB = toBigIntSafe(cur.totalWithdrawnBase);
                  list[i] = {
                    ...cur,
                    shares: (curShares - shares >= 0n ? curShares - shares : 0n).toString(),
                    withdrawCount: Number(cur.withdrawCount || 0) + 1,
                    totalWithdrawnQuote: (curWQ + amountQuote).toString(),
                    totalWithdrawnBase: (curWB + amountBase).toString(),
                    lastWithdrawAt: ts,
                    updatedAt: ts,
                  };
                } else {
                  list.unshift({
                    id: `${userAddr}-${vaultAddr}`,
                    account: { id: userAddr },
                    shares: '0',
                    depositCount: 0,
                    withdrawCount: 1,
                    totalDepositedQuote: '0',
                    totalDepositedBase: '0',
                    totalWithdrawnQuote: amountQuote.toString(),
                    totalWithdrawnBase: amountBase.toString(),
                    lastDepositAt: 0,
                    lastWithdrawAt: ts,
                    updatedAt: ts,
                  });
                }
                return list;
              });
            }
          } catch (e) {
            console.warn('ws update failed', e);
          }

          const now = Date.now();
          wsCooldownRef.current = now;
          if (wsTimerRef.current) clearTimeout(wsTimerRef.current);
          wsTimerRef.current = setTimeout(async () => {
            const slim = (vaultList || []).map((v: any) => ({ id: v.id as `0x${string}` }));
            try {
              const oc = await fetchVaultBalances(slim);
              setVaultList((prev: any[]) =>
                prev.map((v: any) => {
                  const b = oc[String(v.id).toLowerCase()];
                  return b ? { ...v, quoteBalance: b.quoteBalance, baseBalance: b.baseBalance } : v;
                })
              );
            } catch (e) {
              console.warn('ws refresh failed', e);
            }
          }, 300);
        };

        ws.onerror = () => { };
        ws.onclose = () => { };

        const close = () => { try { ws.close(); } catch { } };
        const cleanupWs = close;
        const _noop = cleanupWs;

        return () => { };
      } catch (e) {
        console.error("vault detail fetch failed:", e);
        if (cancelled) return;
        setDepositors([]);
        setDepositHistory([]);
        setOpenOrders([]);
        setAllOrders([]);
      }
    };

    run();
    return () => { cancelled = true; };
  }, [selectedVaultStrategy, !['earn'].includes(location.pathname.split('/')[1])]);

  const findMarketForToken = useCallback((tokenAddress: string) => {
    for (const [marketKey, marketData] of Object.entries(markets)) {
      if (marketData.baseAddress === tokenAddress || marketData.quoteAddress === tokenAddress) {
        return { marketKey, marketData, trades: tradesByMarket[marketKey] };
      }
    }
    return null;
  }, [markets, tradesByMarket]);

  const saveSubWallets = useCallback((wallets: { address: string; privateKey: string; }[] | ((prevState: { address: string; privateKey: string; }[]) => { address: string; privateKey: string; }[])) => {
    setSubWallets((prevWallets) => {
      const newWallets = typeof wallets === 'function' ? wallets(prevWallets) : wallets;

      const deduplicated = deduplicateWallets(newWallets);

      localStorage.setItem('crystal_sub_wallets', JSON.stringify(deduplicated));
      return deduplicated;
    });
  }, []);

  // on market select
  const onMarketSelect = useCallback((market: { quoteAddress: any; baseAddress: any; }) => {
    if (!['swap', 'limit', 'send', 'scale', 'market'].includes(location.pathname.slice(1))) {
      if (simpleView) {
        navigate('/swap');
      }
      else {
        navigate('/market');
      }
    }

    setTokenIn(market.quoteAddress);
    setTokenOut(market.baseAddress);
    setswitched(false);
    setInputString('');
    setsendInputString('');
    setamountIn(BigInt(0));
    setSliderPercent(0);
    setamountOutSwap(BigInt(0));
    setoutputString('');
    setlimitChase(true);
    setScaleStart(BigInt(0))
    setScaleEnd(BigInt(0))
    setScaleStartString('')
    setScaleEndString('')
    const slider = document.querySelector('.balance-amount-slider');
    const popup = document.querySelector('.slider-percentage-popup');
    if (slider && popup) {
      (popup as HTMLElement).style.left = `${15 / 2}px`;
    }
  }, [location.pathname, simpleView]);

  // update limit amount
  const updateLimitAmount = useCallback((price: number, priceFactor: number, displayPriceFactor?: number) => {
    let newPrice = BigInt(Math.round(Number(price.toFixed(Math.floor(Math.log10(displayPriceFactor ? displayPriceFactor : priceFactor)))) * priceFactor));
    setlimitPrice(newPrice);
    setlimitPriceString(price.toFixed(Math.floor(Math.log10(displayPriceFactor ? displayPriceFactor : priceFactor))));
    setlimitChase(false);
    if (location.pathname.slice(1) == 'limit') {
      if (switched) {
        debouncedSetAmount(
          newPrice !== BigInt(0) && amountOutSwap !== BigInt(0)
            ? tokenIn === activeMarket?.baseAddress
              ? (amountOutSwap *
                (activeMarket.scaleFactor || BigInt(1))) /
              newPrice
              : (amountOutSwap * newPrice) /
              (activeMarket.scaleFactor || BigInt(1))
            : BigInt(0),
        );
        setInputString(
          (newPrice !== BigInt(0) && amountOutSwap !== BigInt(0)
            ? tokenIn === activeMarket?.baseAddress
              ? customRound(
                Number(
                  (amountOutSwap *
                    (activeMarket.scaleFactor || BigInt(1))) /
                  newPrice,
                ) /
                10 ** Number(tokendict[tokenIn].decimals),
                3,
              )
              : customRound(
                Number(
                  (amountOutSwap * newPrice) /
                  (activeMarket.scaleFactor || BigInt(1)),
                ) /
                10 ** Number(tokendict[tokenIn].decimals),
                3,
              )
            : ''
          ).toString(),
        );
        const percentage =
          tokenBalances[tokenIn] === BigInt(0)
            ? 0
            : Math.min(
              100,
              Math.floor(
                Number(
                  (newPrice !== BigInt(0) &&
                    amountOutSwap !== BigInt(0)
                    ? tokenIn === activeMarket?.baseAddress
                      ? (amountOutSwap *
                        (activeMarket.scaleFactor ||
                          BigInt(1))) /
                      newPrice
                      : (amountOutSwap * newPrice) /
                      (activeMarket.scaleFactor || BigInt(1))
                    : BigInt(0)) * BigInt(100) / tokenBalances[tokenIn]
                )
              ),
            );
        setSliderPercent(percentage);
        const slider = document.querySelector(
          '.balance-amount-slider',
        );
        const popup = document.querySelector(
          '.slider-percentage-popup',
        );
        if (slider && popup) {
          const rect = slider.getBoundingClientRect();
          (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
            }px`;
        }
      }
      else {
        setamountOutSwap(
          newPrice != BigInt(0) && amountIn != BigInt(0)
            ? tokenIn === activeMarket?.baseAddress
              ? (amountIn * newPrice) / (activeMarket.scaleFactor || BigInt(1))
              : (amountIn * (activeMarket.scaleFactor || BigInt(1))) / newPrice
            : BigInt(0),
        );
        setoutputString(
          (newPrice != BigInt(0) && amountIn != BigInt(0)
            ? tokenIn === activeMarket?.baseAddress
              ? customRound(
                Number(
                  (amountIn * newPrice) / (activeMarket.scaleFactor || BigInt(1)),
                ) /
                10 ** Number(tokendict[tokenOut].decimals),
                3,
              )
              : customRound(
                Number(
                  (amountIn * (activeMarket.scaleFactor || BigInt(1))) / newPrice,
                ) /
                10 ** Number(tokendict[tokenOut].decimals),
                3,
              )
            : ''
          ).toString(),
        );
      }
    }
  }, [activeMarket?.scaleFactor,
  activeMarket?.baseAddress,
    switched,
    amountIn,
    amountOutSwap,
    tokenIn,
    tokenOut,
  tokenBalances[tokenIn],
    tokendict,
  location.pathname.slice(1),
  ]);

  // set amount for a token
  const debouncedSetAmount = (amount: bigint) => {
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }
    setStateIsLoading(true);
    debounceTimerRef.current = setTimeout(() => {
      setamountIn(amount);
      debounceTimerRef.current = null;
    }, 300);
  };

  // set amountout for a token
  const debouncedSetAmountOut = (amount: bigint) => {
    if (debounceTimerRef.current) {
      clearTimeout(debounceTimerRef.current);
    }
    setStateIsLoading(true);
    debounceTimerRef.current = setTimeout(() => {
      setamountOutSwap(amount);
      debounceTimerRef.current = null;
    }, 300);
  };

  // data loop, reuse to have every single rpc call method in this loop
  const { data: rpcQueryData, isLoading, dataUpdatedAt, refetch } = useQuery({
    queryKey: [
      'crystal_rpc_reads',
      switched,
      String(amountOutSwap),
      String(amountIn),
      tokenIn,
      tokenOut,
      address,
      activeMarketKey,
      isStake,
    ],
    queryFn: async () => {
      let gasEstimateCall: any = null;
      let gasEstimate: bigint = 0n;

      if (address && (amountIn || amountOutSwap)) {
        try {
          const deadline = BigInt(Math.floor(Date.now() / 1000) + 900);

          const path = activeMarket.path[0] === tokenIn ? activeMarket.path : [...activeMarket.path].reverse();

          let tx: any = null;

          if (tokenIn === eth && tokenOut === weth) {
            tx = wrapeth(amountIn, weth);
          } else if (tokenIn === weth && tokenOut === eth) {
            tx = unwrapeth(amountIn, weth);
          } else if (tokenIn === eth && tokendict[tokenOut]?.lst && isStake) {
            tx = stake(tokenOut, address, amountIn);
          } else if (orderType === 1 || multihop) {
            const slippageAmount = !switched
              ? (amountOutSwap * slippage + 5000n) / 10000n
              : (amountIn * 10000n + slippage / 2n) / slippage;

            if (tokenIn === eth && tokenOut !== eth) {
              tx = !switched
                ? swapExactETHForTokens(router, amountIn, slippageAmount, path, address, deadline, usedRefAddress)
                : swapETHForExactTokens(router, amountOutSwap, slippageAmount, path, address, deadline, usedRefAddress);
            } else if (tokenIn !== eth && tokenOut === eth) {
              tx = !switched
                ? swapExactTokensForETH(router, amountIn, slippageAmount, path, address, deadline, usedRefAddress)
                : swapTokensForExactETH(router, amountOutSwap, slippageAmount, path, address, deadline, usedRefAddress);
            } else {
              tx = !switched
                ? swapExactTokensForTokens(router, amountIn, slippageAmount, path, address, deadline, usedRefAddress)
                : swapTokensForExactTokens(router, amountOutSwap, slippageAmount, path, address, deadline, usedRefAddress);
            }
          } else {
            const amount = !switched ? amountIn : amountOutSwap;
            const limitPrice = tokenIn === activeMarket.quoteAddress
              ? (lowestAsk * 10000n + slippage / 2n) / slippage
              : (highestBid * slippage + 5000n) / 10000n;

            tx = _swap(
              router,
              tokenIn === eth
                ? (!switched ? amountIn : BigInt((amountIn * 10000n + slippage / 2n) / slippage))
                : BigInt(0),
              activeMarket.path[0] === tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
              activeMarket.path[0] === tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
              !switched,
              BigInt(0),
              amount,
              limitPrice,
              deadline,
              usedRefAddress
            );
          }

          if (tx) {
            gasEstimateCall = {
              jsonrpc: '2.0',
              id: 1,
              method: 'eth_estimateGas',
              params: [{
                from: address as `0x${string}`,
                to: tx.target,
                data: tx.data,
                value: tx.value ? `0x${tx.value.toString(16)}` : '0x'
              }]
            };
          }
        } catch (e) {
          gasEstimateCall = null;
        }
      }

      const mainGroup: any = [
        {
          disabled: (switched ? amountOutSwap : amountIn) > maxUint256,
          to: router,
          abi: CrystalRouterAbi,
          functionName: switched ? 'getAmountsIn' : 'getAmountsOut',
          args: [
            switched ? amountOutSwap : amountIn,
            activeMarket.path[0] === tokenIn ? activeMarket.path : [...activeMarket.path].reverse()
          ]
        },
        {
          disabled: !address,
          to: tokenIn === eth ? weth : tokenIn,
          abi: TokenAbi,
          functionName: 'allowance',
          args: [
            address as `0x${string}`,
            router
          ]
        },
        {
          disabled: !address,
          to: balancegetter,
          abi: CrystalDataHelperAbi,
          functionName: 'batchBalanceOf',
          args: [
            address as `0x${string}`,
            [...Object.values(tokendict).map((t: any) => t.address), ...Object.values(markets).map((t: any) => t.address)]
          ]
        },
        {
          to: balancegetter,
          abi: CrystalDataHelperAbi,
          functionName: 'getMarketData',
          args: [router, activeMarket?.address, BigInt(1000000), BigInt(1), BigInt(100)]
        },
        {
          to: balancegetter,
          abi: CrystalDataHelperAbi,
          functionName: 'getPrices',
          args: [
            router, Array.from(new Set(Object.values(markets).map((m: any) => m.address)))
          ]
        },
        ...(isStake && tokenIn == eth && (tokendict[tokenOut] as any)?.lst
          ? [{
            to: tokenOut,
            abi: tokenOut === '0xe1d2439b75fb9746E7Bc6cB777Ae10AA7f7ef9c5' ? sMonAbi : shMonadAbi,
            functionName: switched ? 'convertToAssets' : 'convertToShares',
            args: [switched ? amountOutSwap : amountIn]
          }]
          : [])
      ];

      const refGroup: any = [
        {
          to: settings.chainConfig[activechain].referralManager,
          abi: CrystalReferralAbi as any,
          functionName: 'getRefInfo',
          args: [address ?? '0x0000000000000000000000000000000000000000'],
        },
        ...Array.from(
          new Set(
            Object.values(tokendict).map(
              (market) => market.address as `0x${string}`
            )
          )
        ).flatMap((marketAddress: any) => ({
          to: router as `0x${string}`,
          abi: CrystalRouterAbi,
          functionName: 'claimableRewards',
          args: [marketAddress, address ?? '0x0000000000000000000000000000000000000000'],
        })),
      ]

      const oneCTDepositGroup: any = [
        {
          disabled: !scaAddress,
          to: balancegetter,
          abi: CrystalDataHelperAbi,
          functionName: 'batchBalanceOf',
          args: [
            scaAddress as `0x${string}`,
            Object.values(tokendict).map((t: any) => t.address)
          ]
        },
      ]

      const groups: any = {
        mainGroup
      };

      if (Date.now() - lastRefGroupFetch.current >= 9500) {
        lastRefGroupFetch.current = Date.now();
        groups.refGroup = refGroup;
      }

      if (popup == 25) {
        groups.oneCTDepositGroup = oneCTDepositGroup;
      }

      const callData: any = []
      const callMapping: any = []

      const groupResults: any = {};
      Object.keys(groups).forEach(groupKey => {
        groupResults[groupKey] = [];
      });

      Object.entries(groups).forEach(([groupKey, group]: [string, any]) => {
        group.forEach((call: any, callIndex: number) => {
          if (!call.disabled) {
            try {
              callData.push({
                target: call.to || call.address,
                callData: encodeFunctionData({
                  abi: call.abi,
                  functionName: call.functionName,
                  args: call.args
                })
              });

              callMapping.push({
                groupKey,
                callIndex
              });
            } catch (e: any) {
              while (groupResults[groupKey].length < callIndex) {
                groupResults[groupKey].push(null);
              }
              groupResults[groupKey][callIndex] = { error: e.message, result: undefined, status: "failure" };
            }
          }
          else {
            while (groupResults[groupKey].length < callIndex) {
              groupResults[groupKey].push(null);
            }
            groupResults[groupKey][callIndex] = { error: "param missing", result: undefined, status: "failure" };
          }
        });
      });

      const multicallData: any = encodeFunctionData({
        abi: [{
          inputs: [
            { name: 'requireSuccess', type: 'bool' },
            {
              components: [
                { name: 'target', type: 'address' },
                { name: 'callData', type: 'bytes' }
              ], name: 'calls', type: 'tuple[]'
            }
          ],
          name: 'tryBlockAndAggregate',
          outputs: [
            { name: 'blockNumber', type: 'uint256' },
            { name: 'blockHash', type: 'bytes32' },
            {
              components: [
                { name: 'success', type: 'bool' },
                { name: 'returnData', type: 'bytes' }
              ], name: 'returnData', type: 'tuple[]'
            }
          ],
          stateMutability: 'view',
          type: 'function'
        }],
        functionName: 'tryBlockAndAggregate',
        args: [false, callData]
      })

      const response: any = await fetch(HTTP_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify([{
          jsonrpc: '2.0',
          id: 1,
          method: 'eth_call',
          params: [{ to: settings.chainConfig[activechain].multicall3, data: multicallData }, 'latest']
        }, ...(gasEstimateCall ? [gasEstimateCall] : [])])
      })

      const json: any = await response.json()


      const returnData: any = decodeFunctionResult({
        abi: [{
          inputs: [
            { name: 'requireSuccess', type: 'bool' },
            {
              components: [
                { name: 'target', type: 'address' },
                { name: 'callData', type: 'bytes' }
              ], name: 'calls', type: 'tuple[]'
            }
          ],
          name: 'tryBlockAndAggregate',
          outputs: [
            { name: 'blockNumber', type: 'uint256' },
            { name: 'blockHash', type: 'bytes32' },
            {
              components: [
                { name: 'success', type: 'bool' },
                { name: 'returnData', type: 'bytes' }
              ], name: 'returnData', type: 'tuple[]'
            }
          ],
          stateMutability: 'view',
          type: 'function'
        }],
        functionName: 'tryBlockAndAggregate',
        data: json[0].result
      })

      blockNumber.current = returnData?.[0]
      returnData?.[2]?.forEach((data: any, responseIndex: number) => {
        const { groupKey, callIndex } = callMapping[responseIndex] || {};
        if (groupKey === undefined) return;
        const originalCall = groups[groupKey][callIndex];
        while (groupResults[groupKey].length <= callIndex) {
          groupResults[groupKey].push(null);
        }
        if (data?.success == true) {
          try {
            const decodedResult = decodeFunctionResult({
              abi: originalCall.abi,
              functionName: originalCall.functionName,
              data: data?.returnData
            });
            groupResults[groupKey][callIndex] = { result: decodedResult, status: "success" };
          } catch (e: any) {
            groupResults[groupKey][callIndex] = { error: e.message, result: undefined, status: "failure" };
          }
        }
        else {
          groupResults[groupKey][callIndex] = { error: 'call reverted', result: undefined, status: "failure" };
        }
      });

      if (json?.[1]?.result) {
        gasEstimate = BigInt(json[1].result)
      }

      return { readContractData: groupResults, gasEstimate: gasEstimate }
    },
    enabled: !!activeMarket && !!tokendict && !!markets,
    refetchInterval: ['market', 'limit', 'send', 'scale'].includes(location.pathname.slice(1)) && !simpleView ? 300 : 5000,
    gcTime: 0,
  })

  const handleImportWallets = (walletsText: string, addToSingleGroup: boolean) => {
    console.log('Importing wallets:', walletsText, 'Add to single group:', addToSingleGroup);

    try {
      const lines = walletsText.trim().split('\n');
      const newWallets = lines.map((line, index) => {
        const parts = line.split(',');
        return {
          id: Date.now().toString() + index,
          address: parts[0]?.trim() || '',
          name: parts[1]?.trim() || `Imported Wallet ${index + 1}`,
          emoji: parts[2]?.trim() || '',
          balance: 0,
          lastActive: 'Never'
        };
      }).filter(w => w.address);

      setTrackedWallets(prev => [...prev, ...newWallets]);
      setpopup(0);
    } catch (e) {
      console.error('Failed to parse wallets:', e);
    }
  };

  const handleSearchKeyDown = (
    e: ReactKeyboardEvent<HTMLInputElement>,
  ): void => {
    if (e.key === 'Enter' && sortedMarkets.length > 0) {
      e.preventDefault();
      const selectedMarket = sortedMarkets[selectedIndex];
      setSearchQuery('');
      setpopup(0);
      onMarketSelect(selectedMarket)
    } else if (e.key === 'Escape') {
      setSearchQuery('');
    } else if (e.key === 'ArrowDown') {
      e.preventDefault();
      const newIndex = selectedIndex < sortedMarkets.length - 1 ? selectedIndex + 1 : selectedIndex;
      setSelectedIndex(newIndex);

      const selectedItem = document.getElementById(`search-market-item-${newIndex}`);
      if (selectedItem) {
        selectedItem.scrollIntoView({ block: 'nearest', behavior: 'auto' });
      }

      refocusSearchInput();
    } else if (e.key === 'ArrowUp') {
      e.preventDefault();
      const newIndex = selectedIndex > 0 ? selectedIndex - 1 : 0;
      setSelectedIndex(newIndex);

      const selectedItem = document.getElementById(`search-market-item-${newIndex}`);
      if (selectedItem) {
        selectedItem.scrollIntoView({ block: 'nearest', behavior: 'auto' });
      }

      refocusSearchInput();
    }
  };

  useEffect(() => {
    if (showSendDropdown) {
      const handleClick = (event: MouseEvent) => {
        if (sendButtonRef.current && sendButtonRef.current.contains(event.target as Node)) {
          return;
        }

        if (sendDropdownRef.current && !sendDropdownRef.current.contains(event.target as Node)) {
          setShowSendDropdown(false);
        }
      };

      document.addEventListener('mousedown', handleClick);
      return () => {
        document.removeEventListener('mousedown', handleClick);
      };
    }
  }, [showSendDropdown])

  useEffect(() => {
    setSelectedIndex(0);
    setSelectedTokenIndex(0);
  }, [searchQuery, tokenString, popup]);

  const refocusSearchInput = () => {
    if (searchInputRef.current) {
      searchInputRef.current.focus();
    }
  };

  const handleSort = (field: 'volume' | 'price' | 'change' | 'favorites') => {
    if (sortField === field) {
      if (sortDirection === 'asc') {
        setSortDirection('desc');
      } else if (sortDirection === 'desc') {
        setSortField(null);
        setSortDirection(undefined);
      }
    } else {
      setSortField(field);
      setSortDirection('asc');
    }
  };

  const setScaleOutput = (
    amountIn: number,
    startPrice: number,
    endPrice: number,
    numOrders: number,
    skew: number,
  ) => {
    const prices: number[] = Array.from({ length: numOrders }, (_, i) =>
      Math.round(
        startPrice +
        ((endPrice - startPrice) * i) /
        (numOrders - 1)
      )
    );

    let orderSizes: number[];
    let factorSum: number;

    if (tokenIn == activeMarket.quoteAddress) {
      factorSum = prices.reduce(
        (sum, price, i) => sum + price * (1 + ((skew - 1) * i) / (numOrders - 1)),
        0
      );
      const x = (Number(amountIn) * Number(activeMarket.scaleFactor)) / factorSum;
      orderSizes = Array.from({ length: numOrders }, (_, i) =>
        Math.round(x * (1 + ((skew - 1) * i) / (numOrders - 1)))
      );
    } else {
      factorSum = Array.from({ length: numOrders }).reduce(
        (sum: number, _, i) => sum + (1 + ((skew - 1) * i) / (numOrders - 1)),
        0
      );
      const x = Number(amountIn) / factorSum;
      orderSizes = Array.from({ length: numOrders }, (_, i) =>
        Math.round(x * (1 + ((skew - 1) * i) / (numOrders - 1)))
      );
    }
    const orderUsdValues: number[] = prices.map((price, i) =>
      Math.round((price * orderSizes[i]) / Number(activeMarket.scaleFactor)))
    let totalUsdValue = orderUsdValues.reduce((sum, val) => sum + val, 0);
    let totalTokenValue = orderSizes.reduce((sum, val) => sum + val, 0);
    if (tokenIn == activeMarket.quoteAddress) {
      if (totalUsdValue != amountIn) {
        orderUsdValues[orderUsdValues.length - 1] += (amountIn - totalUsdValue)
        totalUsdValue = amountIn
      }
      setamountOutSwap(BigInt(totalTokenValue))
      setoutputString(
        totalTokenValue
          /
          10 ** Number(tokendict[tokenOut].decimals)
          ? customRound(
            totalTokenValue
            /
            10 ** Number(tokendict[tokenOut].decimals),
            3,
          ) : ''
      );
    }
    else {
      if (totalTokenValue != amountIn) {
        orderSizes[orderSizes.length - 1] += (amountIn - totalTokenValue)
        totalTokenValue = amountIn
      }
      setamountOutSwap(BigInt(totalUsdValue))
      setoutputString(
        totalUsdValue
          /
          10 ** Number(tokendict[tokenOut].decimals)
          ? customRound(
            totalUsdValue
            /
            10 ** Number(tokendict[tokenOut].decimals),
            3,
          ) : ''
      );
    }
  }

  const calculateScaleOutput = (
    amountIn: bigint,
    startPrice: number,
    endPrice: number,
    numOrders: number,
    skew: number,
  ) => {
    const prices: number[] = Array.from({ length: numOrders }, (_, i) => {
      const p = startPrice + ((endPrice - startPrice) * i) / (numOrders - 1)
      return activeMarket.marketType !== 0 ? Math.round(Number(p.toPrecision(5))) : Math.round(p)
    })

    let orderSizes: bigint[];
    let factorSum: number;

    if (tokenIn == activeMarket.quoteAddress) {
      factorSum = prices.reduce(
        (sum, price, i) => sum + price * (1 + ((skew - 1) * i) / (numOrders - 1)),
        0
      );
      const x = (Number(amountIn) * Number(activeMarket.scaleFactor)) / factorSum;
      orderSizes = Array.from({ length: numOrders }, (_, i) =>
        BigInt(Math.round(x * (1 + ((skew - 1) * i) / (numOrders - 1))))
      );
    } else {
      factorSum = Array.from({ length: numOrders }).reduce(
        (sum: number, _, i) => sum + (1 + ((skew - 1) * i) / (numOrders - 1)),
        0
      );
      const x = Number(amountIn) / factorSum;
      orderSizes = Array.from({ length: numOrders }, (_, i) =>
        BigInt(Math.round(x * (1 + ((skew - 1) * i) / (numOrders - 1))))
      );
    }
    const orderUsdValues: bigint[] = prices.map((price, i) =>
      ((BigInt(price) * orderSizes[i]) / activeMarket.scaleFactor))
    let totalUsdValue = orderUsdValues.reduce((sum, val) => sum + val, BigInt(0));
    let totalTokenValue = orderSizes.reduce((sum, val) => sum + val, BigInt(0));
    if (tokenIn == activeMarket.quoteAddress) {
      if (totalUsdValue != amountIn) {
        orderUsdValues[orderUsdValues.length - 1] += amountIn - totalUsdValue
      }
    }
    else {
      if (totalTokenValue != amountIn) {
        orderSizes[orderSizes.length - 1] += amountIn - totalTokenValue
      }
    }
    return prices.map((price, i) => [price, orderSizes[i], orderUsdValues[i]])
  }

  const calculateScaleInput = (
    desiredOutput: bigint,
    startPrice: number,
    endPrice: number,
    numOrders: number,
    skew: number,
  ): bigint => {
    if (numOrders <= 1) {
      return 0n;
    }

    const prices: bigint[] = Array.from({ length: numOrders }, (_, i) =>
      BigInt(Math.round(startPrice + ((endPrice - startPrice) * i) / (numOrders - 1)))
    );

    const weights: bigint[] = Array.from({ length: numOrders }, (_, i) =>
      BigInt(Math.round(1e8 + ((skew - 1) * i * 1e8) / (numOrders - 1)))
    );

    const S_p = prices.reduce((sum, price, i) => sum + (price * weights[i]), 0n);
    const S_w = weights.reduce((sum, w) => sum + w, 0n);

    if (S_p === 0n || S_w === 0n || desiredOutput === 0n) {
      return 0n;
    }

    let requiredInput: bigint;

    if (tokenIn === activeMarket.quoteAddress) {
      requiredInput = (desiredOutput * S_p) / (BigInt(activeMarket.scaleFactor) * S_w);
    } else {
      requiredInput = (desiredOutput * BigInt(activeMarket.scaleFactor) * S_w) / S_p;
    }

    return requiredInput;
  };

  // oc resizers
  const handleVertMouseDown = (e: React.MouseEvent) => {
    e.preventDefault();
    e.stopPropagation();

    initialMousePosRef.current = e.clientY;
    initialHeightRef.current = orderCenterHeight;

    setIsVertDragging(true);
    document.body.style.cursor = 'row-resize';
    document.body.style.userSelect = 'none';
  };

  // order processing
  const processOrders = (buyOrdersRaw: any[], sellOrdersRaw: any[]) => {
    const mapOrdersBuy = (orderData: bigint[]) => {
      const orders = orderData
        .filter(
          (order) =>
            (order & BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF')) !==
            BigInt(0),
        )
        .map((order) => {
          const price =
            Number(order >> BigInt(128)) / Number(activeMarket.priceFactor);
          const size =
            Number(order & BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF')) /
            (10 ** Number(activeMarket.quoteDecimals));
          return {
            price,
            size,
            totalSize: 0,
          };
        });

      let runningTotal = 0;
      return orders.map((order) => {
        runningTotal += order.size;
        return {
          ...order,
          totalSize: runningTotal,
        };
      });
    };

    const mapOrdersSell = (orderData: bigint[]) => {
      const orders = orderData
        .filter(
          (order) =>
            (order & BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF')) !==
            BigInt(0),
        )
        .map((order) => {
          const price =
            Number(order >> BigInt(128)) / Number(activeMarket.priceFactor);
          const size =
            Number(order & BigInt('0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF')) * Number(order >> BigInt(128)) /
            Number(activeMarket.scaleFactor) / (10 ** Number(activeMarket.quoteDecimals));
          return {
            price,
            size,
            totalSize: 0,
          };
        });

      let runningTotal = 0;
      return orders.map((order) => {
        runningTotal += order.size;
        return {
          ...order,
          totalSize: runningTotal,
        };
      });
    };

    return {
      buyOrders: mapOrdersBuy(buyOrdersRaw as bigint[]),
      sellOrders: mapOrdersSell(sellOrdersRaw as bigint[]),
    };
  }

  const processOrdersForDisplay = (
    orders: Order[],
    amountsQuote: string,
    latestPrice: number,
    userOrders: any[],
    isBuyOrderList: boolean
  ) => {
    const priceDecimals = Math.max(
      0,
      Math.floor(Math.log10(Number(activeMarket.priceFactor))) +
      Math.floor(
        Math.log10(Number(latestPrice))
      ) + (Math.log10(Number(latestPrice)) < -1 ? Math.log10(Number(latestPrice)) + 1 : 0)
    )

    const priceMap: { [key: string]: boolean } = {};
    if (userOrders && userOrders.length > 0 && orders && orders.length > 0) {
      const filteredUserOrders = userOrders.filter((order) => {
        return isBuyOrderList == (Number(order[3]) === 1) && String(order[4]) === ((activeMarket.baseAsset == wethticker ? ethticker : activeMarket.baseAsset) + (activeMarket.quoteAsset == wethticker ? ethticker : activeMarket.quoteAsset));
      });

      filteredUserOrders.forEach((order) => {
        priceMap[Number(order[0]).toFixed(
          Math.floor(Math.log10(Number(activeMarket.priceFactor)))
        )] = true;
      });
    }

    const roundedOrders = orders.map((order) => {
      const roundedSize =
        amountsQuote === 'Base'
          ? Number((order.size / order.price).toFixed(priceDecimals))
          : Number(order.size.toFixed(2));
      const roundedTotalSize =
        amountsQuote === 'Base'
          ? Number((order.totalSize / order.price).toFixed(priceDecimals))
          : Number(order.totalSize.toFixed(2));

      const userPrice = priceMap[Number(order.price * Number(activeMarket.priceFactor)).toFixed(
        Math.floor(Math.log10(Number(activeMarket.priceFactor)))
      )] == true;

      return {
        price: Number(Number(order.price).toFixed(
          Math.floor(Math.log10(Number(activeMarket.priceFactor)))
        )),
        size: roundedSize,
        totalSize: roundedTotalSize,
        shouldFlash: false,
        userPrice,
      };
    });

    const defaultOrders = orders.map((order) => ({
      price: Number(
        Number(order.price).toFixed(
          Math.floor(Math.log10(Number(activeMarket.priceFactor))),
        ),
      ),
      size: Number(Number(order.size).toFixed(2)),
      totalSize: Number(Number(order.totalSize).toFixed(2)),
    }));

    return { roundedOrders, defaultOrders };
  };

  function v2ToOrderbook(
    reserve1Raw: number | bigint,
    reserve2Raw: number | bigint,
    interval: number,
    baseDecimals: number,
    quoteDecimals: number,
    amountsQuote: string
  ): { bids: Order[]; asks: Order[] } {
    if (reserve1Raw == 0 || reserve2Raw == 0 || interval <= 0) return { bids: [], asks: [] };

    const UNI_V2_FEE_BIPS = 25;
    const fee = Math.max(0, UNI_V2_FEE_BIPS) / 10_000;
    const oneMinusFee = Math.max(1e-12, 1 - fee);

    const toHuman = (raw: number | bigint, decimals: number) => {
      const n = typeof raw === 'bigint' ? Number(raw) : raw;
      return n / Math.pow(10, decimals);
    };

    const x0 = Math.max(1e-18, toHuman(reserve1Raw, baseDecimals));
    const y0 = Math.max(1e-18, toHuman(reserve2Raw, quoteDecimals));
    const k = x0 * y0;
    const pMid = y0 / x0;

    const xFromP = (p: number) => Math.sqrt(k * Math.max(p, 1e-18));

    const intervalToScale = (iv: number) => {
      const s = iv.toString();
      let dec: number;
      if (s.includes('e-')) {
        const [base, exp] = s.split('e-');
        const baseDec = (base.split('.')[1] || '').length;
        dec = parseInt(exp, 10) + baseDec;
      } else {
        const dot = s.indexOf('.');
        dec = dot === -1 ? 0 : s.length - dot - 1;
      }
      const pow = Math.min(12, dec + 6);
      const SCALE = Math.pow(10, pow);
      const intervalTicks = Math.max(1, Math.round(iv * SCALE));
      return { SCALE, intervalTicks };
    };

    const { SCALE, intervalTicks } = intervalToScale(interval);
    const toTicks = (p: number) => Math.round(p * SCALE);
    const fromTicks = (t: number) => t / SCALE;

    const bids: any[] = [];
    const asks: any[] = [];
    const MAX_LEVELS_PER_SIDE = 2000;

    {
      let tMid = toTicks(pMid);
      let tHere = Math.floor(tMid / intervalTicks) * intervalTicks;
      for (let i = 0; i < MAX_LEVELS_PER_SIDE; i++) {
        const tLow = tHere - intervalTicks;
        if (tLow <= 0) break;

        const pLow = fromTicks(tLow);
        const pHere = fromTicks(tHere);

        const xLow = xFromP(pLow);
        const xHi = xFromP(pHere);
        const dxEff = Math.max(0, xHi - xLow);

        const baseIn = dxEff / oneMinusFee;
        if (baseIn <= 0) break;

        const effectivePrice = pLow * (1 - fee);
        const size = amountsQuote == 'Quote' ? baseIn * effectivePrice : baseIn
        bids.push({
          price: effectivePrice,
          size: size,
          totalSize: size,
          shouldFlash: false,
          userPrice: false,
        });

        tHere = tLow;
      }
    }

    {
      let tMid = toTicks(pMid);
      let tHere = Math.ceil(tMid / intervalTicks) * intervalTicks;
      for (let i = 0; i < MAX_LEVELS_PER_SIDE; i++) {
        const tHigh = tHere + intervalTicks;
        const pHere = fromTicks(tHere);
        const pHigh = fromTicks(tHigh);

        const xA = xFromP(pHere);
        const xN = xFromP(pHigh);
        const baseOut = Math.max(0, xN - xA);
        if (baseOut <= 0) break;

        const effectivePrice = pHigh * (1 + fee);
        const size = amountsQuote == 'Quote' ? baseOut * effectivePrice : baseOut
        asks.push({
          price: effectivePrice,
          size: size,
          totalSize: size,
          shouldFlash: false,
          userPrice: false,
        });

        tHere = tHigh;
      }
    }

    return { bids, asks };
  }

  // tokenexplorer
  function reducer(state: State, action: Action): State {
    switch (action.type) {
      case 'INIT': {
        const buckets: State['tokensByStatus'] = {
          new: [],
          graduating: [],
          graduated: [],
        };
        action.tokens.forEach((t) => buckets[t.status].push(t));
        return { ...state, tokensByStatus: buckets };
      }
      case 'ADD_MARKET': {
        const { token } = action;
        const list = [token, ...state.tokensByStatus[token?.status as Token['status']]].slice(
          0,
          30,
        );
        return {
          ...state,
          tokensByStatus: { ...state.tokensByStatus, [token?.status as Token['status']]: list },
        };
      }
      case 'UPDATE_MARKET': {
        const buckets = { ...state.tokensByStatus };
        let movedToken: any;
        (Object.keys(buckets) as Token['status'][]).forEach((s) => {
          buckets[s] = buckets[s].flatMap((t) => {
            if (t.id.toLowerCase() !== action.id.toLowerCase()) return [t];

            const {
              volumeDelta = 0,
              buyTransactions = 0,
              sellTransactions = 0,
              ...rest
            } = action.updates;
            const status = s == 'graduated'
              ? 'graduated'
              : (rest?.price ?? t?.price) * TOTAL_SUPPLY > 12500
                ? 'graduating'
                : 'new'

            if (status != s) {
              movedToken = {
                ...t,
                ...rest,
                volume24h: t.volume24h + volumeDelta,
                buyTransactions: t.buyTransactions + buyTransactions,
                sellTransactions: t.sellTransactions + sellTransactions,
                status: status,
              }
              return []
            }
            return [{
              ...t,
              ...rest,
              volume24h: t.volume24h + volumeDelta,
              buyTransactions: t.buyTransactions + buyTransactions,
              sellTransactions: t.sellTransactions + sellTransactions,
              status: status,
            }];
          });
        });
        if (movedToken?.status) {
          buckets[movedToken?.status as Token['status']].push(movedToken);
        }
        return { ...state, tokensByStatus: buckets };
      }
      case 'GRADUATE_MARKET': {
        const buckets = { ...state.tokensByStatus };
        let movedToken: any;
        (Object.keys(buckets) as Token['status'][]).forEach((s) => {
          buckets[s] = buckets[s].flatMap((t) => {
            if (t.id.toLowerCase() !== action.id.toLowerCase()) return [t];

            const status = 'graduated'

            if (status != s) {
              movedToken = {
                ...t,
                status: status,
              }
              return []
            }
            return [{
              ...t,
              status: status,
            }];
          });
        });
        if (movedToken?.status) {
          buckets[movedToken?.status as Token['status']].push(movedToken);
        }
        return { ...state, tokensByStatus: buckets };
      }
      case 'HIDE_TOKEN': {
        const h = new Set(state.hidden).add(action.id);
        return { ...state, hidden: h };
      }
      case 'SET_LOADING': {
        const l = new Set(state.loading);
        const key = action.buttonType ? `${action.id}-${action.buttonType}` : action.id;
        action.loading ? l.add(key) : l.delete(key);
        return { ...state, loading: l };
      }
      case 'SHOW_TOKEN': {
        const h = new Set(state.hidden);
        h.delete(action.id);
        return { ...state, hidden: h };
      }
      case 'ADD_QUEUED_TOKENS': {
        return {
          ...state,
          tokensByStatus: {
            ...state.tokensByStatus,
            [action.payload.status]: [
              ...action.payload.tokens,
              ...state.tokensByStatus[action.payload.status]
            ]
          }
        };
      }
      default:
        return state;
    }
  }

  const subscribe = useCallback(
    (ws: WebSocket, params: any, onAck?: (subId: string) => void) => {
      const reqId = subIdRef.current++;
      ws.send(
        JSON.stringify({
          id: reqId,
          jsonrpc: '2.0',
          method: 'eth_subscribe',
          params,
        }),
      );
      if (!onAck) return;
      const handler = (evt: MessageEvent) => {
        const msg = JSON.parse(evt.data);
        if (msg.id === reqId && msg.result) {
          onAck(msg.result);
          ws.removeEventListener('message', handler);
        }
      };
      ws.addEventListener('message', handler);
    },
    [],
  );

  const addMarket = useCallback(
    async (log: any) => {
      const { args } = decodeEventLog({
        abi: CrystalRouterAbi,
        data: log.data,
        topics: log.topics,
      }) as any;

      const socials = [args.social1, args.social2, args.social3, args.social4].map((s) =>
        s ? (/^https?:\/\//.test(s) ? s : `https://${s}`) : s,
      );
      const twitter = socials.find(
        (s) =>
          s?.startsWith('https://x.com') ||
          s?.startsWith('https://twitter.com'),
      );
      if (twitter) {
        socials.splice(socials.indexOf(twitter), 1);
      }
      const telegram = socials.find((s) => s?.startsWith('https://t.me'));
      if (telegram) {
        socials.splice(socials.indexOf(telegram), 1);
      }
      const discord = socials.find(
        (s) =>
          s?.startsWith('https://discord.gg') ||
          s?.startsWith('https://discord.com'),
      );
      if (discord) {
        socials.splice(socials.indexOf(discord), 1);
      }
      const website = socials[0];

      const token: Partial<Token> = {
        ...defaultMetrics,
        id: args.token,
        tokenAddress: args.token,
        name: args.name,
        symbol: args.symbol,
        image: args.metadataCID || '',
        description: args.description ?? '',
        twitterHandle: twitter ?? '',
        website: website ?? '',
        status: 'new',
        marketCap: defaultMetrics.price * TOTAL_SUPPLY,
        created: Math.floor(Date.now() / 1000),
        volumeDelta: 0,
        telegramHandle: telegram ?? '',
        discordHandle: discord ?? '',
        dev: args.creator,
        launchedTokens: 0,
        graduatedTokens: 0,
      };

      if (token.status && pausedColumnRef.current == token.status) {
        pausedTokenQueueRef.current[token.status].push(token as any);
        return;
      }
      dispatch({ type: 'ADD_MARKET', token });
      if (alertSettingsRef.current.soundAlertsEnabled) {
        try {
          const audio = new Audio(alertSettingsRef.current.sounds.newPairs);
          audio.volume = alertSettingsRef.current.volume / 100;
          audio.play().catch(console.error);
        } catch (error) {
          console.error('Failed to play new pairs sound:', error);
        }
      }
    },
    [],
  );

  const updateMarket = useCallback(
    (log: any) => {
      if (log.topics?.[0] !== MARKET_UPDATE_EVENT) return;

      const tokenAddr = `0x${log.topics[1].slice(26)}`.toLowerCase();

      const hex = log.data.replace(/^0x/, '');
      const words: string[] = [];
      for (let i = 0; i < hex.length; i += 64) words.push(hex.slice(i, i + 64));

      const isBuy = BigInt('0x' + words[0]);
      const amountIn = BigInt('0x' + words[1]);
      const amountOut = BigInt('0x' + words[2]);
      const virtualNativeReserve = BigInt('0x' + words[3]);
      const virtualTokenReserve = BigInt('0x' + words[4]);
      const price =
        virtualTokenReserve == 0n
          ? 0
          : Number(virtualNativeReserve) / Number(virtualTokenReserve);

      dispatch({
        type: 'UPDATE_MARKET',
        id: tokenAddr,
        updates: {
          price: price,
          marketCap: price * TOTAL_SUPPLY,
          buyTransactions: isBuy ? 1 : 0,
          sellTransactions: isBuy ? 0 : 1,
          volumeDelta:
            isBuy > 0 ? Number(amountIn) / 1e18 : Number(amountOut) / 1e18,
        },
      });
    },
    [],
  );

  const scheduleReconnect = useCallback(() => {
    if (
      connectionStateRef.current === 'connecting' ||
      connectionStateRef.current === 'connected'
    )
      return;

    const baseDelay = consecutiveFailuresRef.current > 5 ? 10000 : 1000;
    const attempt = Math.min(retryCountRef.current, 8);
    const exponentialDelay = baseDelay * Math.pow(1.5, attempt);
    const jitter = Math.random() * 1000;
    const delay = Math.round(exponentialDelay + jitter);

    const now = Date.now();
    const timeSinceLastAttempt = now - lastConnectionAttemptRef.current;
    const minInterval = 2000;

    if (timeSinceLastAttempt < minInterval) {
      const additionalDelay = minInterval - timeSinceLastAttempt;
      setTimeout(() => scheduleReconnect(), additionalDelay);
      return;
    }

    if (reconnectTimerRef.current)
      window.clearTimeout(reconnectTimerRef.current);

    connectionStateRef.current = 'reconnecting';
    reconnectTimerRef.current = window.setTimeout(() => {
      openWebsocket();
    }, delay);
  }, []);

  const handleConnectionError = useCallback(
    (_errorType: string) => {
      connectionStateRef.current = 'disconnected';
      consecutiveFailuresRef.current += 1;
      retryCountRef.current += 1;

      scheduleReconnect();
    },
    [scheduleReconnect],
  );

  const openWebsocket = useCallback((): void => {
    if (
      connectionStateRef.current === 'connecting' ||
      connectionStateRef.current === 'connected'
    ) {
      return;
    }
    lastConnectionAttemptRef.current = Date.now();
    connectionAttemptsRef.current += 1;

    if (teRef.current) {
      const oldWs = teRef.current;
      teRef.current = null;

      oldWs.onopen = null;
      oldWs.onmessage = null;
      oldWs.onerror = null;
      oldWs.onclose = null;

      if (
        oldWs.readyState === WebSocket.OPEN ||
        oldWs.readyState === WebSocket.CONNECTING
      ) {
        oldWs.close(1000, 'reconnecting');
      }
    }

    connectionStateRef.current = 'connecting';

    try {
      const ws = new WebSocket(settings.chainConfig[activechain].wssurl);
      teRef.current = ws;
      const connectionTimeout = setTimeout(() => {
        if (ws.readyState === WebSocket.CONNECTING) {
          ws.close(1000, 'connection timeout');
          handleConnectionError('timeout');
        }
      }, 10000);

      ws.onopen = () => {
        clearTimeout(connectionTimeout);
        connectionStateRef.current = 'connected';
        retryCountRef.current = 0;
        consecutiveFailuresRef.current = 0;

        subscribe(ws, [
          'monadLogs',
          { address: settings.chainConfig[activechain].router, topics: [[TRADE_EVENT, MARKET_CREATED_EVENT, MARKET_UPDATE_EVENT, '0xa2e7361c23d7820040603b83c0cd3f494d377bac69736377d75bb56c651a5098']] }
        ]);
      };

      ws.onmessage = ({ data }) => {
        try {
          const msg = JSON.parse(data);
          if (msg.method !== 'eth_subscription' || !msg.params?.result)
            return;
          const log = msg.params?.result;
          if (!log?.topics?.length || msg?.params?.result?.commitState != "Proposed") return;
          setProcessedLogs(prev => {
            let tempset = new Set(prev);
            const resolve = txReceiptResolvers.current.get(log['transactionHash']);
            if (resolve) {
              resolve();
              txReceiptResolvers.current.delete(log['transactionHash']);
            }

            if (log.topics?.[0] === TRADE_EVENT) {
              const marketAddr = `0x${log.topics[1].slice(26)}`.toLowerCase();
              const callerAddr = `0x${log.topics[2].slice(26)}`.toLowerCase();

              const mcfg = markets[addresstoMarket[marketAddr]];
              if (!mcfg || !mcfg.baseAddress) return tempset;
              const tokenAddrFromMarket = (mcfg.baseAddress || '').toLowerCase();

              const hex = log.data.startsWith('0x') ? log.data.slice(2) : log.data;
              const word = (i: number) => BigInt('0x' + hex.slice(i * 64, i * 64 + 64));

              const isBuy = word(0) !== 0n;
              const amountInWei = word(1);
              const amountOutWei = word(2);

              const amountIn = Number(amountInWei) / 1e18;
              const amountOut = Number(amountOutWei) / 1e18;

              const priceFactor = Number(mcfg.priceFactor || 1);

              const startPrice = priceFactor ? (Number(word(3)) / priceFactor) : 0
              const endPrice = priceFactor ? (Number(word(4)) / priceFactor) : 0

              dispatch({
                type: 'UPDATE_MARKET',
                id: tokenAddrFromMarket,
                updates: {
                  price: endPrice,
                  marketCap: endPrice * TOTAL_SUPPLY,
                  buyTransactions: isBuy ? 1 : 0,
                  sellTransactions: isBuy ? 0 : 1,
                  volumeDelta:
                    isBuy == true ? Number(amountIn) / 1e18 : Number(amountOut) / 1e18,
                },
              });

              if (!memeRef.current.id || tokenAddrFromMarket !== memeRef.current.id.toLowerCase()) return tempset;

              setTokenData(p => ({
                ...p,
                price: endPrice,
                marketCap: endPrice * TOTAL_SUPPLY,
                buyTransactions: (p?.buyTransactions || 0) + (isBuy ? 1 : 0),
                sellTransactions: (p?.sellTransactions || 0) + (isBuy ? 0 : 1),
                volume24h: (p?.volume24h || 0) + (isBuy ? amountIn : amountOut),
              }));

              setMemeTrades(prev => [
                {
                  id: `${log.transactionHash}-${log.logIndex}`,
                  timestamp: Date.now() / 1000,
                  isBuy,
                  price: endPrice,
                  nativeAmount: isBuy ? amountIn : amountOut,
                  tokenAmount: isBuy ? amountOut : amountIn,
                  caller: `0x${log.topics[2].slice(26)}`,
                },
                ...prev.slice(0, 99),
              ]);

              setChartData((prev: any) => {
                if (!prev || !Array.isArray(prev) || prev.length < 2) return prev;
                const [bars, key, flag] = prev;
                const sel = key?.split('MON').pop() || ''
                const RESOLUTION_SECS: Record<string, number> = {
                  '1S': 1, '5S': 5, '15S': 15, '1m': 60, '5m': 300, '15m': 900,
                  '1h': 3600, '4h': 14400, '1d': 86400,
                };
                const resSecs = RESOLUTION_SECS[sel] ?? 60;
                const now = Date.now();
                const bucket = Math.floor(now / (resSecs * 1000)) * resSecs * 1000;
                const volNative = isBuy ? amountIn : amountOut;
                const updated = [...bars];
                const last = updated[updated.length - 1];
                if (!last || last.time < bucket) {
                  const prevClose = last?.close ?? startPrice;
                  const open = prevClose;
                  const high = Math.max(open, Math.max(startPrice, endPrice));
                  const low = Math.min(open, Math.min(startPrice, endPrice));
                  const newBar = {
                    time: bucket,
                    open,
                    high,
                    low,
                    close: endPrice,
                    volume: volNative || 0,
                  };
                  updated.push(newBar);
                  const cb =
                    memeRealtimeCallbackRef.current?.[key];
                  if (cb) cb(newBar);
                } else {
                  const cur = { ...last };
                  cur.high = Math.max(cur.high, Math.max(startPrice, endPrice));
                  cur.low = Math.min(cur.low, Math.min(startPrice, endPrice));
                  cur.close = endPrice;
                  cur.volume = (cur.volume || 0) + (volNative || 0);
                  updated[updated.length - 1] = cur;
                  const cb =
                    memeRealtimeCallbackRef.current?.[key];
                  if (cb) cb(cur);
                }
                if (updated.length > 1200) updated.splice(0, updated.length - 1200);
                return [updated, key, flag];
              });

              setMemeHolders(prev => {
                const arr = prev.slice();
                let idx = memeHoldersMapRef.current.get?.(callerAddr);
                if (idx == undefined) {
                  const fresh: Holder = {
                    address: `0x${log.topics[2].slice(26)}`,
                    balance: 0,
                    amountBought: 0,
                    amountSold: 0,
                    valueBought: 0,
                    valueSold: 0,
                    valueNet: 0,
                    tokenNet: 0,
                  };
                  arr.push(fresh);
                  idx = arr.length - 1;
                  memeHoldersMapRef.current.set(callerAddr, idx);
                }
                const h = { ...arr[idx] };
                if (isBuy) {
                  h.amountBought = (h.amountBought || 0) + amountOut;
                  h.valueBought = (h.valueBought || 0) + amountIn;
                  h.balance = (h.balance || 0) + amountOut;
                } else {
                  h.amountSold = (h.amountSold || 0) + amountIn;
                  h.valueSold = (h.valueSold || 0) + amountOut;
                  h.balance = Math.max(0, (h.balance || 0) - amountIn);
                }
                arr[idx] = h;

                for (let i = 0; i < arr.length; i++) {
                  const hh = arr[i];
                  const realized = (hh.valueSold || 0) - (hh.valueBought || 0);
                  const bal = Math.max(0, hh.balance || 0);
                  arr[i] = { ...hh, valueNet: realized + bal * endPrice };
                }

                const topSum = arr
                  .map(hh => Math.max(0, hh.balance || 0))
                  .sort((a, b) => b - a)
                  .slice(0, 10)
                  .reduce((s, n) => s + n, 0);
                setMemeTop10HoldingPct((topSum / TOTAL_SUPPLY) * 100);
                return arr;
              });

              setMemeTopTraders(prev => {
                const copy = Array.isArray(prev) ? [...prev] : [];
                const key = callerAddr;
                let idx = memeTopTradersMapRef.current.get(key) ?? -1;

                if (idx === -1) {
                  const row: Holder = {
                    address: `0x${log.topics[2].slice(26)}`,
                    balance: 0, tokenNet: 0, valueNet: 0,
                    amountBought: 0, amountSold: 0,
                    valueBought: 0, valueSold: 0,
                  };
                  copy.push(row);
                  idx = copy.length - 1;
                  memeTopTradersMapRef.current.set(key, idx);
                }

                const row = { ...copy[idx] };
                const curBal = Math.max(0, (row.balance ?? row.amountBought - row.amountSold) || 0);
                if (isBuy) {
                  row.amountBought = (row.amountBought || 0) + amountOut;
                  row.valueBought = (row.valueBought || 0) + amountIn;
                  row.balance = curBal + amountOut;
                } else {
                  row.amountSold = (row.amountSold || 0) + amountIn;
                  row.valueSold = (row.valueSold || 0) + amountOut;
                  row.balance = Math.max(0, curBal - amountIn);
                }
                row.tokenNet = (row.amountBought || 0) - (row.amountSold || 0);
                copy[idx] = row;

                for (let i = 0; i < copy.length; i++) {
                  const r = copy[i];
                  const bal = Math.max(0, (r.balance ?? r.amountBought - r.amountSold) || 0);
                  const realized = (r.valueSold || 0) - (r.valueBought || 0);
                  copy[i] = { ...r, valueNet: realized + bal * endPrice };
                }

                copy.sort((a, b) => b.valueNet - a.valueNet);
                if (copy.length > 300) {
                  const removed = copy.splice(300);
                  for (const r of removed) memeTopTradersMapRef.current.delete((r.address || '').toLowerCase());
                }
                copy.forEach((r, i) => memeTopTradersMapRef.current.set((r.address || '').toLowerCase(), i));
                return copy;
              });

              setMemePositions(prev => {
                const copy = Array.isArray(prev) ? [...prev] : [];
                const allUserAddresses = [
                  (address || '').toLowerCase(),
                  ...(subWallets || []).map(w => (w.address || '').toLowerCase()),
                ];
                const isUserTrade = allUserAddresses.includes(callerAddr);

                let idx = memePositionsMapRef.current.get(tokenAddrFromMarket);
                if (idx === undefined && isUserTrade) {
                  const newPos = {
                    tokenId: memeRef.current.id?.toLowerCase(),
                    symbol: memeRef.current?.symbol || '',
                    name: memeRef.current?.name || '',
                    imageUrl: memeRef.current?.image || '',
                    metadataCID: '',
                    boughtTokens: 0,
                    soldTokens: 0,
                    spentNative: 0,
                    receivedNative: 0,
                    remainingTokens: 0,
                    remainingPct: 0,
                    pnlNative: 0,
                    lastPrice: endPrice,
                  };
                  copy.push(newPos);
                  idx = copy.length - 1;
                  memePositionsMapRef.current.set(tokenAddrFromMarket, idx);
                }
                if (idx === undefined) return prev;

                const pos = { ...copy[idx] };
                pos.lastPrice = endPrice;
                if (isUserTrade) {
                  if (isBuy) {
                    pos.boughtTokens += amountOut;
                    pos.spentNative += amountIn;
                    pos.remainingTokens = (pos.remainingTokens || 0) + amountOut;
                  } else {
                    pos.soldTokens += amountIn;
                    pos.receivedNative += amountOut;
                    pos.remainingTokens = Math.max(0, (pos.remainingTokens || 0) - amountIn);
                  }
                }
                pos.remainingPct = pos.boughtTokens > 0
                  ? (pos.remainingTokens / pos.boughtTokens) * 100
                  : 0;

                const balance = Math.max(0, pos.remainingTokens);
                const realized = (pos.receivedNative || 0) - (pos.spentNative || 0);
                const unrealized = balance * (pos.lastPrice || 0);
                pos.pnlNative = realized + unrealized;

                copy[idx] = pos;

                if (memeRef.current.id && tokenAddrFromMarket === memeRef.current.id.toLowerCase()) {
                  const markToMarket = balance * (pos.lastPrice || 0);
                  const totalPnL = (pos.receivedNative || 0) + markToMarket - (pos.spentNative || 0);
                  setMemeUserStats({
                    balance,
                    amountBought: pos.boughtTokens || 0,
                    amountSold: pos.soldTokens || 0,
                    valueBought: pos.spentNative || 0,
                    valueSold: pos.receivedNative || 0,
                    valueNet: totalPnL,
                  });
                }
                return copy;
              });

              if (memeDevTokenIdsRef.current.has(tokenAddrFromMarket)) {
                setMemeDevTokens(prev => {
                  const updated = prev.map(t => {
                    if ((t.id || '').toLowerCase() !== tokenAddrFromMarket) return t;
                    return { ...t, endPrice, marketCap: endPrice * TOTAL_SUPPLY, timestamp: Date.now() / 1000 };
                  });
                  memeDevTokenIdsRef.current = new Set(updated.map(t => (t.id || '').toLowerCase()));
                  return updated;
                });
              }

              return tempset;
            }
            else if (log.topics?.[0] === MARKET_CREATED_EVENT) {
              addMarket(log);
            }
            else if (log.topics?.[0] === MARKET_UPDATE_EVENT) {
              updateMarket(log);
              const tokenAddr = `0x${log.topics[1].slice(26)}`.toLowerCase();
              const callerAddr = `0x${log.topics[2].slice(26)}`.toLowerCase();

              const hex = log.data.startsWith('0x') ? log.data.slice(2) : log.data;
              const word = (i: number) => BigInt('0x' + hex.slice(i * 64, i * 64 + 64));

              const isBuy = word(0) !== 0n;
              const inputAmountWei = word(1);
              const outputAmountWei = word(2);
              const vNativeWei = word(3);
              const vTokenWei = word(4);

              const toNum = (x: bigint) => Number(x) / 1e18;
              const amountIn = toNum(inputAmountWei);
              const amountOut = toNum(outputAmountWei);
              const vNative = Number(vNativeWei);
              const vToken = Number(vTokenWei);

              const price = vToken === 0 ? 0 : vNative / vToken;
              if (memeRef.current.id && tokenAddr === memeRef.current.id.toLowerCase()) {
                setTokenData(p => ({
                  ...p,
                  price,
                  marketCap: price * TOTAL_SUPPLY,
                  buyTransactions: (p?.buyTransactions || 0) + (isBuy ? 1 : 0),
                  sellTransactions: (p?.sellTransactions || 0) + (isBuy ? 0 : 1),
                  volume24h: (p?.volume24h || 0) + (isBuy ? amountIn : amountOut),
                }));

                setMemeTrades(prev => [
                  {
                    id: `${log.transactionHash}-${log.logIndex}`,
                    timestamp: Date.now() / 1000,
                    isBuy,
                    price: price,
                    nativeAmount: isBuy ? amountIn : amountOut,
                    tokenAmount: isBuy ? amountOut : amountIn,
                    caller: `0x${log.topics[2].slice(26)}`,
                  },
                  ...prev.slice(0, 99),
                ]);

                setChartData((prev: any) => {
                  if (!prev || !Array.isArray(prev) || prev.length < 2) return prev;
                  const [bars, key, flag] = prev;
                  const sel = key?.split('MON').pop() || ''
                  const RESOLUTION_SECS: Record<string, number> = {
                    '1S': 1, '5S': 5, '15S': 15, '1m': 60, '5m': 300, '15m': 900,
                    '1h': 3600, '4h': 14400, '1d': 86400,
                  };
                  const resSecs = RESOLUTION_SECS[sel] ?? 60;
                  const now = Date.now();
                  const bucket = Math.floor(now / (resSecs * 1000)) * resSecs * 1000;
                  const volNative = isBuy ? amountIn : amountOut;

                  const updated = [...bars];
                  const last = updated[updated.length - 1];

                  if (!last || last.time < bucket) {
                    const prevClose = last?.close ?? price;
                    const open = prevClose;
                    const high = Math.max(open, price);
                    const low = Math.min(open, price);
                    const newBar = {
                      time: bucket,
                      open,
                      high,
                      low,
                      close: price,
                      volume: volNative || 0,
                    };
                    updated.push(newBar);
                    const cb =
                      memeRealtimeCallbackRef.current?.[key];
                    if (cb) cb(newBar);
                  } else {
                    const cur = { ...last };
                    cur.high = Math.max(cur.high, price);
                    cur.low = Math.min(cur.low, price);
                    cur.close = price;
                    cur.volume = (cur.volume || 0) + (volNative || 0);
                    updated[updated.length - 1] = cur;
                    const cb =
                      memeRealtimeCallbackRef.current?.[key];
                    if (cb) cb(cur);
                  }
                  if (updated.length > 1200) updated.splice(0, updated.length - 1200);
                  return [updated, key, flag];
                });

                setMemeHolders(prev => {
                  const arr = prev.slice();
                  let idx = memeHoldersMapRef.current.get?.(callerAddr);
                  if (idx == undefined) {
                    const fresh: Holder = {
                      address: `0x${log.topics[2].slice(26)}`,
                      balance: 0,
                      amountBought: 0,
                      amountSold: 0,
                      valueBought: 0,
                      valueSold: 0,
                      valueNet: 0,
                      tokenNet: 0,
                    };
                    arr.push(fresh);
                    idx = arr.length - 1;
                    memeHoldersMapRef.current.set(callerAddr, idx);
                  }
                  const h = { ...arr[idx] };
                  if (isBuy) {
                    h.amountBought = (h.amountBought || 0) + amountOut;
                    h.valueBought = (h.valueBought || 0) + amountIn;
                    h.balance = (h.balance || 0) + amountOut;
                  } else {
                    h.amountSold = (h.amountSold || 0) + amountIn;
                    h.valueSold = (h.valueSold || 0) + amountOut;
                    h.balance = Math.max(0, (h.balance || 0) - amountIn);
                  }
                  arr[idx] = h;

                  for (let i = 0; i < arr.length; i++) {
                    const h = arr[i];
                    const realized = (h.valueSold || 0) - (h.valueBought || 0);
                    const bal = Math.max(0, h.balance || 0);
                    arr[i] = { ...h, valueNet: realized + bal * price };
                  }
                  const topSum = arr.map(h => Math.max(0, h.balance || 0)).sort((a, b) => b - a).slice(0, 10).reduce((s, n) => s + n, 0);
                  setMemeTop10HoldingPct((topSum / TOTAL_SUPPLY) * 100);
                  return arr;
                });

                setMemeTopTraders(prev => {
                  const copy = Array.isArray(prev) ? [...prev] : [];
                  const key = callerAddr;
                  let idx = memeTopTradersMapRef.current.get(key) ?? -1;

                  if (idx === -1) {
                    const row: Holder = {
                      address: `0x${log.topics[2].slice(26)}`,
                      balance: 0, tokenNet: 0, valueNet: 0,
                      amountBought: 0, amountSold: 0,
                      valueBought: 0, valueSold: 0,
                    };
                    copy.push(row);
                    idx = copy.length - 1;
                    memeTopTradersMapRef.current.set(key, idx);
                  }

                  const row = { ...copy[idx] };
                  const curBal = Math.max(0, (row.balance ?? row.amountBought - row.amountSold) || 0);
                  if (isBuy) {
                    row.amountBought = (row.amountBought || 0) + amountOut;
                    row.valueBought = (row.valueBought || 0) + amountIn;
                    row.balance = curBal + amountOut;
                  } else {
                    row.amountSold = (row.amountSold || 0) + amountIn;
                    row.valueSold = (row.valueSold || 0) + amountOut;
                    row.balance = Math.max(0, curBal - amountIn);
                  }
                  row.tokenNet = (row.amountBought || 0) - (row.amountSold || 0);
                  copy[idx] = row;

                  for (let i = 0; i < copy.length; i++) {
                    const r = copy[i];
                    const bal = Math.max(0, (r.balance ?? r.amountBought - r.amountSold) || 0);
                    const realized = (r.valueSold || 0) - (r.valueBought || 0);
                    copy[i] = { ...r, valueNet: realized + bal * price };
                  }

                  copy.sort((a, b) => b.valueNet - a.valueNet);
                  if (copy.length > 300) {
                    const removed = copy.splice(300);
                    for (const r of removed) memeTopTradersMapRef.current.delete((r.address || '').toLowerCase());
                  }
                  copy.forEach((r, i) => memeTopTradersMapRef.current.set((r.address || '').toLowerCase(), i));
                  return copy;
                });

                setMemePositions(prev => {
                  const copy = Array.isArray(prev) ? [...prev] : [];
                  const allUserAddresses = [
                    (address || '').toLowerCase(),
                    ...(subWallets || []).map(w => (w.address || '').toLowerCase()),
                  ];
                  const isUserTrade = allUserAddresses.includes(callerAddr);
                  let idx = memePositionsMapRef.current.get(tokenAddr);

                  if (idx === undefined && isUserTrade) {
                    const newPos = {
                      tokenId: memeRef.current.id?.toLowerCase(),
                      symbol: memeRef.current?.symbol || '',
                      name: memeRef.current?.name || '',
                      imageUrl: memeRef.current?.image || '',
                      metadataCID: '',
                      boughtTokens: 0,
                      soldTokens: 0,
                      spentNative: 0,
                      receivedNative: 0,
                      remainingTokens: 0,
                      remainingPct: 0,
                      pnlNative: 0,
                      lastPrice: price,
                    };
                    copy.push(newPos);
                    idx = copy.length - 1;
                    memePositionsMapRef.current.set(tokenAddr, idx);
                  }
                  if (idx === undefined) return prev;

                  const pos = { ...copy[idx] };
                  pos.lastPrice = price;
                  if (isUserTrade) {
                    if (isBuy) {
                      pos.boughtTokens += amountOut;
                      pos.spentNative += amountIn;
                      pos.remainingTokens += amountOut;
                    } else {
                      pos.soldTokens += amountIn;
                      pos.receivedNative += amountOut;
                      pos.remainingTokens = Math.max(0, pos.remainingTokens - amountIn);
                    }
                  }
                  pos.remainingPct = pos.boughtTokens > 0 ? (pos.remainingTokens / pos.boughtTokens) * 100 : 0;

                  const balance = Math.max(0, pos.remainingTokens);
                  const realized = (pos.receivedNative || 0) - (pos.spentNative || 0);
                  const unrealized = balance * (pos.lastPrice || 0);
                  pos.pnlNative = realized + unrealized;

                  copy[idx] = pos;

                  if (memeRef.current.id && tokenAddr === memeRef.current.id.toLowerCase()) {
                    const markToMarket = balance * (pos.lastPrice || 0);
                    const totalPnL = (pos.receivedNative || 0) + markToMarket - (pos.spentNative || 0);
                    setMemeUserStats({
                      balance,
                      amountBought: pos.boughtTokens || 0,
                      amountSold: pos.soldTokens || 0,
                      valueBought: pos.spentNative || 0,
                      valueSold: pos.receivedNative || 0,
                      valueNet: totalPnL,
                    });
                  }
                  return copy;
                });

                if (memeDevTokenIdsRef.current.has(tokenAddr)) {
                  setMemeDevTokens(prev => {
                    const updated = prev.map(t => {
                      if ((t.id || '').toLowerCase() !== tokenAddr) return t;
                      return { ...t, price, marketCap: price * TOTAL_SUPPLY, timestamp: Date.now() / 1000 };
                    });
                    memeDevTokenIdsRef.current = new Set(updated.map(t => (t.id || '').toLowerCase()));
                    return updated;
                  });
                }
              }
              return tempset;
            }
            else if (log.topics?.[0] == '0xa2e7361c23d7820040603b83c0cd3f494d377bac69736377d75bb56c651a5098') {
              const tokenAddr = `0x${log.topics[1].slice(26)}`.toLowerCase();
              dispatch({
                type: 'GRADUATE_MARKET',
                id: tokenAddr,
              });
              if (!memeRef.current.id || tokenAddr !== memeRef.current.id.toLowerCase()) return tempset;
              setTokenData(p => ({
                ...p,
                status: 'graduated'
              }));
            }
            return tempset;
          })
        } catch (parseError) {
          console.warn('Failed to parse WebSocket message:', parseError);
        }
      };

      ws.onerror = (event) => {
        clearTimeout(connectionTimeout);
        console.warn('WebSocket error:', event);
        handleConnectionError('error');
      };

      ws.onclose = (event) => {
        clearTimeout(connectionTimeout);
        connectionStateRef.current = 'disconnected';

        const isNormalClose = event.code === 1000;
        const isServerError = event.code >= 1011 && event.code <= 1014;
        const isNetworkError = event.code === 1006;

        if (!isNormalClose) {
          consecutiveFailuresRef.current += 1;
          retryCountRef.current += 1;

          console.warn(
            `WebSocket closed (${event.code}): ${event.reason || 'No reason'}`,
          );

          if (isServerError && consecutiveFailuresRef.current > 3) {
            retryCountRef.current += 2;
          } else if (isNetworkError && consecutiveFailuresRef.current > 2) {
            retryCountRef.current += 1;
          }

          scheduleReconnect();
        }
      };
    } catch (error) {
      console.error('Failed to create WebSocket:', error);
      handleConnectionError('creation');
    }
  },
    [subscribe, scheduleReconnect],
  );

  useEffect(() => {
    if (!['board', 'spectra', 'meme', 'launchpad'].includes(location.pathname.split('/')[1])) return;

    let cancelled = false;

    async function bootstrap() {
      try {
        const res = await fetch(SUBGRAPH_URL, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({
            query: `
          {
            active: launchpadTokens(first:30, orderBy: timestamp, orderDirection: desc, where:{migrated:false}) {
              id
              creator {
                id
                tokensLaunched
                tokensGraduated
              }
              name
              symbol
              metadataCID
              description
              social1
              social2
              social3	
              social4
              decimals
              initialSupply
              timestamp
              migrated
              migratedAt
              migratedMarket {
                id
              }
              volumeNative
              volumeToken
              buyTxs
              sellTxs
              distinctBuyers
              distinctSellers
              lastPriceNativePerTokenWad
              lastUpdatedAt
              trades {
                id
                amountIn
                amountOut
              }
              totalHolders
              devHoldingAmount
              holders(first:11, orderBy: tokens, orderDirection: desc, where:{tokens_gt:0}) {
                account { id }
                tokens
              }
            }
            migrated: launchpadTokens(first:30, orderBy: timestamp, orderDirection: desc, where:{migrated:true}) {
              id
              creator {
                id
                tokensLaunched
                tokensGraduated
              }
              name
              symbol
              metadataCID
              description
              social1
              social2
              social3	
              social4
              decimals
              initialSupply
              timestamp
              migrated
              migratedAt
              migratedMarket {
                id
              }
              volumeNative
              volumeToken
              buyTxs
              sellTxs
              distinctBuyers
              distinctSellers
              lastPriceNativePerTokenWad
              lastUpdatedAt
              trades {
                id
                amountIn
                amountOut
              }
              totalHolders
              devHoldingAmount
              holders(first:11, orderBy: tokens, orderDirection: desc, where:{tokens_gt:0}) {
                account { id }
                tokens
              }
            }
          }`,
          }),
        });
        const json = await res.json();
        const rawMarkets = [
          ...(json.data?.active ?? []),
          ...(json.data?.migrated ?? []),
        ];

        const tokens: Token[] = await Promise.all(
          rawMarkets.map(async (m: any) => {
            const price =
              Number(m.lastPriceNativePerTokenWad) / 1e9 ||
              defaultMetrics.price;

            let createdTimestamp = Number(m.timestamp);
            if (createdTimestamp > 1e10) {
              createdTimestamp = Math.floor(createdTimestamp / 1000);
            }
            const socials = [m.social1, m.social2, m.social3, m.social4].map((s) =>
              s ? (/^https?:\/\//.test(s) ? s : `https://${s}`) : s,
            );
            const twitter = socials.find(
              (s) =>
                s?.startsWith('https://x.com') ||
                s?.startsWith('https://twitter.com'),
            );
            if (twitter) {
              socials.splice(socials.indexOf(twitter), 1);
            }
            const telegram = socials.find((s) => s?.startsWith('https://t.me'));
            if (telegram) {
              socials.splice(socials.indexOf(telegram), 1);
            }
            const discord = socials.find(
              (s) =>
                s?.startsWith('https://discord.gg') ||
                s?.startsWith('https://discord.com'),
            );
            if (discord) {
              socials.splice(socials.indexOf(discord), 1);
            }
            const website = socials[0];

            return {
              ...defaultMetrics,
              id: m.id.toLowerCase(),
              tokenAddress: m.id.toLowerCase(),
              dev: m.creator.id,
              name: m.name,
              symbol: m.symbol,
              image: m.metadataCID || '',
              description: m.description ?? '',
              twitterHandle: twitter ?? '',
              website: website ?? '',
              status: m.migrated
                ? 'graduated'
                : price * TOTAL_SUPPLY > 12500
                  ? 'graduating'
                  : 'new',
              created: createdTimestamp,
              price,
              marketCap: price * TOTAL_SUPPLY,
              buyTransactions: Number(m.buyTxs),
              sellTransactions: Number(m.sellTxs),
              volume24h: Number(m.volumeNative) / 1e18,
              volumeDelta: 0,
              discordHandle: discord ?? '',
              telegramHandle: telegram ?? '',
              launchedTokens: m.creator.tokensLaunched ?? '',
              graduatedTokens: m.creator.tokensGraduated ?? '',
              holders: m.totalHolders - 1,
              devHolding: m.devHoldingAmount / 1e27,
              top10Holding: Number(
                (m.holders ?? [])
                  .filter((h: { account?: { id?: string } }) => (h.account?.id?.toLowerCase() ?? '') !== (settings.chainConfig[activechain].router ?? '').toLowerCase())
                  .slice(0, 10)
                  .reduce((sum: bigint, h: { tokens: string }) => sum + BigInt(h.tokens || '0'), 0n)
              ) / 1e25,
            } as Token;
          }),
        );

        dispatch({ type: 'INIT', tokens });
        openWebsocket();
      } catch (err) {
        console.error('initial subgraph fetch failed', err);
      } finally {
        if (!cancelled) setIsTokenExplorerLoading(false);
      }
    }

    bootstrap();
    return () => {
      cancelled = true;
      connectionStateRef.current = 'disconnected';

      if (reconnectTimerRef.current) {
        window.clearTimeout(reconnectTimerRef.current);
        reconnectTimerRef.current = null;
      }

      if (explorerWsRef.current) {
        const ws = explorerWsRef.current;
        explorerWsRef.current = null;

        ws.onopen = null;
        ws.onmessage = null;
        ws.onerror = null;
        ws.onclose = null;

        if (
          ws.readyState === WebSocket.OPEN ||
          ws.readyState === WebSocket.CONNECTING
        ) {
          try {
            ws.close(1000, 'component unmount');
          } catch (error) {
            console.warn('Error closing WebSocket on unmount:', error);
          }
        }
      }

      connectionAttemptsRef.current = 0;
      retryCountRef.current = 0;
      consecutiveFailuresRef.current = 0;
    };
  }, [openWebsocket, !['board', 'spectra', 'meme', 'launchpad'].includes(location.pathname.split('/')[1])]);

  // memeinterface
  const [memeTrades, setMemeTrades] = useState<LaunchpadTrade[]>([]);
  const [memeHolders, setMemeHolders] = useState<Holder[]>([]);
  const [memeTopTraders, setMemeTopTraders] = useState<Holder[]>([]);
  const [memePositions, setMemePositions] = useState<any[]>([]);
  const [memeDevTokens, setMemeDevTokens] = useState<any[]>([]);
  const [memeTop10HoldingPct, setMemeTop10HoldingPct] = useState(0);
  const [memeUserStats, setMemeUserStats] = useState({
    balance: 0, amountBought: 0, amountSold: 0, valueBought: 0, valueSold: 0, valueNet: 0,
  });
  const [memeSimilarTokens, setMemeSimilarTokens] = useState<any[]>([]);
  const [memeSelectedInterval, setMemeSelectedInterval] = useState(
    () => localStorage.getItem('meme_chart_timeframe') || '1m',
  );
  const memeSelectedIntervalRef = useRef<string>(memeSelectedInterval);
  const [page, _setPage] = useState(0);
  const [initialMemeFetchDone, setInitialMemeFetchDone] = useState(false);
  const [currentPNLData, setCurrentPNLData] = useState({
    balance: 0,
    amountBought: 0,
    amountSold: 0,
    valueBought: 0,
    valueSold: 0,
    valueNet: 0,
  });
  const [currentTokenData, setCurrentTokenData] = useState({
    address: '',
    symbol: '',
    name: '',
    price: 0,
  });
  const memeRef = useRef<any>();
  const memeHoldersMapRef = useRef<Map<string, number>>(new Map());
  const memePositionsMapRef = useRef<Map<string, number>>(new Map());
  const memeTopTradersMapRef = useRef<Map<string, number>>(new Map());
  const memeDevTokenIdsRef = useRef<Set<string>>(new Set());
  const memeLastInvalidateRef = useRef(0);
  const pendingTradesRef = useRef<Array<any>>([]);
  const queuedUpdatesRef = useRef<Array<any>>([]);

  const calcDevHoldingPct = (list: Holder[], dev?: string) => {
    if (!dev) return 0;
    const row = list.find(
      (h) => (h.address || '').toLowerCase() === dev.toLowerCase(),
    );
    return row ? (Math.max(0, row.balance) / 1e9) * 100 : 0;
  };

  const addDevTokenFromEvent = useCallback(async (log: any, currentTokenDev?: string) => {
    try {
      const decoded: any = decodeEventLog({ abi: CrystalRouterAbi, data: log.data, topics: log.topics });
      const tokenId = String(decoded.args?.token || '').toLowerCase();
      const creator = String(decoded.args?.creator || '').toLowerCase();

      if (!currentTokenDev || creator !== String(currentTokenDev).toLowerCase()) return;
      if (memeDevTokenIdsRef.current.has(tokenId)) return;

      let imageUrl = decoded.args?.metadataCID || '';

      const symbol = String(decoded.args?.symbol || '').toUpperCase();
      const name = String(decoded.args?.name || symbol || tokenId.slice(0, 6));
      const price = 0;

      const newDev = {
        id: tokenId, symbol, name, imageUrl,
        price, marketCap: price * TOTAL_SUPPLY, timestamp: Math.floor(Date.now() / 1000), migrated: false,
      };

      setMemeDevTokens(prev => {
        if (prev.some(t => String(t.id).toLowerCase() === tokenId)) return prev;
        const updated = [newDev, ...prev];
        memeDevTokenIdsRef.current = new Set(updated.map(t => String(t.id || '').toLowerCase()));
        return updated;
      });
    } catch (e) {
      console.error('failed to decode MARKET_CREATED_EVENT', e);
    }
  }, []);

  const token: Token = useMemo(() => {
    const baseDefaults: Token = {
      id: tokenAddress || "",
      tokenAddress: tokenAddress || "",
      name: "Unknown Token",
      symbol: "UNKNOWN",
      dev: "",
      image: "",
      price: 0,
      marketCap: 0,
      change24h: 0,
      volume24h: 0,
      holders: 0,
      proTraders: 0,
      sniperHolding: 0,
      devHolding: 0,
      bundleHolding: 0,
      insiderHolding: 0,
      top10Holding: 0,
      buyTransactions: 0,
      sellTransactions: 0,
      globalFeesPaid: 0,
      website: "",
      twitterHandle: "",
      progress: 0,
      status: "new",
      description: "",
      created: Math.floor(Date.now() / 1000),
      bondingAmount: 0,
      volumeDelta: 0,
      telegramHandle: "",
      discordHandle: "",
      graduatedTokens: 0,
      launchedTokens: 0
    };

    const snapshot: Partial<Token> = (tokenData ?? {}) as Partial<Token>;
    const merged = {
      ...baseDefaults,
      ...snapshot,
    } as Token;

    merged.id = (tokenAddress || "").toLowerCase();
    merged.tokenAddress = (merged.tokenAddress || tokenAddress || "").toLowerCase();
    if (!merged.created) {
      merged.created = Math.floor(Date.now() / 1000);
    }
    memeRef.current = merged
    return merged;
  }, [tokenAddress, tokenData]);

  // metadata n klines
  useEffect(() => {
    if (!token.id) return;
    let isCancelled = false;

    const id = (token.id || '').toLowerCase();

    const fetchMemeTokenData = async () => {
      try {
        const response = await fetch(SUBGRAPH_URL, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({
            query: `
              query ($id: ID!) {
                launchpadTokens: launchpadTokens(where: { id: $id }) {
                  id
                  creator {
                    id
                    tokensLaunched
                    tokensGraduated
                  }
                  name
                  symbol
                  metadataCID
                  description
                  social1
                  social2
                  social3	
                  social4
                  decimals
                  initialSupply
                  timestamp
                  migrated
                  migratedAt
                  migratedMarket {
                    id
                  }
                  volumeNative
                  volumeToken
                  buyTxs
                  sellTxs
                  distinctBuyers
                  distinctSellers
                  lastPriceNativePerTokenWad
                  lastUpdatedAt
                  trades(first: 50, orderBy: block, orderDirection: desc) {
                    id account {id} block isBuy priceNativePerTokenWad amountIn amountOut
                  }
                  totalHolders
                  devHoldingAmount
                  holders(first:11, orderBy: tokens, orderDirection: desc, where:{tokens_gt:0}) {
                    account { id }
                    tokens
                  }
                  series: ${'series' + (
                memeSelectedInterval === '1s' ? '1' :
                  memeSelectedInterval === '5s' ? '5' :
                    memeSelectedInterval === '15s' ? '15' :
                      memeSelectedInterval === '1m' ? '60' :
                        memeSelectedInterval === '5m' ? '300' :
                          memeSelectedInterval === '15m' ? '900' :
                            memeSelectedInterval === '1h' ? '3600' :
                              memeSelectedInterval === '4h' ? '14400' : '86400'
              )
              } { 
                    klines(first: 1000, orderBy: time, orderDirection: desc) {
                      time open high low close baseVolume
                    } 
                  }
                }
              }`,
            variables: { id },
          }),
        });

        const data = (await response.json())?.data;
        if (isCancelled || !data) return;

        if (data.launchpadTokens?.length) {
          const m = data.launchpadTokens[0];

          let imageUrl = m.metadataCID || '';

          const price = Number(m.lastPriceNativePerTokenWad || 0) / 1e9;
          const socials = [m.social1, m.social2, m.social3, m.social4].map((s) =>
            s ? (/^https?:\/\//.test(s) ? s : `https://${s}`) : s,
          );
          const twitter = socials.find(
            (s) =>
              s?.startsWith('https://x.com') ||
              s?.startsWith('https://twitter.com'),
          );
          if (twitter) {
            socials.splice(socials.indexOf(twitter), 1);
          }
          const telegram = socials.find((s) => s?.startsWith('https://t.me'));
          if (telegram) {
            socials.splice(socials.indexOf(telegram), 1);
          }
          const discord = socials.find(
            (s) =>
              s?.startsWith('https://discord.gg') ||
              s?.startsWith('https://discord.com'),
          );
          if (discord) {
            socials.splice(socials.indexOf(discord), 1);
          }
          const website = socials[0];

          setTokenData(p => ({
            ...p,
            ...data.launchpadTokens[0],
            id: m.id.toLowerCase(),
            tokenAddress: m.id.toLowerCase(),
            dev: m.creator.id,
            name: m.name,
            symbol: m.symbol,
            image: imageUrl,
            twitterHandle: twitter ?? '',
            website: website ?? '',
            created: m.timestamp,
            status: m.migrated
              ? 'graduated'
              : price * TOTAL_SUPPLY > 12500
                ? 'graduating'
                : 'new',
            price,
            marketCap: price * TOTAL_SUPPLY,
            buyTransactions: Number(m.buyTxs),
            sellTransactions: Number(m.sellTxs),
            volume24h: Number(m.volumeNative) / 1e18,
            volumeDelta: 0,
            discordHandle: discord ?? '',
            telegramHandle: telegram ?? '',
            launchedTokens: m.creator.tokensLaunched ?? '',
            graduatedTokens: m.creator.tokensGraduated ?? '',
            holders: m.totalHolders - 1,
            devHolding: m.devHoldingAmount / 1e27,
            top10Holding: Number(
              (m.holders ?? [])
                .filter((h: { account?: { id?: string } }) => (h.account?.id?.toLowerCase() ?? '') !== (settings.chainConfig[activechain].router ?? '').toLowerCase())
                .slice(0, 10)
                .reduce((sum: bigint, h: { tokens: string }) => sum + BigInt(h.tokens || '0'), 0n)
            ) / 1e25,
          }));
        }

        if (data.launchpadTokens?.[0]?.trades?.length) {
          const mapped = data.launchpadTokens[0].trades.map((t: any) => ({
            id: t.id,
            timestamp: Number(t.block),
            isBuy: t.isBuy,
            price: Number(t.priceNativePerTokenWad) / 1e9,
            tokenAmount: Number(t.isBuy ? t.amountOut : t.amountIn) / 1e18,
            nativeAmount: Number(t.isBuy ? t.amountIn : t.amountOut) / 1e18,
            caller: t.account.id,
          }));
          setMemeTrades(mapped);
        } else {
          setMemeTrades([]);
        }

        if (data.launchpadTokens?.[0]?.series?.klines) {
          const bars = data.launchpadTokens[0].series.klines
            .slice()
            .reverse()
            .map((c: any) => ({
              time: Number(c.time) * 1000,
              open: Number(c.open) / 1e9,
              high: Number(c.high) / 1e9,
              low: Number(c.low) / 1e9,
              close: Number(c.close) / 1e9,
              volume: Number(c.baseVolume) / 1e18,
            }));

          const resForChart =
            memeSelectedInterval === '1d'
              ? '1D'
              : memeSelectedInterval === '4h'
                ? '240'
                : memeSelectedInterval === '1h'
                  ? '60'
                  : memeSelectedInterval.endsWith('s')
                    ? memeSelectedInterval.slice(0, -1).toUpperCase() + 'S'
                    : memeSelectedInterval.slice(0, -1);

          setChartData([bars, data.launchpadTokens[0].symbol + 'MON' + resForChart, true]);
        }

        setInitialMemeFetchDone(true);
      } catch (e) {
        console.error('Error fetching token data:', e);
        setTokenData(p => ({
          ...p,
          price: 0,
          marketCap: 0,
          volume24h: 0,
          buyTransactions: 0,
          sellTransactions: 0,
        }));
        setMemeTrades([]);
      }
    };

    fetchMemeTokenData();
    return () => { isCancelled = true; };
  }, [token.id, memeSelectedInterval]);

  // by-token oc initial
  useEffect(() => {
    if (!token.id || !initialMemeFetchDone) return;
    let cancelled = false;

    (async () => {
      const first = 100;
      const skip = page * 100;
      const m = (token.id || '').toLowerCase();

      const holdersPromise = (async () => {
        const response = await fetch(SUBGRAPH_URL, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({
            query: HOLDERS_QUERY,
            variables: { m, skip, first },
          }),
        });

        const { data } = await response.json();

        const positions: any[] = data?.launchpadPositions ?? [];
        const mapped: Holder[] = positions
          .filter(
            (p: any) =>
              p.account?.id.toLowerCase() !== settings.chainConfig[activechain].router.toLowerCase(),
          )
          .map((p: any) => {
            const amountBought = Number(p.tokenBought) / 1e18;
            const amountSold = Number(p.tokenSold) / 1e18;
            const valueBought = Number(p.nativeSpent) / 1e18;
            const valueSold = Number(p.nativeReceived) / 1e18;
            const balance = Number(p.tokens) / 1e18;
            const realized = valueSold - valueBought;
            const unrealized = balance * Number(data.launchpadTokens[0].lastPriceNativePerTokenWad || 0) / 1e9;
            const totalPnl = realized + unrealized;

            return {
              address: p.account.id,
              balance,
              amountBought,
              amountSold,
              valueBought,
              valueSold,
              tokenNet: balance,
              valueNet: totalPnl,
            };
          });

        const top10Pct = (mapped
          .map((h) => Math.max(0, h.balance))
          .sort((a, b) => b - a)
          .slice(0, 10)
          .reduce((s, n) => s + n, 0) / 1e9) * 100

        if (!cancelled) {
          setMemeTop10HoldingPct(top10Pct);
          const devPct = calcDevHoldingPct(mapped, token.dev);
          setTokenData((p: any) => ({ ...p, devHolding: devPct }));
          setMemeHolders(mapped);
          memeHoldersMapRef.current = new Map(
            mapped.map((h: Holder, i: number) => [h.address.toLowerCase(), i]),
          );
        }
      })();

      const topTradersPromise = (async () => {
        const out: Holder[] = [];

        const res = await fetch(SUBGRAPH_URL, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({
            query: TOP_TRADERS_QUERY,
            variables: { m, skip, first },
          }),
        });

        const { data } = await res.json();
        const rows: any[] = data?.launchpadPositions ?? [];

        for (const p of rows) {
          if (p.account.id.toLowerCase() != settings.chainConfig[activechain].router.toLowerCase()) {
            const amountBought = Number(p.tokenBought) / 1e18;
            const amountSold = Number(p.tokenSold) / 1e18;
            const valueBought = Number(p.nativeSpent) / 1e18;
            const valueSold = Number(p.nativeReceived) / 1e18;
            const balance = Number(p.tokens) / 1e18;
            const realized = valueSold - valueBought;
            const unrealized = balance * Number(data.launchpadTokens[0].lastPriceNativePerTokenWad || 0) / 1e9;
            const pnl = realized + unrealized;

            out.push({
              address: p.account.id,
              balance: amountBought - amountSold,
              tokenNet: amountBought - amountSold,
              valueNet: pnl,
              amountBought,
              amountSold,
              valueBought,
              valueSold,
            });
          }
        }

        if (!cancelled) {
          out.sort((a, b) => b.valueNet - a.valueNet);
          const trimmed = out.slice(0, 100);
          setMemeTopTraders(trimmed);
          memeTopTradersMapRef.current = new Map(
            trimmed.map((t, i) => [t.address.toLowerCase(), i]),
          );
        }
      })();

      await Promise.all([holdersPromise, topTradersPromise]);
    })();

    return () => {
      cancelled = true;
    };
  }, [token.id, page, initialMemeFetchDone]);

  // dev
  useEffect(() => {
    if (!token.id || !initialMemeFetchDone) return;
    const d = token.dev ? token.dev.toLowerCase() : '';
    if (!d) {
      setMemeDevTokens([]);
      memeDevTokenIdsRef.current = new Set();
      return;
    }

    let cancelled = false;
    (async () => {
      try {
        const first = 100;
        const skip = page * 100;

        const res = await fetch(SUBGRAPH_URL, {
          method: 'POST',
          headers: { 'content-type': 'application/json' },
          body: JSON.stringify({
            query: DEV_TOKENS_QUERY,
            variables: { d, skip, first },
          }),
        });

        const { data } = await res.json();
        const rows: any[] = data?.launchpadTokens ?? [];

        const out = [];
        for (const t of rows) {
          let imageUrl = t.metadataCID || '';
          const price = Number(t.lastPriceNativePerTokenWad || 0) / 1e9;
          out.push({
            id: t.id,
            symbol: t.symbol,
            name: t.name,
            imageUrl,
            price,
            marketCap: price * TOTAL_SUPPLY,
            timestamp: Number(t.timestamp ?? 0),
            status: t.migrated,
          });
        }

        if (!cancelled) {
          setMemeDevTokens(out);
          memeDevTokenIdsRef.current = new Set(
            out.map((t) => String(t.id || '').toLowerCase()),
          );
        }
      } catch (e) {
        if (!cancelled) {
          setMemeDevTokens([]);
          memeDevTokenIdsRef.current = new Set();
        }
        console.error('dev tokens fetch failed', e);
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [token.id, page, initialMemeFetchDone]);

  // similar tokens
  useEffect(() => {
    if (!token.id || !initialMemeFetchDone) return;

    const baseName = String(token.name || '').trim();
    const baseSymbol = String(token.symbol || '').trim();

    if (!baseName && !baseSymbol) {
      setMemeSimilarTokens([]);
      return;
    }

    let cancelled = false;

    const normalize = (s: string) =>
      s.toLowerCase().replace(/\s+/g, ' ').trim();
    const tokenize = (s: string) =>
      normalize(s)
        .split(/[^a-z0-9]+/i)
        .filter((w) => w.length >= 3 && !STOPWORDS.has(w))
        .slice(0, 8);
    const acronym = (s: string) =>
      (s.match(/\b([a-zA-Z0-9])/g) || []).join('').toLowerCase();
    const trigrams = (s: string) => {
      const t: string[] = [];
      const x = ` ${normalize(s)} `;
      for (let i = 0; i < x.length - 2; i++) t.push(x.slice(i, i + 3));
      return t;
    };
    const jaccard = (a: string[], b: string[]) => {
      const A = new Set(a);
      const B = new Set(b);
      let inter = 0;
      for (const v of A) if (B.has(v)) inter++;
      const uni = A.size + B.size - inter || 1;
      return inter / uni;
    };

    const edit = (a: string, b: string) => {
      const m = a.length,
        n = b.length;
      const dp = Array.from({ length: m + 1 }, (_, _i) =>
        new Array(n + 1).fill(0),
      );
      for (let i = 0; i <= m; i++) dp[i][0] = i;
      for (let j = 0; j <= n; j++) dp[0][j] = j;
      for (let i = 1; i <= m; i++) {
        for (let j = 1; j <= n; j++) {
          const cost = a[i - 1] === b[j - 1] ? 0 : 1;
          dp[i][j] = Math.min(
            dp[i - 1][j] + 1,
            dp[i][j - 1] + 1,
            dp[i - 1][j - 1] + cost,
          );
        }
      }
      return dp[m][n];
    };

    const scoreSimilarity = (
      qName: string,
      qSymbol: string,
      candName: string,
      candSymbol: string,
    ) => {
      const qs = normalize(qName);
      const cs = normalize(candName);
      const qTok = tokenize(qs);
      const cTok = tokenize(cs);

      let score = 0;

      score += 400 * jaccard(qTok, cTok);
      score += 300 * jaccard(trigrams(qs), trigrams(cs));

      if (cs.startsWith(qs) && qs.length >= 3) score += 200;
      if (qs.startsWith(cs) && cs.length >= 3) score += 120;
      if (cs.includes(qs) && qs.length >= 3) score += 120;

      const qa = acronym(qName);
      const ca = acronym(candName);
      if (qa && ca && qa === ca) score += 180;

      if (qs && cs) {
        const dist = edit(qs, cs);
        const norm = 1 - Math.min(1, dist / Math.max(qs.length, cs.length));
        score += 200 * norm;
      }

      const qSym = qSymbol.toLowerCase();
      const cSym = (candSymbol || '').toLowerCase();
      if (qSym && cSym) {
        if (qSym === cSym) score += 350;
        if (cSym.startsWith(qSym)) score += 220;
        else if (qSym.startsWith(cSym)) score += 160;
        else if (cSym.includes(qSym)) score += 140;
      }

      return score;
    };

    const STOPWORDS = new Set([
      'the',
      'a',
      'an',
      'token',
      'coin',
      'inu',
      'doge',
      'baby',
      'new',
      'of',
      'and',
      'for',
      'with',
      'club',
      'project',
    ]);

    (async () => {
      try {
        const exclude = token.id?.toLowerCase();
        const nameTerms = tokenize(baseName);
        const terms = Array.from(new Set(nameTerms)).slice(0, 4);
        const sym = baseSymbol.trim();
        const symTerms = sym.length >= 2 ? [sym, sym.slice(0, 3)].filter(Boolean) : [];
        const requests: Promise<Response>[] = [];

        for (const q of terms) {
          requests.push(
            fetch(SUBGRAPH_URL, {
              method: 'POST',
              headers: { 'content-type': 'application/json' },
              body: JSON.stringify({
                query: SIMILAR_TOKENS_BY_NAME_QUERY,
                variables: { q, exclude, first: 100 },
              }),
            }),
          );
        }

        for (const q of symTerms) {
          requests.push(
            fetch(SUBGRAPH_URL, {
              method: 'POST',
              headers: { 'content-type': 'application/json' },
              body: JSON.stringify({
                query: SIMILAR_TOKENS_BY_SYMBOL_QUERY,
                variables: { q, exclude, first: 50 },
              }),
            }),
          );
        }

        if (requests.length === 0 && baseName) {
          requests.push(
            fetch(SUBGRAPH_URL, {
              method: 'POST',
              headers: { 'content-type': 'application/json' },
              body: JSON.stringify({
                query: SIMILAR_TOKENS_BY_NAME_QUERY,
                variables: { q: baseName, exclude, first: 100 },
              }),
            }),
          );
        }

        const responses = await Promise.all(requests);
        const jsons = await Promise.all(responses.map((r) => r.json()));
        const candidates: any[] = [];
        for (const j of jsons) {
          const rows = j?.data?.launchpadTokens ?? [];
          for (const r of rows) candidates.push(r);
        }

        const mergedMap = new Map<string, any>();
        for (const r of candidates)
          mergedMap.set(String(r.id).toLowerCase(), r);
        const merged = Array.from(mergedMap.values());

        const scored = merged
          .map((t: any) => ({
            ...t,
            _score: scoreSimilarity(
              baseName,
              baseSymbol,
              t.name || '',
              t.symbol || '',
            ),
          }))
          .sort((a: any, b: any) => b._score - a._score)
          .slice(0, 5);

        const finalWithImages = await Promise.all(
          scored.map(async (t: any) => {
            let imageUrl = t.metadataCID || '';
            const price = Number(t.lastPriceNativePerTokenWad || 0) / 1e9;
            return {
              id: t.id,
              name: t.name,
              symbol: t.symbol,
              imageUrl,
              price,
              marketCap: price * TOTAL_SUPPLY,
              volume24h: Number(t.volumeNative || 0) / 1e18,
              timestamp: Number(t.timestamp ?? 0),
              lastUpdatedAt: Number(t.lastUpdatedAt),
            };
          }),
        );

        if (!cancelled) setMemeSimilarTokens(finalWithImages);
      } catch (e) {
        if (!cancelled) setMemeSimilarTokens([]);
        console.error('similar tokens fuzzy fetch failed', e);
      }
    })();

    return () => {
      cancelled = true;
    };
  }, [token.id, initialMemeFetchDone]);

  // positions aggregated across all wallets
  useEffect(() => {
    const allAddresses = [...new Set(
      [address, ...subWallets.map(w => w.address)]
        .filter(Boolean)
        .map(a => a.toLowerCase())
    )];

    if (allAddresses.length === 0 || !initialMemeFetchDone) return;

    let cancelled = false;

    (async () => {
      const totals = {
        balance: 0,
        amountBought: 0,
        amountSold: 0,
        valueBought: 0,
        valueSold: 0,
        lastPriceNative: 0,
      };

      const aggregatedMap = new Map<string, any>();

      const response = await fetch(SUBGRAPH_URL, {
        method: 'POST',
        headers: { 'content-type': 'application/json' },
        body: JSON.stringify({
          query: `
            query ($addrs: [Bytes!]!) {
              launchpadPositions(
                where: { account_in: $addrs, tokens_gt: "0" }
                orderBy: tokens
                orderDirection: desc
                first: 1000
              ) {
                token { id symbol name lastPriceNativePerTokenWad metadataCID }
                account { id }
                tokenBought
                tokenSold
                nativeSpent
                nativeReceived
                tokens
                lastUpdatedAt
              }
            }
          `,
          variables: { addrs: allAddresses },
        }),
      });

      const { data } = await response.json();
      const rows: any[] = data?.launchpadPositions ?? [];

      for (const p of rows) {
        const tokenId = p.token.id.toLowerCase();
        const boughtTokens = Number(p.tokenBought) / 1e18;
        const soldTokens = Number(p.tokenSold) / 1e18;
        const spentNative = Number(p.nativeSpent) / 1e18;
        const receivedNative = Number(p.nativeReceived) / 1e18;
        const lastPrice = Number(p.token.lastPriceNativePerTokenWad) / 1e9;
        const balance = Number(p.tokens) / 1e18;

        if (!aggregatedMap.has(tokenId)) {
          let imageUrl = p.token.metadataCID || '';

          aggregatedMap.set(tokenId, {
            tokenId: p.token.id,
            symbol: p.token.symbol,
            name: p.token.name,
            metadataCID: p.token.metadataCID,
            imageUrl: imageUrl,
            boughtTokens: 0,
            soldTokens: 0,
            spentNative: 0,
            receivedNative: 0,
            remainingTokens: 0,
            remainingPct: 0,
            pnlNative: 0,
            lastPrice: lastPrice,
          });
        }

        const existing = aggregatedMap.get(tokenId);
        existing.boughtTokens += boughtTokens;
        existing.soldTokens += soldTokens;
        existing.spentNative += spentNative;
        existing.receivedNative += receivedNative;
        existing.remainingTokens += balance;
        existing.lastPrice = lastPrice || existing.lastPrice;

        if (p.token.id.toLowerCase() === token.id?.toLowerCase()) {
          totals.amountBought += boughtTokens;
          totals.amountSold += soldTokens;
          totals.valueBought += spentNative;
          totals.valueSold += receivedNative;
          totals.balance += balance;
          totals.lastPriceNative = lastPrice || totals.lastPriceNative;
        }
      }

      if (cancelled) return;

      const all = Array.from(aggregatedMap.values()).map((pos) => {
        const realized = pos.receivedNative - pos.spentNative;
        const unrealized = pos.remainingTokens * pos.lastPrice;
        const pnlNative = realized + unrealized;
        const remainingPct =
          pos.boughtTokens > 0
            ? (pos.remainingTokens / pos.boughtTokens) * 100
            : 0;

        return {
          ...pos,
          remainingPct,
          pnlNative,
        };
      });

      const markToMarket = totals.balance * (totals.lastPriceNative || 0);
      const totalPnL = totals.valueSold + markToMarket - totals.valueBought;

      const sorted = all.sort((a, b) => b.remainingTokens - a.remainingTokens);
      setMemePositions(sorted);
      memePositionsMapRef.current = new Map(
        sorted.map((p, i) => [String(p.tokenId).toLowerCase(), i]),
      );

      setMemeUserStats({
        balance: totals.balance,
        amountBought: totals.amountBought,
        amountSold: totals.amountSold,
        valueBought: totals.valueBought,
        valueSold: totals.valueSold,
        valueNet: totalPnL,
      });
    })();

    return () => {
      cancelled = true;
    };
  }, [address, subWallets, token.id, initialMemeFetchDone]);

  // live dev holding
  useEffect(() => {
    const dev = (token.dev || "").toLowerCase();
    if (!dev) {
      setTokenData(p => ({ ...p, devHolding: 0 }));
      return;
    }

    const row = memeHolders.find(h => (h.address || "").toLowerCase() === dev);
    const pct = row ? (Math.max(0, row.balance || 0) / 1e9) * 100 : 0;

    setTokenData(p => ({ ...p, devHolding: pct }));
  }, [
    memeHolders,
    token.dev,
  ]);

  // data loop, reuse to have every single rpc call method in this loop
  const { data: terminalQueryData, isFetching: isTerminalDataFetching, dataUpdatedAt: terminalDataUpdatedAt, refetch: terminalRefetch } = useQuery({
    queryKey: [
      'crystal_rpc_terminal_reads',
      address,
      token.id,
      subWallets.length
    ],
    queryFn: async () => {
      let gasEstimateCall: any = null;
      let gasEstimate: bigint = 0n;
      const tokenAddresses = [
        ...Object.values(tokendict).map(t => t.address),
        ...(token.id ? [token.id] : [])
      ];

      if (address && (['board', 'spectra', 'meme'].includes(location.pathname.split('/')[1]))) {
        try {
          const deadline = BigInt(Math.floor(Date.now() / 1000) + 900);

          let tx: any = null;

          if (tx) {
            gasEstimateCall = {
              jsonrpc: '2.0',
              id: 1,
              method: 'eth_estimateGas',
              params: [{
                from: address as `0x${string}`,
                to: tx.target,
                data: tx.data,
                value: tx.value ? `0x${tx.value.toString(16)}` : '0x'
              }]
            };
          }
        } catch (e) {
          gasEstimateCall = null;
        }
      }

      const mainGroup: any = [
        {
          disabled: !scaAddress,
          to: balancegetter,
          abi: CrystalDataHelperAbi,
          functionName: 'batchBalanceOf',
          args: [
            scaAddress as `0x${string}`,
            tokenAddresses
          ]
        },
        ...subWallets.map(w => ({
          disabled: !w.address,
          to: balancegetter,
          abi: CrystalDataHelperAbi,
          functionName: 'batchBalanceOf',
          args: [
            w.address as `0x${string}`,
            tokenAddresses
          ]
        })),
        {
          disabled: !address || !token.id,
          to: balancegetter,
          abi: CrystalDataHelperAbi,
          functionName: 'getVirtualReserves',
          args: [
            router, token.id, weth, BigInt(1000000), BigInt(1), BigInt(100)
          ]
        },
      ];

      const groups: any = {
        mainGroup
      };

      const callData: any = []
      const callMapping: any = []

      const groupResults: any = {};
      Object.keys(groups).forEach(groupKey => {
        groupResults[groupKey] = [];
      });

      Object.entries(groups).forEach(([groupKey, group]: [string, any]) => {
        group.forEach((call: any, callIndex: number) => {
          if (!call.disabled) {
            try {
              callData.push({
                target: call.to || call.address,
                callData: encodeFunctionData({
                  abi: call.abi,
                  functionName: call.functionName,
                  args: call.args
                })
              });

              callMapping.push({
                groupKey,
                callIndex
              });
            } catch (e: any) {
              while (groupResults[groupKey].length < callIndex) {
                groupResults[groupKey].push(null);
              }
              groupResults[groupKey][callIndex] = { error: e.message, result: undefined, status: "failure" };
            }
          }
          else {
            while (groupResults[groupKey].length < callIndex) {
              groupResults[groupKey].push(null);
            }
            groupResults[groupKey][callIndex] = { error: "param missing", result: undefined, status: "failure" };
          }
        });
      });

      const multicallData: any = encodeFunctionData({
        abi: [{
          inputs: [
            { name: 'requireSuccess', type: 'bool' },
            {
              components: [
                { name: 'target', type: 'address' },
                { name: 'callData', type: 'bytes' }
              ], name: 'calls', type: 'tuple[]'
            }
          ],
          name: 'tryBlockAndAggregate',
          outputs: [
            { name: 'blockNumber', type: 'uint256' },
            { name: 'blockHash', type: 'bytes32' },
            {
              components: [
                { name: 'success', type: 'bool' },
                { name: 'returnData', type: 'bytes' }
              ], name: 'returnData', type: 'tuple[]'
            }
          ],
          stateMutability: 'view',
          type: 'function'
        }],
        functionName: 'tryBlockAndAggregate',
        args: [false, callData]
      })

      let shouldFetchNonce = false;
      if (Date.now() - lastNonceGroupFetch.current >= 9500) {
        lastNonceGroupFetch.current = Date.now();
        shouldFetchNonce = true;
      }

      const response: any = await fetch(HTTP_URL, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify([{
          jsonrpc: '2.0',
          id: 1,
          method: 'eth_call',
          params: [{ to: settings.chainConfig[activechain].multicall3, data: multicallData }, 'latest']
        }, ...(gasEstimateCall ? [gasEstimateCall] : []), ...(shouldFetchNonce ? subWallets.map(w => ({
          jsonrpc: '2.0',
          id: 1,
          method: 'eth_getTransactionCount',
          params: [w.address, 'latest']
        })) : [])])
      })

      const json: any = await response.json()


      const returnData: any = decodeFunctionResult({
        abi: [{
          inputs: [
            { name: 'requireSuccess', type: 'bool' },
            {
              components: [
                { name: 'target', type: 'address' },
                { name: 'callData', type: 'bytes' }
              ], name: 'calls', type: 'tuple[]'
            }
          ],
          name: 'tryBlockAndAggregate',
          outputs: [
            { name: 'blockNumber', type: 'uint256' },
            { name: 'blockHash', type: 'bytes32' },
            {
              components: [
                { name: 'success', type: 'bool' },
                { name: 'returnData', type: 'bytes' }
              ], name: 'returnData', type: 'tuple[]'
            }
          ],
          stateMutability: 'view',
          type: 'function'
        }],
        functionName: 'tryBlockAndAggregate',
        data: json[0].result
      })

      blockNumber.current = returnData?.[0]
      returnData?.[2]?.forEach((data: any, responseIndex: number) => {
        const { groupKey, callIndex } = callMapping[responseIndex] || {};
        if (groupKey === undefined) return;
        const originalCall = groups[groupKey][callIndex];
        while (groupResults[groupKey].length <= callIndex) {
          groupResults[groupKey].push(null);
        }
        if (data?.success == true) {
          try {
            const decodedResult = decodeFunctionResult({
              abi: originalCall.abi,
              functionName: originalCall.functionName,
              data: data?.returnData
            });
            groupResults[groupKey][callIndex] = { result: decodedResult, status: "success" };
          } catch (e: any) {
            groupResults[groupKey][callIndex] = { error: e.message, result: undefined, status: "failure" };
          }
        }
        else {
          groupResults[groupKey][callIndex] = { error: 'call reverted', result: undefined, status: "failure" };
        }
      });

      if (gasEstimateCall && json?.[1]?.result) {
        gasEstimate = BigInt(json[1].result)
      }

      if (shouldFetchNonce) {
        subWallets.forEach((w, i) => {
          const old = nonces.current?.get(w.address) || { pendingtxs: [] }
          if (old.pendingtxs.length == 0) old.nonce = parseInt(json[i + (gasEstimateCall ? 2 : 1)].result, 16)
          nonces.current.set(w.address, old)
        })
      }

      [{ address: scaAddress }].concat(subWallets as any).forEach((wallet, walletIndex) => {
        const balanceMap: { [key: string]: bigint } = {};
        let totalValue = 0;
        tokenAddresses.forEach((tokenAddress, index) => {
          if (groupResults?.mainGroup?.[walletIndex]?.result?.[index]) {
            balanceMap[tokenAddress] = groupResults?.mainGroup?.[walletIndex]?.result?.[index];

            try {
              const marketInfo = findMarketForToken(tokenAddress);
              if (marketInfo && marketInfo.trades) {
                const usdValue = calculateUSDValue(
                  groupResults?.mainGroup?.[walletIndex]?.result?.[index],
                  marketInfo.trades,
                  tokenAddress,
                  marketInfo.marketData
                );
                totalValue += usdValue;
              }
            } catch (error) {
              console.warn('Error calculating USD value for', tokenAddress, error);
            }
          }
        });

        setWalletTokenBalances(prev => ({
          ...prev,
          [wallet.address]: balanceMap
        }));

        setWalletTotalValues(prev => ({
          ...prev,
          [wallet.address]: totalValue
        }));
      })

      if (groupResults?.mainGroup?.at(-1)?.result) {
        const reservesData = groupResults?.mainGroup?.at(-1)?.result;
        setTokenData((prev: any) => ({ ...prev, reserveQuote: reservesData[0], reserveBase: reservesData[1] }));
      }
      return { readContractData: groupResults, gasEstimate: gasEstimate }
    },
    enabled: !!activeMarket && !!tokendict && !!markets,
    refetchInterval: ['board', 'spectra', 'meme'].includes(location.pathname.split('/')[1]) ? 800 : 5000,
    gcTime: 0,
  });

  // memeinterface ws
  /* useEffect(() => {
    if (!token.id || !initialMemeFetchDone) return;
    const wssUrl = settings.chainConfig[activechain]?.wssurl;
    const routerAddress = settings.chainConfig[activechain]?.router;

    if (!wssUrl || !routerAddress) return;

    const currentTokenDev = tokenData?.dev || '';

    const ws = new WebSocket(wssUrl);
    memeWsRef.current = ws;

    const sendSub = (params: any) => {
      const id = Date.now();
      try {
        const payload = { id, jsonrpc: '2.0', method: 'eth_subscribe', params };
        ws.send(JSON.stringify(payload));
        subsRef.current.set(id, { params, ok: false, ts: Date.now() });
        console.log('[ws] subscribing...', payload);
      } catch (e) {
        console.error('[ws] send failed for', params, e);
      }
    };

    ws.onopen = () => {
      sendSub(['monadLogs', { address: token.id, topics: [[TRANSFER_TOPIC]] }]);
      sendSub(['monadLogs', { address: routerAddress, topics: [[TRADE_EVENT, MARKET_CREATED_EVENT, MARKET_UPDATE_EVENT, '0xa2e7361c23d7820040603b83c0cd3f494d377bac69736377d75bb56c651a5098']] }]);
    };

    ws.onmessage = ({ data }) => {
      const msg = JSON.parse(data);
        if (typeof msg?.id === 'number') {
        const pending = subsRef.current.get(msg.id);
        if (!pending) return;

        if (msg.error) {
          console.error('ws subscribe error:', pending.params, msg.error);
          subsRef.current.set(msg.id, { ...pending, ok: false });
        } else if (msg.result) {
          subsRef.current.set(msg.id, { ...pending, ok: true, subId: msg.result });
          subIdsRef.current.add(msg.result);
        }
        return;
      }
      if (msg?.method !== 'eth_subscription') return;       
      const log = msg.params?.result;
      if (!log?.topics?.length || msg?.params?.result?.commitState != "Proposed") return;
      setProcessedLogs(prev => {
        let tempset = new Set(prev);
        const logIdentifier = `${log['transactionHash']}-${log['logIndex']}`;
        if (tempset.has(logIdentifier)) return tempset;
        if (tempset.size >= 10000) {
          const first = tempset.values().next().value;
          if (first !== undefined) {
            tempset.delete(first);
          }
        }
        tempset.add(logIdentifier);
        const resolve = txReceiptResolvers.current.get(log['transactionHash']);
        if (resolve) {
          resolve();
          txReceiptResolvers.current.delete(log['transactionHash']);
        }
        if (log.topics[0] === MARKET_UPDATE_EVENT) {
          const tokenAddr = `0x${log.topics[1].slice(26)}`.toLowerCase();
          const callerAddr = `0x${log.topics[2].slice(26)}`.toLowerCase();

          const hex = log.data.startsWith('0x') ? log.data.slice(2) : log.data;
          const word = (i: number) => BigInt('0x' + hex.slice(i * 64, i * 64 + 64));

          const isBuy = word(0) !== 0n;
          const inputAmountWei = word(1);
          const outputAmountWei = word(2);
          const vNativeWei = word(3);
          const vTokenWei = word(4);

          const toNum = (x: bigint) => Number(x) / 1e18;
          const amountIn = toNum(inputAmountWei);
          const amountOut = toNum(outputAmountWei);
          const vNative = Number(vNativeWei);
          const vToken = Number(vTokenWei);

          const price = vToken === 0 ? 0 : vNative / vToken;
          const tradePrice = (isBuy ? amountIn / amountOut : amountOut / amountIn) || 0;
          if (token.id && tokenAddr === token.id.toLowerCase()) {
            setTokenData(p => ({
              ...p,
              price,
              marketCap: price * TOTAL_SUPPLY,
              buyTransactions: (p?.buyTransactions || 0) + (isBuy ? 1 : 0),
              sellTransactions: (p?.sellTransactions || 0) + (isBuy ? 0 : 1),
              volume24h: (p?.volume24h || 0) + (isBuy ? amountIn : amountOut),
            }));

            setMemeTrades(prev => [
              {
                id: `${log.transactionHash}-${log.logIndex}`,
                timestamp: Date.now() / 1000,
                isBuy,
                price: tradePrice,
                nativeAmount: isBuy ? amountIn : amountOut,
                tokenAmount: isBuy ? amountOut : amountIn,
                caller: `0x${log.topics[2].slice(26)}`,
              },
              ...prev.slice(0, 99),
            ]);

            const sel = memeSelectedInterval;
            const RESOLUTION_SECS: Record<string, number> = {
              '1s': 1,
              '5s': 5,
              '15s': 15,
              '1m': 60,
              '5m': 300,
              '15m': 900,
              '1h': 3600,
              '4h': 14400,
              '1d': 86400,
            };
            const resSecs = RESOLUTION_SECS[sel] ?? 60;
            const now = Date.now();
            const bucket = Math.floor(now / (resSecs * 1000)) * resSecs * 1000;
            const volNative = isBuy ? amountIn : amountOut;

            setChartData((prev: any) => {
              if (!prev || !Array.isArray(prev) || prev.length < 2) return prev;

              const [bars, key, flag] = prev as [any[], string, boolean];
              const updated = bars.slice();
              const last = updated[updated.length - 1];

              if (!last || last.time < bucket) {
                const open = last?.close ?? tradePrice;
                updated.push({
                  time: bucket,
                  open,
                  high: Math.max(open, tradePrice),
                  low: Math.min(open, tradePrice),
                  close: tradePrice,
                  volume: volNative || 0,
                });
              } else {
                const cur = { ...last };
                cur.high = Math.max(cur.high, tradePrice);
                cur.low = Math.min(cur.low, tradePrice);
                cur.close = tradePrice;
                cur.volume = (cur.volume || 0) + (volNative || 0);
                updated[updated.length - 1] = cur;
              }

              if (updated.length > 1200) updated.splice(0, updated.length - 1200);
              return [updated, key, flag];
            });

            memePriceTickRef.current?.(tradePrice, isBuy ? amountIn : amountOut);

            setMemeHolders(prev => {
              const arr = prev.slice();
              let idx = memeHoldersMapRef.current.get?.(callerAddr);
              if (idx == undefined) {
                const fresh: Holder = {
                  address: `0x${log.topics[2].slice(26)}`,
                  balance: 0,
                  amountBought: 0,
                  amountSold: 0,
                  valueBought: 0,
                  valueSold: 0,
                  valueNet: 0,
                  tokenNet: 0,
                };
                arr.push(fresh);
                idx = arr.length - 1;
                memeHoldersMapRef.current.set(callerAddr, idx);
              }
              const h = { ...arr[idx] };
              if (isBuy) {
                h.amountBought = (h.amountBought || 0) + amountOut;
                h.valueBought = (h.valueBought || 0) + amountIn;
                h.balance = (h.balance || 0) + amountOut;
              } else {
                h.amountSold = (h.amountSold || 0) + amountIn;
                h.valueSold = (h.valueSold || 0) + amountOut;
                h.balance = Math.max(0, (h.balance || 0) - amountIn);
              }
              arr[idx] = h;

              for (let i = 0; i < arr.length; i++) {
                const h = arr[i];
                const realized = (h.valueSold || 0) - (h.valueBought || 0);
                const bal = Math.max(0, h.balance || 0);
                arr[i] = { ...h, valueNet: realized + bal * price };
              }
              const topSum = arr.map(h => Math.max(0, h.balance || 0)).sort((a, b) => b - a).slice(0, 10).reduce((s, n) => s + n, 0);
              setMemeTop10HoldingPct((topSum / TOTAL_SUPPLY) * 100);
              return arr;
            });

            setMemeTopTraders(prev => {
              const copy = Array.isArray(prev) ? [...prev] : [];
              const key = callerAddr;
              let idx = memeTopTradersMapRef.current.get(key) ?? -1;

              if (idx === -1) {
                const row: Holder = {
                  address: `0x${log.topics[2].slice(26)}`,
                  balance: 0, tokenNet: 0, valueNet: 0,
                  amountBought: 0, amountSold: 0,
                  valueBought: 0, valueSold: 0,
                };
                copy.push(row);
                idx = copy.length - 1;
                memeTopTradersMapRef.current.set(key, idx);
              }

              const row = { ...copy[idx] };
              const curBal = Math.max(0, (row.balance ?? row.amountBought - row.amountSold) || 0);
              if (isBuy) {
                row.amountBought = (row.amountBought || 0) + amountOut;
                row.valueBought = (row.valueBought || 0) + amountIn;
                row.balance = curBal + amountOut;
              } else {
                row.amountSold = (row.amountSold || 0) + amountIn;
                row.valueSold = (row.valueSold || 0) + amountOut;
                row.balance = Math.max(0, curBal - amountIn);
              }
              row.tokenNet = (row.amountBought || 0) - (row.amountSold || 0);
              copy[idx] = row;

              for (let i = 0; i < copy.length; i++) {
                const r = copy[i];
                const bal = Math.max(0, (r.balance ?? r.amountBought - r.amountSold) || 0);
                const realized = (r.valueSold || 0) - (r.valueBought || 0);
                copy[i] = { ...r, valueNet: realized + bal * price };
              }

              copy.sort((a, b) => b.valueNet - a.valueNet);
              if (copy.length > 300) {
                const removed = copy.splice(300);
                for (const r of removed) memeTopTradersMapRef.current.delete((r.address || '').toLowerCase());
              }
              copy.forEach((r, i) => memeTopTradersMapRef.current.set((r.address || '').toLowerCase(), i));
              return copy;
            });

            setMemePositions(prev => {
              const copy = Array.isArray(prev) ? [...prev] : [];
              const allUserAddresses = [
                (address || '').toLowerCase(),
                ...(subWallets || []).map(w => (w.address || '').toLowerCase()),
              ];
              const isUserTrade = allUserAddresses.includes(callerAddr);
              let idx = memePositionsMapRef.current.get(tokenAddr);

              if (idx === undefined && isUserTrade) {
                const newPos = {
                  tokenId: token.id?.toLowerCase(),
                  symbol: tokenData?.symbol || '',
                  name: tokenData?.name || '',
                  imageUrl: tokenData?.image || '',
                  metadataCID: '',
                  boughtTokens: 0,
                  soldTokens: 0,
                  spentNative: 0,
                  receivedNative: 0,
                  remainingTokens: 0,
                  remainingPct: 0,
                  pnlNative: 0,
                  lastPrice: price,
                };
                copy.push(newPos);
                idx = copy.length - 1;
                memePositionsMapRef.current.set(tokenAddr, idx);
              }
              if (idx === undefined) return prev;

              const pos = { ...copy[idx] };
              pos.lastPrice = price;
              if (isUserTrade) {
                if (isBuy) {
                  pos.boughtTokens += amountOut;
                  pos.spentNative += amountIn;
                  pos.remainingTokens += amountOut;
                } else {
                  pos.soldTokens += amountIn;
                  pos.receivedNative += amountOut;
                  pos.remainingTokens = Math.max(0, pos.remainingTokens - amountIn);
                }
              }
              pos.remainingPct = pos.boughtTokens > 0 ? (pos.remainingTokens / pos.boughtTokens) * 100 : 0;

              const balance = Math.max(0, pos.remainingTokens);
              const realized = (pos.receivedNative || 0) - (pos.spentNative || 0);
              const unrealized = balance * (pos.lastPrice || 0);
              pos.pnlNative = realized + unrealized;

              copy[idx] = pos;

              if (token.id && tokenAddr === token.id.toLowerCase()) {
                const markToMarket = balance * (pos.lastPrice || 0);
                const totalPnL = (pos.receivedNative || 0) + markToMarket - (pos.spentNative || 0);
                setMemeUserStats({
                  balance,
                  amountBought: pos.boughtTokens || 0,
                  amountSold: pos.soldTokens || 0,
                  valueBought: pos.spentNative || 0,
                  valueSold: pos.receivedNative || 0,
                  valueNet: totalPnL,
                });
              }
              return copy;
            });

            if (memeDevTokenIdsRef.current.has(tokenAddr)) {
              setMemeDevTokens(prev => {
                const updated = prev.map(t => {
                  if ((t.id || '').toLowerCase() !== tokenAddr) return t;
                  return { ...t, price, marketCap: price * TOTAL_SUPPLY, timestamp: Date.now() / 1000 };
                });
                memeDevTokenIdsRef.current = new Set(updated.map(t => (t.id || '').toLowerCase()));
                return updated;
              });
            }
          }
          return tempset;
        }

        if (log.topics[0] === MARKET_CREATED_EVENT) {
          addDevTokenFromEvent(log, currentTokenDev);
          return tempset;
        }

        if (log.topics[0] === TRADE_EVENT) {
          const marketAddr = `0x${log.topics[1].slice(26)}`.toLowerCase();
          const callerAddr = `0x${log.topics[2].slice(26)}`.toLowerCase();

          const mcfg = settings?.chainConfig?.[activechain]?.markets?.[marketAddr];
          if (!mcfg || !mcfg.baseAddress) return tempset;
          const tokenAddrFromMarket = (mcfg.baseAddress || '').toLowerCase();

          if (!token.id || tokenAddrFromMarket !== token.id.toLowerCase()) return tempset;

          const hex = log.data.startsWith('0x') ? log.data.slice(2) : log.data;
          const word = (i: number) => BigInt('0x' + hex.slice(i * 64, i * 64 + 64));

          const isBuy = word(0) !== 0n;
          const amountInWei = word(1);
          const amountOutWei = word(2);
          const endPrice = word(4);

          const amountIn = Number(amountInWei)  / 1e18;
          const amountOut = Number(amountOutWei) / 1e18;

          const priceFactor = Number(mcfg.priceFactor || 1);
          const price = priceFactor ? (Number(endPrice) / priceFactor) : 0;

          const tradePrice = price;

          setTokenData(p => ({
            ...p,
            price,
            marketCap: price * TOTAL_SUPPLY,
            buyTransactions: (p?.buyTransactions || 0) + (isBuy ? 1 : 0),
            sellTransactions: (p?.sellTransactions || 0) + (isBuy ? 0 : 1),
            volume24h: (p?.volume24h || 0) + (isBuy ? amountIn : amountOut),
          }));

          setMemeTrades(prev => [
            {
              id: `${log.transactionHash}-${log.logIndex}`,
              timestamp: Date.now() / 1000,
              isBuy,
              price: tradePrice,
              nativeAmount: isBuy ? amountIn : amountOut,
              tokenAmount:  isBuy ? amountOut : amountIn,
              caller: `0x${log.topics[2].slice(26)}`,
            },
            ...prev.slice(0, 99),
          ]);

          setTokenData((prev: any) => ({ ...prev, price, marketCap: price * TOTAL_SUPPLY }));

          {
            const sel = memeSelectedInterval;
            const RESOLUTION_SECS: Record<string, number> = {
              '1s': 1, '5s': 5, '15s': 15, '1m': 60, '5m': 300, '15m': 900,
              '1h': 3600, '4h': 14400, '1d': 86400,
            };
            const resSecs = RESOLUTION_SECS[sel] ?? 60;
            const now = Date.now();
            const bucket = Math.floor(now / (resSecs * 1000)) * resSecs * 1000;
            const volNative = isBuy ? amountIn : amountOut;

            setChartData((prev: any) => {
              if (!prev || !Array.isArray(prev) || prev.length < 2) return prev;
              const [bars, key, flag] = prev as [any[], string, boolean];
              const updated = bars.slice();
              const last = updated[updated.length - 1];

              if (!last || last.time < bucket) {
                const open = last?.close ?? tradePrice;
                updated.push({
                  time: bucket,
                  open,
                  high: Math.max(open, tradePrice),
                  low: Math.min(open, tradePrice),
                  close: tradePrice,
                  volume: volNative || 0,
                });
              } else {
                const cur = { ...last };
                cur.high = Math.max(cur.high, tradePrice);
                cur.low = Math.min(cur.low,  tradePrice);
                cur.close = tradePrice;
                cur.volume = (cur.volume || 0) + (volNative || 0);
                updated[updated.length - 1] = cur;
              }

              if (updated.length > 1200) updated.splice(0, updated.length - 1200);
              return [updated, key, flag];
            });

            memePriceTickRef.current?.(tradePrice, isBuy ? amountIn : amountOut);
          }

          setMemeHolders(prev => {
            const arr = prev.slice();
            let idx = memeHoldersMapRef.current.get?.(callerAddr);
            if (idx == undefined) {
              const fresh: Holder = {
                address: `0x${log.topics[2].slice(26)}`,
                balance: 0,
                amountBought: 0,
                amountSold: 0,
                valueBought: 0,
                valueSold: 0,
                valueNet: 0,
                tokenNet: 0,
              };
              arr.push(fresh);
              idx = arr.length - 1;
              memeHoldersMapRef.current.set(callerAddr, idx);
            }
            const h = { ...arr[idx] };
            if (isBuy) {
              h.amountBought = (h.amountBought || 0) + amountOut;
              h.valueBought = (h.valueBought || 0) + amountIn;
              h.balance = (h.balance || 0) + amountOut;
            } else {
              h.amountSold = (h.amountSold || 0) + amountIn;
              h.valueSold = (h.valueSold || 0) + amountOut;
              h.balance = Math.max(0, (h.balance || 0) - amountIn);
            }
            arr[idx] = h;

            for (let i = 0; i < arr.length; i++) {
              const hh = arr[i];
              const realized = (hh.valueSold || 0) - (hh.valueBought || 0);
              const bal = Math.max(0, hh.balance || 0);
              arr[i] = { ...hh, valueNet: realized + bal * price };
            }

            const topSum = arr
              .map(hh => Math.max(0, hh.balance || 0))
              .sort((a, b) => b - a)
              .slice(0, 10)
              .reduce((s, n) => s + n, 0);
            setMemeTop10HoldingPct((topSum / TOTAL_SUPPLY) * 100);
            return arr;
          });

          setMemeTopTraders(prev => {
            const copy = Array.isArray(prev) ? [...prev] : [];
            const key = callerAddr;
            let idx = memeTopTradersMapRef.current.get(key) ?? -1;

            if (idx === -1) {
              const row: Holder = {
                address: `0x${log.topics[2].slice(26)}`,
                balance: 0, tokenNet: 0, valueNet: 0,
                amountBought: 0, amountSold: 0,
                valueBought: 0, valueSold: 0,
              };
              copy.push(row);
              idx = copy.length - 1;
              memeTopTradersMapRef.current.set(key, idx);
            }

            const row = { ...copy[idx] };
            const curBal = Math.max(0, (row.balance ?? row.amountBought - row.amountSold) || 0);
            if (isBuy) {
              row.amountBought = (row.amountBought || 0) + amountOut;
              row.valueBought = (row.valueBought || 0) + amountIn;
              row.balance = curBal + amountOut;
            } else {
              row.amountSold = (row.amountSold || 0) + amountIn;
              row.valueSold = (row.valueSold || 0) + amountOut;
              row.balance = Math.max(0, curBal - amountIn);
            }
            row.tokenNet = (row.amountBought || 0) - (row.amountSold || 0);
            copy[idx] = row;

            for (let i = 0; i < copy.length; i++) {
              const r = copy[i];
              const bal = Math.max(0, (r.balance ?? r.amountBought - r.amountSold) || 0);
              const realized = (r.valueSold || 0) - (r.valueBought || 0);
              copy[i] = { ...r, valueNet: realized + bal * price };
            }

            copy.sort((a, b) => b.valueNet - a.valueNet);
            if (copy.length > 300) {
              const removed = copy.splice(300);
              for (const r of removed) memeTopTradersMapRef.current.delete((r.address || '').toLowerCase());
            }
            copy.forEach((r, i) => memeTopTradersMapRef.current.set((r.address || '').toLowerCase(), i));
            return copy;
          });

          setMemePositions(prev => {
            const copy = Array.isArray(prev) ? [...prev] : [];
            const allUserAddresses = [
              (address || '').toLowerCase(),
              ...(subWallets || []).map(w => (w.address || '').toLowerCase()),
            ];
            const isUserTrade = allUserAddresses.includes(callerAddr);

            let idx = memePositionsMapRef.current.get(tokenAddrFromMarket);
            if (idx === undefined && isUserTrade) {
              const newPos = {
                tokenId: token.id?.toLowerCase(),
                symbol: tokenData?.symbol || '',
                name: tokenData?.name   || '',
                imageUrl: tokenData?.image || '',
                metadataCID: '',
                boughtTokens: 0,
                soldTokens: 0,
                spentNative: 0,
                receivedNative: 0,
                remainingTokens: 0,
                remainingPct: 0,
                pnlNative: 0,
                lastPrice: price,
              };
              copy.push(newPos);
              idx = copy.length - 1;
              memePositionsMapRef.current.set(tokenAddrFromMarket, idx);
            }
            if (idx === undefined) return prev;

            const pos = { ...copy[idx] };
            pos.lastPrice = price;
            if (isUserTrade) {
              if (isBuy) {
                pos.boughtTokens += amountOut;
                pos.spentNative += amountIn;
                pos.remainingTokens = (pos.remainingTokens || 0) + amountOut;
              } else {
                pos.soldTokens += amountIn;
                pos.receivedNative += amountOut;
                pos.remainingTokens = Math.max(0, (pos.remainingTokens || 0) - amountIn);
              }
            }
            pos.remainingPct = pos.boughtTokens > 0
              ? (pos.remainingTokens / pos.boughtTokens) * 100
              : 0;

            const balance = Math.max(0, pos.remainingTokens);
            const realized = (pos.receivedNative || 0) - (pos.spentNative || 0);
            const unrealized = balance * (pos.lastPrice || 0);
            pos.pnlNative = realized + unrealized;

            copy[idx] = pos;

            if (token.id && tokenAddrFromMarket === token.id.toLowerCase()) {
              const markToMarket = balance * (pos.lastPrice || 0);
              const totalPnL = (pos.receivedNative || 0) + markToMarket - (pos.spentNative || 0);
              setMemeUserStats({
                balance,
                amountBought: pos.boughtTokens || 0,
                amountSold: pos.soldTokens   || 0,
                valueBought: pos.spentNative  || 0,
                valueSold: pos.receivedNative || 0,
                valueNet: totalPnL,
              });
            }
            return copy;
          });

          if (memeDevTokenIdsRef.current.has(tokenAddrFromMarket)) {
            setMemeDevTokens(prev => {
              const updated = prev.map(t => {
                if ((t.id || '').toLowerCase() !== tokenAddrFromMarket) return t;
                return { ...t, price, marketCap: price * TOTAL_SUPPLY, timestamp: Date.now() / 1000 };
              });
              memeDevTokenIdsRef.current = new Set(updated.map(t => (t.id || '').toLowerCase()));
              return updated;
            });
          }

          return tempset;
        }

        if (log.topics[0] == '0xa2e7361c23d7820040603b83c0cd3f494d377bac69736377d75bb56c651a5098') {

        }

        if (
          token.id &&
          log.address?.toLowerCase() === token.id.toLowerCase() &&
          log.topics[0] === TRANSFER_TOPIC &&
          address
        ) {
          const allWalletTopics = [
            '0x' + address.slice(2).padStart(64, '0'),
            ...(subWallets || []).map(w => '0x' + w.address.slice(2).padStart(64, '0')),
          ];
          const involvesWallet = allWalletTopics.some(t => log.topics[1] === t || log.topics[2] === t);
          if (involvesWallet) {
            const now = Date.now();
            if (now - memeLastInvalidateRef.current > 800) {
              memeLastInvalidateRef.current = now;
              try { terminalRefetch?.(); } catch { }
            }
          }
        }
        return tempset;
      })
    };

    ws.onerror = (ev) => {
      console.error('memeinterface ws error', ev);
    };

    ws.onclose = (ev) => {
      console.warn('memeinterface ws closed', ev.code, ev.reason);
    };

    return () => {
      try {
        console.log("ws closing");
        ws.close();
      } catch { }
    };
  }, [activechain, token.id, initialMemeFetchDone, address, subWallets]); */

  useEffect(() => {
    const cleaned = deduplicateWallets(subWallets);
    if (cleaned.length !== subWallets.length) {
      console.log(`Removed ${subWallets.length - cleaned.length} duplicate wallets on startup`);
      saveSubWallets(cleaned);
    }
  }, []);

  useEffect(() => {
    const handleMouseMove = (e: MouseEvent) => {
      if (!isVertDragging) return;

      e.preventDefault();
      e.stopPropagation();

      const mouseDeltaY = e.clientY - initialMousePosRef.current;
      const newHeight = Math.max(
        234,
        Math.min(450, initialHeightRef.current - mouseDeltaY),
      );

      setOrderCenterHeight(newHeight);
    };

    const handleMouseUp = (e: MouseEvent) => {
      if (!isVertDragging) return;

      e.preventDefault();
      e.stopPropagation();

      setIsVertDragging(false);
      document.body.style.cursor = '';
      document.body.style.userSelect = '';

      const overlay = document.getElementById('global-drag-overlay');
      if (overlay) {
        document.body.removeChild(overlay);
      }
    };

    if (isVertDragging) {
      const overlay = document.createElement('div');
      overlay.id = 'global-drag-overlay';
      overlay.style.position = 'fixed';
      overlay.style.top = '0';
      overlay.style.left = '0';
      overlay.style.width = '100%';
      overlay.style.height = '100%';
      overlay.style.zIndex = '9999';
      overlay.style.cursor = 'row-resize';
      document.body.appendChild(overlay);

      window.addEventListener('mousemove', handleMouseMove, { capture: true });
      window.addEventListener('mouseup', handleMouseUp, { capture: true });
    }

    return () => {
      window.removeEventListener('mousemove', handleMouseMove, {
        capture: true,
      });
      window.removeEventListener('mouseup', handleMouseUp, { capture: true });

      const overlay = document.getElementById('global-drag-overlay');
      if (overlay) {
        document.body.removeChild(overlay);
      }
    };
  }, [isVertDragging]);

  // auto resizer
  useEffect(() => {
    const handleResize = () => {
      if (window.innerHeight > 1080) {
        setOrderCenterHeight(367.58);
      } else if (window.innerHeight > 960) {
        setOrderCenterHeight(324.38);
      } else if (window.innerHeight > 840) {
        setOrderCenterHeight(282.18);
      } else if (window.innerHeight > 720) {
        setOrderCenterHeight(239.98);
      } else {
        setOrderCenterHeight(198.78);
      }
    };

    window.addEventListener('resize', handleResize);

    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);

  // dynamic title
  useEffect(() => {
    let title = 'Crystal | Decentralized Cryptocurrency Exchange';

    switch (true) {
      case location.pathname === '/portfolio':
        title = 'Portfolio | Crystal';
        break;
      case location.pathname === '/leaderboard':
        title = 'Leaderboard | Crystal';
        break;
      case location.pathname === '/launchpad':
        title = 'Launchpad | Crystal';
        break;
      case location.pathname === '/spectra':
        title = 'Spectra | Crystal';
        break;
      case location.pathname === '/trackers':
        title = 'Trackers | Crystal';
        break;
      case location.pathname === '/perps':
        title = 'Perpetuals | Crystal';
        break;
      case location.pathname.startsWith('/perps/'):
        if (perpsMarketsData && perpsActiveMarketKey) {
          const perpsMarket = perpsMarketsData[perpsActiveMarketKey];
          if (perpsMarket && perpsMarket.lastPrice) {
            const formattedPrice = formatSubscript(perpsMarket.lastPrice);
            title = `${formattedPrice} - ${perpsMarket.baseAsset} | Crystal`;
          } else {
            title = 'Perpetuals | Crystal';
          }
        } else {
          title = 'Perpetuals | Crystal';
        }
        break;
      case location.pathname.startsWith('/earn/vaults'):
        if (location.pathname === '/earn/vaults') {
          title = 'Vaults | Crystal';
        } else {
          const pathParts = location.pathname.split('/');
          if (pathParts.length >= 4) {
            const vaultAddress = pathParts[3];
            title = `Vault ${vaultAddress.slice(0, 8)}... | Crystal`;
          }
        }
        break;
      case location.pathname.startsWith('/earn'):
        if (location.pathname === '/earn' || location.pathname === '/earn/liquidity-pools') {
          title = 'Earn | Crystal';
        } else if (location.pathname.startsWith('/earn/liquidity-pools/')) {
          const pathParts = location.pathname.split('/');
          if (pathParts.length >= 4) {
            const poolIdentifier = pathParts[3];
            const [firstToken, secondToken] = poolIdentifier.split('-');
            title = `${firstToken.toUpperCase()}-${secondToken.toUpperCase()} Pool | Crystal`;
          }
        }
        break;
      case ['/swap', '/market', '/limit', '/send', '/scale'].includes(location.pathname):
        if (trades.length > 0) {
          const formattedPrice = formatSubscript(trades[0][1]);
          if (activeMarket.quoteAsset) {
            title = `${formattedPrice} - ${activeMarket.baseAsset + '/' + activeMarket.quoteAsset} | Crystal`;
          } else {
            title = `${location.pathname.slice(1).charAt(0).toUpperCase() + location.pathname.slice(2)} | Crystal`;
          }
        }
        break;
    }

    document.title = title;
  }, [trades, location.pathname, activeMarket, perpsMarketsData, perpsActiveMarketKey]);

  useEffect(() => {
    if (prevOrderData && Array.isArray(prevOrderData) && prevOrderData.length >= 4) {
      try {
        const buyOrdersRaw: bigint[] = [];
        const sellOrdersRaw: bigint[] = [];

        for (let i = 2; i < prevOrderData[4].length; i += 64) {
          const chunk = prevOrderData[4].slice(i, i + 64);
          buyOrdersRaw.push(BigInt(`0x${chunk}`));
        }

        for (let i = 2; i < prevOrderData[5].length; i += 64) {
          const chunk = prevOrderData[5].slice(i, i + 64);
          sellOrdersRaw.push(BigInt(`0x${chunk}`));
        }

        const {
          buyOrders: processedBuyOrders,
          sellOrders: processedSellOrders,
        } = processOrders(buyOrdersRaw, sellOrdersRaw);

        const { roundedOrders: roundedBuy, } =
          processOrdersForDisplay(
            processedBuyOrders,
            amountsQuote,
            processedBuyOrders?.[0]?.price && processedSellOrders?.[0]?.price ? (processedBuyOrders?.[0]?.price + processedSellOrders?.[0]?.price) / 2 : processedBuyOrders?.[0]?.price,
            orders,
            true,
          );
        const {
          roundedOrders: roundedSell,
        } = processOrdersForDisplay(
          processedSellOrders,
          amountsQuote,
          processedBuyOrders?.[0]?.price && processedSellOrders?.[0]?.price ? (processedBuyOrders?.[0]?.price + processedSellOrders?.[0]?.price) / 2 : processedSellOrders?.[0]?.price,
          orders,
          false,
        );

        if (prevAmountsQuote.current == amountsQuote) {
          const prevBuyMap = new Map(roundedBuyOrders?.orders?.map((o, i) => [`${o.price}_${o.size}`, i]));
          const prevSellMap = new Map(roundedSellOrders?.orders?.map((o, i) => [`${o.price}_${o.size}`, i]));

          for (let i = 0; i < roundedBuy.length; i++) {
            const prevIndex = prevBuyMap.get(`${roundedBuy[i].price}_${roundedBuy[i].size}`);
            if (prevIndex === undefined || (i === 0 && prevIndex !== 0)) {
              roundedBuy[i].shouldFlash = true;
            }
          }

          for (let i = 0; i < roundedSell.length; i++) {
            const prevIndex = prevSellMap.get(`${roundedSell[i].price}_${roundedSell[i].size}`);
            if (prevIndex === undefined || (i === 0 && prevIndex !== 0)) {
              roundedSell[i].shouldFlash = true;
            }
          }
        }

        const interval = localStorage.getItem(`${activeMarket.baseAsset}_ob_interval`)
          ? Number(
            localStorage.getItem(
              `${activeMarket.baseAsset}_ob_interval`,
            ),
          )
          : 1 / (activeMarket?.marketType != 0 && (Number(prevOrderData[0]) * Number(activeMarket.scaleFactor) / Number(prevOrderData[1]) / Number(activeMarket.priceFactor)) ? 10 ** Math.max(0, 5 - Math.floor(Math.log10((Number(prevOrderData[0]) * Number(activeMarket.scaleFactor) / Number(prevOrderData[1]) / Number(activeMarket.priceFactor)))) - 1) : Number(activeMarket.priceFactor))
        const { bids, asks } = v2ToOrderbook(prevOrderData[1], prevOrderData[0], interval * 10, Number(activeMarket.baseDecimals), Number(activeMarket.quoteDecimals), amountsQuote);

        setRoundedBuyOrders({ orders: roundedBuy.concat(bids as any), key: activeMarketKey, amountsQuote });
        setRoundedSellOrders({ orders: roundedSell.concat(asks as any), key: activeMarketKey, amountsQuote });
        prevAmountsQuote.current = amountsQuote
      } catch (error) {
        console.error(error);
      }
    }
  }, [amountsQuote, orders.length > 0]);

  // process data
  useLayoutEffect(() => {
    const data = rpcQueryData?.readContractData?.mainGroup;
    const refData = rpcQueryData?.readContractData?.refGroup;
    const oneCTDepositData = rpcQueryData?.readContractData?.oneCTDepositGroup;
    if (!isLoading && data) {
      if (!txPending.current && !debounceTimerRef.current) {
        if (data?.[1]?.result != null) {
          setallowance(data[1].result);
        }
        let tempbalances = tokenBalances
        if (data?.[2]?.result || !address) {
          tempbalances = [...Object.values(tokendict), ...Object.values(markets)].reduce((acc, token, i) => {
            const balance = data[2].result?.[i] || BigInt(0);
            acc[token.address] = balance;
            return acc;
          }, {});
          if (stateloading || sliderPercent == 0) {
            const percentage = !tempbalances[tokenIn]
              ? 0
              : Math.min(
                100,
                Math.floor(
                  Number((amountIn * BigInt(100)) / tempbalances[tokenIn]),
                ),
              );
            setSliderPercent(percentage);
            const slider = document.querySelector('.balance-amount-slider');
            const popup = document.querySelector('.slider-percentage-popup');
            if (slider && popup) {
              const rect = slider.getBoundingClientRect();
              (popup as HTMLElement).style.left =
                `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
            }
          }
          setBalanceAddress(address);
          setTokenBalances(tempbalances);
        }
        if (tokenIn === eth && tokendict[tokenOut]?.lst && isStake) {
          setStateIsLoading(false);
          setstateloading(false);
          const stakeResult = data?.[5]?.result as bigint | undefined;
          if (stakeResult !== undefined && (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market')) {
            if (switched === false) {
              setamountOutSwap(stakeResult);
              setoutputString(
                stakeResult === 0n
                  ? ''
                  : customRound(
                    Number(stakeResult) /
                    10 ** Number(tokendict[tokenOut].decimals),
                    3,
                  ).toString(),
              );
            } else {
              setamountIn(stakeResult);
              setInputString(
                stakeResult === 0n
                  ? ''
                  : customRound(
                    Number(stakeResult) /
                    10 ** Number(tokendict[tokenIn].decimals),
                    3,
                  ).toString(),
              );
              const percentage = !tempbalances[tokenIn]
                ? 0
                : Math.min(
                  100,
                  Math.floor(
                    Number((stakeResult * BigInt(100)) / tempbalances[tokenIn]),
                  ),
                );
              setSliderPercent(percentage);
              const slider = document.querySelector('.balance-amount-slider');
              const popup = document.querySelector('.slider-percentage-popup');
              if (slider && popup) {
                const rect = slider.getBoundingClientRect();
                (popup as HTMLElement).style.left =
                  `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
              }
            }
          }
        } else if (data?.[0]?.result || (data?.[0]?.error == 'call reverted') || (data?.[0]?.error == 'param missing')) {
          setStateIsLoading(false);
          setstateloading(false);
          if (switched == false && !isWrap && (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market')) {
            const outputValue = BigInt(data[0].result?.at(-1) || BigInt(0));
            setamountOutSwap(outputValue);
            setoutputString(
              outputValue === BigInt(0)
                ? ''
                : parseFloat(
                  customRound(
                    Number(outputValue) /
                    10 ** Number(tokendict[tokenOut].decimals),
                    3,
                  ),
                ).toString(),
            );
          } else if (!isWrap && (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market')) {
            let inputValue;
            if (BigInt(data[0].result?.at(-1) || BigInt(0)) != amountOutSwap) {
              inputValue = BigInt(0);
            } else {
              inputValue = BigInt(data[0].result?.[0] || BigInt(0));
            }
            setamountIn(inputValue);
            setInputString(
              inputValue == BigInt(0)
                ? ''
                : parseFloat(
                  customRound(
                    Number(inputValue) /
                    10 ** Number(tokendict[tokenIn].decimals),
                    3,
                  ),
                ).toString(),
            );
            const percentage = !tempbalances[tokenIn]
              ? 0
              : Math.min(
                100,
                Math.floor(
                  Number((inputValue * BigInt(100)) / tempbalances[tokenIn]),
                ),
              );
            setSliderPercent(percentage);
            const slider = document.querySelector('.balance-amount-slider');
            const popup = document.querySelector('.slider-percentage-popup');
            if (slider && popup) {
              const rect = slider.getBoundingClientRect();
              (popup as HTMLElement).style.left =
                `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
            }
          }
        }
      }
      let tempmids = mids;
      if (data?.[4]?.result) {
        tempmids = Object.keys(markets).filter((key) => {
          return !(
            key.startsWith(wethticker) || key.endsWith(wethticker)
          );
        }).reduce(
          (acc, market, i) => {
            const prices = [
              (data as any)[4].result?.[2][i],
              (data as any)[4].result?.[3][i],
              (data as any)[4].result?.[4][i],
              (data as any)[4].result?.[0][i],
              (data as any)[4].result?.[1][i],
            ];
            acc[market] = prices;
            return acc;
          },
          {} as Record<string, any>,
        );
        setmids(tempmids);
      }
      if (data?.[3]?.result) {
        const orderdata = data[3].result;
        setReserveQuote(orderdata[0])
        setReserveBase(orderdata[1])
        let ammPrice = orderdata[1] == 0n ? 0 : ((BigInt(orderdata[0]) * activeMarket.scaleFactor * 9975n * 100000n + (BigInt(orderdata[1]) * 10000n * activeMarket.makerRebate - 1n)) / (BigInt(orderdata[1]) * 10000n * activeMarket.makerRebate));
        let temphighestBid = orderdata[2] < ammPrice ? ammPrice : orderdata[2]
        sethighestBid(temphighestBid || BigInt(0));
        temphighestBid = Number(temphighestBid);
        ammPrice = orderdata[1] == 0n ? Infinity : ((BigInt(orderdata[0]) * activeMarket.scaleFactor * 10000n * activeMarket.makerRebate) / (BigInt(orderdata[1]) * 9975n * 100000n));
        let templowestAsk = orderdata[3] > ammPrice ? ammPrice : orderdata[3]
        setlowestAsk(templowestAsk || BigInt(0));
        templowestAsk = Number(templowestAsk);
        setPrevOrderData(orderdata as any);
        if (orderdata && Array.isArray(orderdata) && orderdata.length >= 4 && !(orderdata[0] == prevOrderData[0] && orderdata[1] == prevOrderData[1] && orderdata[2] == prevOrderData[2] &&
          orderdata[3] == prevOrderData[3] &&
          orderdata[4]?.toLowerCase() == prevOrderData[4]?.toLowerCase() &&
          orderdata[5]?.toLowerCase() == prevOrderData[5]?.toLowerCase())) {
          try {
            const buyOrdersRaw: bigint[] = [];
            const sellOrdersRaw: bigint[] = [];

            for (let i = 2; i < orderdata[4].length; i += 64) {
              const chunk = orderdata[4].slice(i, i + 64);
              buyOrdersRaw.push(BigInt(`0x${chunk}`));
            }

            for (let i = 2; i < orderdata[5].length; i += 64) {
              const chunk = orderdata[5].slice(i, i + 64);
              sellOrdersRaw.push(BigInt(`0x${chunk}`));
            }

            const {
              buyOrders: processedBuyOrders,
              sellOrders: processedSellOrders,
            } = processOrders(buyOrdersRaw, sellOrdersRaw);

            const { roundedOrders: roundedBuy, defaultOrders: liquidityBuy } =
              processOrdersForDisplay(
                processedBuyOrders,
                amountsQuote,
                processedBuyOrders?.[0]?.price && processedSellOrders?.[0]?.price ? (processedBuyOrders?.[0]?.price + processedSellOrders?.[0]?.price) / 2 : processedBuyOrders?.[0]?.price,
                orders,
                true,
              );
            const {
              roundedOrders: roundedSell,
              defaultOrders: liquiditySell,
            } = processOrdersForDisplay(
              processedSellOrders,
              amountsQuote,
              processedBuyOrders?.[0]?.price && processedSellOrders?.[0]?.price ? (processedBuyOrders?.[0]?.price + processedSellOrders?.[0]?.price) / 2 : processedSellOrders?.[0]?.price,
              orders,
              false,
            );

            if (temphighestBid == 0 && templowestAsk != Number(activeMarket.maxPrice)) {
              temphighestBid = templowestAsk
            }
            else if (templowestAsk == Number(activeMarket.maxPrice) && temphighestBid != 0) {
              templowestAsk = temphighestBid
            }
            temphighestBid /= Number(activeMarket.priceFactor)
            templowestAsk /= Number(activeMarket.priceFactor)

            const spread = {
              spread:
                temphighestBid !== undefined && templowestAsk !== undefined
                  ? templowestAsk - temphighestBid
                  : NaN,
              averagePrice:
                temphighestBid !== undefined && templowestAsk !== undefined
                  ? ((temphighestBid + templowestAsk) / 2) : NaN,
            };

            const prevBuyMap = new Map(roundedBuyOrders?.orders?.map((o, i) => [`${o.price}_${o.size}`, i]));
            const prevSellMap = new Map(roundedSellOrders?.orders?.map((o, i) => [`${o.price}_${o.size}`, i]));

            for (let i = 0; i < roundedBuy.length; i++) {
              const prevIndex = prevBuyMap.get(`${roundedBuy[i].price}_${roundedBuy[i].size}`);
              if (prevIndex === undefined || (i === 0 && prevIndex !== 0)) {
                roundedBuy[i].shouldFlash = true;
              }
            }

            for (let i = 0; i < roundedSell.length; i++) {
              const prevIndex = prevSellMap.get(`${roundedSell[i].price}_${roundedSell[i].size}`);
              if (prevIndex === undefined || (i === 0 && prevIndex !== 0)) {
                roundedSell[i].shouldFlash = true;
              }
            }

            const interval = localStorage.getItem(`${activeMarket.baseAsset}_ob_interval`)
              ? Number(
                localStorage.getItem(
                  `${activeMarket.baseAsset}_ob_interval`,
                ),
              )
              : 1 / (activeMarket?.marketType != 0 && spread?.averagePrice ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(spread?.averagePrice ?? 1)) - 1) : Number(activeMarket.priceFactor))

            const { bids, asks } = v2ToOrderbook(orderdata[1], orderdata[0], interval * 10, Number(activeMarket.baseDecimals), Number(activeMarket.quoteDecimals), amountsQuote);

            setSpreadData({ spread: `${((spread?.spread / spread?.averagePrice) * 100).toFixed(2)}%`, averagePrice: formatSubscript(formatSig(spread?.averagePrice.toFixed(Math.floor(Math.log10(Number(activeMarket.priceFactor)))), activeMarket?.marketType != 0)) });
            setRoundedBuyOrders({ orders: roundedBuy.concat(bids as any), key: activeMarketKey, amountsQuote });
            setRoundedSellOrders({ orders: roundedSell.concat(asks as any), key: activeMarketKey, amountsQuote });
            setLiquidityBuyOrders({ orders: liquidityBuy, market: activeMarket.address });
            setLiquiditySellOrders({ orders: liquiditySell, market: activeMarket.address });
            setBaseInterval(1 / (activeMarket?.marketType != 0 && spread?.averagePrice ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(spread?.averagePrice ?? 1)) - 1) : Number(activeMarket.priceFactor)));
            setOBInterval(interval);
          } catch (error) {
            console.error(error);
          }
        }
      }
      if (refData && Object.keys(tempmids).length > 0) {
        setUsedRefAddress(
          refData[0]?.result?.[0] as any || '0x0000000000000000000000000000000000000000',
        );
        setUsedRefLink(refData[0]?.result?.[1]);
        setRefLink(refData[0]?.result?.[2]);
        setClaimableFees(() => {
          let newFees = {};
          let totalFees = 0;
          Array.from(
            Object.values(tokendict).reduce((acc, market: any) => {
              if (!acc.has(market.address)) acc.set(market.address, market);
              return acc;
            }, new Map<string, any>()).values()
          ).forEach((token: any, index) => {
            if (
              tempmids !== null &&
              token !== null
            ) {
              const quoteIndex = index;
              const quotePrice = token.ticker == 'USDC' ? 1 : Number(tempmids[(token.ticker == wethticker ? ethticker : token.ticker) + 'USDC']?.[0])
                / Number(markets[(token.ticker == wethticker ? ethticker : token.ticker) + 'USDC']?.priceFactor)
              if (Number(refData[quoteIndex + 1]?.result) > 0) {
                if (!(newFees as any)[token.address]) {
                  (newFees as any)[token.address] =
                    Number(refData[quoteIndex + 1].result) /
                    10 ** Number(token.decimals);
                  totalFees +=
                    Number(refData[quoteIndex + 1].result) * quotePrice /
                    10 ** Number(token.decimals);
                } else {
                  (newFees as any)[token.address] +=
                    Number(refData[quoteIndex + 1].result) /
                    10 ** Number(token.decimals);
                  totalFees +=
                    Number(refData[quoteIndex + 1].result) * quotePrice /
                    10 ** Number(token.decimals);
                }
              }
            }
          });
          setTotalClaimableFees(totalFees || 0);
          return newFees;
        });
      }
      if (oneCTDepositData?.[0]?.result || !scaAddress) {
        let tempbalances = mainWalletBalances;
        tempbalances = Object.values(tokendict).reduce((acc, token, i) => {
          const balance = oneCTDepositData?.[0]?.result?.[i] || BigInt(0);
          acc[token.address] = balance;
          return acc;
        }, {});
        setMainWalletBalances(tempbalances);
      }
    } else {
    }
  }, [rpcQueryData?.readContractData, activechain, isLoading, dataUpdatedAt, location.pathname.slice(1)]);

  // update display values when loading is finished
  useLayoutEffect(() => {
    if (!isLoading && !stateIsLoading && Object.keys(mids).length > 0) {
      setDisplayValuesLoading(false);
      if (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market') {
        let estPrice = multihop
          ? (Number(amountIn) * 100000) /
          Number(activeMarket.fee) /
          10 ** Number(tokendict[tokenIn].decimals) /
          (Number(amountOutSwap) /
            10 ** Number(tokendict[tokenOut].decimals)) ||
          (() => {
            let price = 1;
            let mid;
            for (let i = 0; i < activeMarket.path.length - 1; i++) {
              let market = getMarket(
                activeMarket.path[i],
                activeMarket.path[i + 1],
              );
              if (activeMarket.path[i] == market.quoteAddress) {
                mid = Number(mids[(market.baseAsset + market.quoteAsset).replace(
                  new RegExp(
                    `^${wethticker}|${wethticker}$`,
                    'g'
                  ),
                  ethticker
                )][2]);
                price *= mid / Number(market.priceFactor);
              } else {
                mid = Number(mids[(market.baseAsset + market.quoteAsset).replace(
                  new RegExp(
                    `^${wethticker}|${wethticker}$`,
                    'g'
                  ),
                  ethticker
                )][1]);
                price /= mid / Number(market.priceFactor);
              }
            }
            return price;
          })()
          : amountIn != BigInt(0) && amountOutSwap != BigInt(0)
            ? Number(
              tokenIn == activeMarket.quoteAddress
                ? amountIn
                : (Number(amountOutSwap) * 100000) / Number(activeMarket.fee),
            ) /
            10 ** Number(tokendict[activeMarket.quoteAddress].decimals) /
            (Number(
              tokenIn == activeMarket.quoteAddress
                ? (Number(amountOutSwap) * 100000) / Number(activeMarket.fee)
                : amountIn,
            ) /
              10 ** Number(tokendict[activeMarket.baseAddress].decimals))
            : (tokenIn == activeMarket.quoteAddress
              ? Number(lowestAsk)
              : Number(highestBid)) / Number(activeMarket.priceFactor);
        setAveragePrice(
          multihop
            ? `${customRound(estPrice, 2)}`
            : `${formatSubscript(formatSig(estPrice.toFixed(Math.floor(Math.log10(Number(activeMarket.priceFactor)))), activeMarket?.marketType != 0))}`,
        );
        setPriceImpact(() => {
          let temppriceimpact;
          if (multihop) {
            let price = 1;
            let mid;
            for (let i = 0; i < activeMarket.path.length - 1; i++) {
              let market = getMarket(
                activeMarket.path[i],
                activeMarket.path[i + 1],
              );
              mid = Number(mids[(market.baseAsset + market.quoteAsset).replace(
                new RegExp(
                  `^${wethticker}|${wethticker}$`,
                  'g'
                ),
                ethticker
              )][0]);
              if (activeMarket.path[i] == market.quoteAddress) {
                price *= mid / Number(market.priceFactor);
              } else {
                price /= mid / Number(market.priceFactor);
              }
            }
            temppriceimpact = `${customRound(
              0.001 > Math.abs(((estPrice - price) / price) * 100)
                ? 0
                : Math.abs(((estPrice - price) / price) * 100),
              3,
            )}%`;
          } else {
            temppriceimpact = `${customRound(
              0.001 >
                Math.abs(
                  ((estPrice -
                    (tokenIn == activeMarket.quoteAddress
                      ? Number(lowestAsk) / Number(activeMarket.priceFactor)
                      : Number(highestBid) / Number(activeMarket.priceFactor))) /
                    (tokenIn == activeMarket.quoteAddress
                      ? Number(lowestAsk) / Number(activeMarket.priceFactor)
                      : Number(highestBid) / Number(activeMarket.priceFactor))) *
                  100,
                )
                ? 0
                : Math.abs(
                  ((estPrice -
                    (tokenIn == activeMarket.quoteAddress
                      ? Number(lowestAsk) / Number(activeMarket.priceFactor)
                      : Number(highestBid) /
                      Number(activeMarket.priceFactor))) /
                    (tokenIn == activeMarket.quoteAddress
                      ? Number(lowestAsk) / Number(activeMarket.priceFactor)
                      : Number(highestBid) /
                      Number(activeMarket.priceFactor))) *
                  100,
                ),
              3,
            )}%`;
          }
          setSwapButtonDisabled(
            (amountIn === BigInt(0) ||
              amountIn > tokenBalances[tokenIn] ||
              ((orderType == 1 || multihop) &&
                !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) &&
                rpcQueryData?.readContractData?.mainGroup?.[0].result?.at(0) == undefined)) &&
            connected &&
            userchain == activechain,
          );
          setSwapButton(
            connected && userchain == activechain
              ? (switched &&
                amountOutSwap != BigInt(0) &&
                amountIn == BigInt(0)) ||
                ((orderType == 1 || multihop) &&
                  !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) &&
                  rpcQueryData?.readContractData?.mainGroup?.[0].result?.at(0) == undefined)
                ? 0
                : amountIn === BigInt(0)
                  ? 1
                  : amountIn <= tokenBalances[tokenIn]
                    ? allowance < amountIn && tokenIn != eth && !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake)
                      ? 6
                      : 2
                    : 3
              : connected
                ? 4
                : 5,
          );
          setwarning(
            !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) &&
              ((amountIn == BigInt(0) && amountOutSwap != BigInt(0)) ||
                ((orderType == 1 || multihop) &&
                  rpcQueryData?.readContractData?.mainGroup?.[0].result?.at(0) == undefined))
              ? multihop
                ? 3
                : 2
              : parseFloat(temppriceimpact.slice(0, -1)) > 5 &&
                !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) &&
                (orderType != 0 || (slippage < BigInt(9500))) &&
                !isLoading &&
                !stateIsLoading
                ? 1
                : 0,
          );
          return temppriceimpact == 'NaN%' ? '0%' : temppriceimpact;
        });
        setTradeFee(
          `${(Number(amountIn) * (100000 - Number(activeMarket.fee))) /
            100000 /
            10 ** Number(tokendict[tokenIn].decimals) >
            0.0001
            ? customRound(
              (Number(amountIn) * (100000 - Number(activeMarket.fee))) /
              100000 /
              10 ** Number(tokendict[tokenIn].decimals),
              2,
            )
            : (Number(amountIn) * (100000 - Number(activeMarket.fee))) /
              100000 /
              10 ** Number(tokendict[tokenIn].decimals) ==
              0
              ? '0'
              : '<0.0001'
          } ${tokendict[tokenIn].ticker}`,
        );
      }
      setLimitButtonDisabled(
        (amountIn === BigInt(0) ||
          limitPrice == BigInt(0) ||
          (tokenIn == activeMarket.quoteAddress
            ? amountIn < activeMarket.minSize
            : (amountIn * limitPrice) / activeMarket.scaleFactor <
            activeMarket.minSize) ||
          amountIn > tokenBalances[tokenIn] ||
          (addliquidityonly &&
            ((limitPrice >= lowestAsk &&
              tokenIn == activeMarket.quoteAddress) ||
              (limitPrice <= highestBid &&
                tokenIn == activeMarket.baseAddress)))) &&
        connected &&
        userchain == activechain,
      );
      setLimitButton(
        connected && userchain == activechain
          ? amountIn === BigInt(0)
            ? 0
            : limitPrice == BigInt(0)
              ? 1
              : amountIn <= tokenBalances[tokenIn]
                ? addliquidityonly &&
                  ((limitPrice >= lowestAsk &&
                    tokenIn == activeMarket.quoteAddress) ||
                    (limitPrice <= highestBid &&
                      tokenIn == activeMarket.baseAddress))
                  ? tokenIn == activeMarket.quoteAddress
                    ? 2
                    : 3
                  : (
                    tokenIn == activeMarket.quoteAddress
                      ? amountIn < activeMarket.minSize
                      : (amountIn * limitPrice) /
                      activeMarket.scaleFactor <
                      activeMarket.minSize
                  )
                    ? 4
                    : allowance < amountIn && tokenIn != eth
                      ? 9
                      : 5
                : 6
          : connected
            ? 7
            : 8,
      );
      setSendButtonDisabled(
        (amountIn === BigInt(0) ||
          amountIn > tokenBalances[tokenIn] ||
          !/^(0x[0-9a-fA-F]{40})$/.test(recipient)) &&
        connected &&
        userchain == activechain,
      );
      setSendButton(
        connected && userchain == activechain
          ? amountIn === BigInt(0)
            ? 0
            : !/^(0x[0-9a-fA-F]{40})$/.test(recipient)
              ? 1
              : amountIn <= tokenBalances[tokenIn]
                ? 2
                : 3
          : connected
            ? 4
            : 5,
      );
      setSendPopupButtonDisabled(
        (sendAmountIn === BigInt(0) ||
          sendAmountIn > tokenBalances[sendTokenIn] ||
          !/^(0x[0-9a-fA-F]{40})$/.test(recipient)) &&
        connected &&
        userchain == activechain,
      );
      setSendPopupButton(
        connected && userchain == activechain
          ? sendAmountIn === BigInt(0)
            ? 0
            : !/^(0x[0-9a-fA-F]{40})$/.test(recipient)
              ? 1
              : sendAmountIn <= tokenBalances[sendTokenIn]
                ? 2
                : 3
          : connected
            ? 4
            : 5,
      );
      setScaleButtonDisabled(
        (amountIn === BigInt(0) ||
          scaleStart == BigInt(0) || scaleEnd == BigInt(0) || scaleOrders == BigInt(0) || scaleOrders == BigInt(1) || scaleSkew == 0 ||
          calculateScaleOutput(
            amountIn,
            Number(scaleStart),
            Number(scaleEnd),
            Number(scaleOrders || 2),
            Number(scaleSkew)
          ).some((order) => order[2] < activeMarket.minSize) ||
          amountIn > tokenBalances[tokenIn] ||
          (
            ((scaleStart >= lowestAsk &&
              tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
              (scaleStart <= highestBid &&
                tokenIn == activeMarket.baseAddress && (addliquidityonly)) || (scaleEnd >= lowestAsk &&
                  tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
              (scaleEnd <= highestBid &&
                tokenIn == activeMarket.baseAddress && (addliquidityonly))))) &&
        connected &&
        userchain == activechain,
      );
      setScaleButton(
        connected && userchain == activechain
          ? amountIn === BigInt(0)
            ? 0
            : scaleStart == BigInt(0)
              ? 1 : scaleEnd == BigInt(0) ? 2
                : amountIn <= tokenBalances[tokenIn]
                  ? ((scaleStart >= lowestAsk &&
                    tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
                    (scaleStart <= highestBid &&
                      tokenIn == activeMarket.baseAddress && (addliquidityonly)))
                    ? tokenIn == activeMarket.quoteAddress
                      ? 3
                      : 4 : ((scaleEnd >= lowestAsk &&
                        tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
                        (scaleEnd <= highestBid &&
                          tokenIn == activeMarket.baseAddress && (addliquidityonly)))
                      ? tokenIn == activeMarket.quoteAddress
                        ? 5
                        : 6
                      : (
                        calculateScaleOutput(
                          amountIn,
                          Number(scaleStart),
                          Number(scaleEnd),
                          Number(scaleOrders || 2),
                          Number(scaleSkew)
                        ).some((order) => order[2] < activeMarket.minSize)
                      ) ? 7 : scaleOrders <= BigInt(1) ? 8 : scaleSkew == 0 ? 9
                        : allowance < amountIn && tokenIn != eth
                          ? 13
                          : 14
                  : 10
          : connected
            ? 11
            : 12,
      );
    } else if (stateIsLoading && !isWrap) {
      setDisplayValuesLoading(true);
    }
  }, [
    isLoading,
    stateIsLoading,
    amountIn,
    amountOutSwap,
    tokenIn,
    tokenOut,
    activechain,
    isWrap,
    addliquidityonly,
    limitPrice,
    highestBid,
    lowestAsk,
    activeMarket.quoteAddress,
    activeMarket.baseAddress,
    orderType,
    slippage,
    connected,
    userchain,
    tokenBalances[tokenIn],
    multihop,
    recipient,
    mids,
    scaleStart,
    scaleEnd,
    scaleOrders,
    scaleSkew,
  ]);

  // trades processing
  useEffect(() => {
    const temp: Trade[] | undefined = tradesByMarket[activeMarketKey];

    let processed: [boolean, string, string, string, string][] = [];

    if (temp) {
      processed = temp.slice(0, 100).map((trade: Trade) => {
        const isBuy = trade[2] === 1;
        const tradeValue = (trade[2] === 1 ? trade[1] : trade[0]) / 10 ** Number(activeMarket.baseDecimals);
        const price = trade[3] / Number(activeMarket.priceFactor) || 0;
        const time = formatTime(trade[6]);
        const hash = trade[5];
        return [
          isBuy,
          formatSubscript(formatSig(
            price.toFixed(Math.floor(Math.log10(Number(activeMarket.priceFactor)))), activeMarket.marketType != 0
          )),
          formatSubscript(customRound(tradeValue, 3)),
          time,
          hash,
        ];
      });
    }

    setTrades(processed);
  }, [tradesByMarket?.[activeMarketKey]?.[0]])

  // fetch initial address info and event stream
  useEffect(() => {
    let liveStreamCancelled = false;
    let isAddressInfoFetching = false;
    let startBlockNumber = '';
    let endBlockNumber = '';

    const fetchData = async () => {
      try {
        const req = await fetch(HTTP_URL, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify([{
            jsonrpc: '2.0',
            id: 0,
            method: 'eth_blockNumber',
          }, {
            jsonrpc: '2.0',
            id: 0,
            method: 'eth_getLogs',
            params: [
              {
                fromBlock: startBlockNumber,
                toBlock: endBlockNumber,
                address: router,
                topics: [
                  '0x9adcf0ad0cda63c4d50f26a48925cf6405df27d422a39c456b5f03f661c82982',
                ],
              },
            ],
          }, ...(address?.slice(2) ? [{
            jsonrpc: '2.0',
            id: 0,
            method: 'eth_getLogs',
            params: [
              {
                fromBlock: startBlockNumber,
                toBlock: endBlockNumber,
                address: router,
                topics: [
                  '0x7ebb55d14fb18179d0ee498ab0f21c070fad7368e44487d51cdac53d6f74812c',
                  null,
                  '0x000000000000000000000000' + address?.slice(2),
                ],
              },
            ],
          }] : [])]),
        });
        const result = await req.json();
        if (liveStreamCancelled) return;
        startBlockNumber = '0x' + (parseInt(result[0].result, 16) - 30).toString(16);
        endBlockNumber = '0x' + (parseInt(result[0].result, 16) + 10).toString(16);
        const tradelogs = result[1].result;
        const orderlogs = result?.[2]?.result;
        const filllogs = result?.[3]?.result;
        let ordersChanged = false;
        let canceledOrdersChanged = false;
        let tradesByMarketChanged = false;
        let tradeHistoryChanged = false;
        let temporders: any;
        let tempcanceledorders: any;
        let temptradesByMarket: any;
        let temptradehistory: any;
        setorders((orders) => {
          temporders = [...orders];
          return orders;
        })
        setcanceledorders((canceledorders) => {
          tempcanceledorders = [...canceledorders];
          return canceledorders;
        })
        settradesByMarket((tradesByMarket: any) => {
          temptradesByMarket = { ...tradesByMarket };
          return tradesByMarket;
        })
        settradehistory((tradehistory: any) => {
          temptradehistory = [...tradehistory];
          return tradehistory;
        })
        setProcessedLogs(prev => {
          let tempset = new Set(prev);
          let temptrades: any = {};
          if (Array.isArray(tradelogs)) {
            for (const log of tradelogs) {
              const logIdentifier = `${log['transactionHash']}-${log['logIndex']}`;
              const marketKey = addresstoMarket['0x' + log['topics'][1].slice(26)];
              if (!tempset.has(logIdentifier) && marketKey && !temptradesByMarket[marketKey]?.some((trade: any) =>
                trade[0] == parseInt(log['data'].slice(66, 130), 16) &&
                trade[1] == parseInt(log['data'].slice(130, 194), 16) &&
                trade[5] == log['transactionHash'])) {
                if (tempset.size >= 10000) {
                  const first = tempset.values().next().value;
                  if (first !== undefined) {
                    tempset.delete(first);
                  }
                }
                tempset.add(logIdentifier);
                const resolve = txReceiptResolvers.current.get(log['transactionHash']);
                if (resolve) {
                  resolve();
                  txReceiptResolvers.current.delete(log['transactionHash']);
                }
                let _timestamp = parseInt(log['blockTimestamp'], 16);
                let _orderdata = log['data'].slice(258);
                for (let i = 0; i < _orderdata.length; i += 64) {
                  let chunk = _orderdata.slice(i, i + 64);
                  let price = parseInt(chunk.slice(1, 20), 16);
                  let id = parseInt(chunk.slice(20, 32), 16);
                  let size = parseInt(chunk.slice(32, 64), 16);
                  let orderIndex = temporders.findIndex(
                    (sublist: any) =>
                      sublist[0] ==
                      price &&
                      sublist[1] ==
                      id &&
                      sublist[4] == marketKey,
                  );
                  let canceledOrderIndex = tempcanceledorders.findIndex(
                    (sublist: any) =>
                      sublist[0] ==
                      price &&
                      sublist[1] ==
                      id &&
                      sublist[4] == marketKey,
                  );
                  if (orderIndex != -1 && canceledOrderIndex != -1) {
                    ordersChanged = true;
                    canceledOrdersChanged = true;
                    temporders[orderIndex] = [...temporders[orderIndex]]
                    tempcanceledorders[canceledOrderIndex] = [...tempcanceledorders[canceledOrderIndex]]
                    let order = [...temporders[orderIndex]];
                    let buy = order[3];
                    let quoteasset =
                      markets[marketKey]
                        .quoteAddress;
                    let baseasset =
                      markets[marketKey]
                        .baseAddress;
                    let amountquote = (
                      ((order[2] - order[7] - size / order[0]) *
                        order[0]) /
                      (Number(
                        markets[marketKey]
                          .scaleFactor,
                      ) *
                        10 **
                        Number(
                          markets[marketKey]
                            .quoteDecimals,
                        ))
                    ).toFixed(2);
                    let amountbase = customRound(
                      (order[2] - order[7] - size / order[0]) /
                      10 **
                      Number(
                        markets[marketKey]
                          .baseDecimals,
                      ),
                      3,
                    );
                    newTxPopup(
                      log['transactionHash'],
                      'fill',
                      buy ? quoteasset : baseasset,
                      buy ? baseasset : quoteasset,
                      buy ? amountquote : amountbase,
                      buy ? amountbase : amountquote,
                      `${order[0] / Number(markets[marketKey].priceFactor)} ${markets[marketKey].quoteAsset}`,
                      '',
                    );
                    if (size == 0) {
                      tradeHistoryChanged = true;
                      temptradehistory.push([
                        order[3] == 1
                          ? (order[2] * order[0]) /
                          Number(markets[order[4]].scaleFactor)
                          : order[2],
                        order[3] == 1
                          ? order[2]
                          : (order[2] * order[0]) /
                          Number(markets[order[4]].scaleFactor),
                        order[3],
                        order[0],
                        order[4],
                        order[5],
                        _timestamp,
                        0,
                      ]);
                      if (temporders[orderIndex]?.[10] && typeof temporders[orderIndex][10].remove === 'function') {
                        try {
                          temporders[orderIndex][10].remove();
                        }
                        catch { }
                        temporders[orderIndex].splice(10, 1)
                      }
                      temporders.splice(orderIndex, 1);
                      tempcanceledorders[canceledOrderIndex][9] =
                        1;
                      tempcanceledorders[canceledOrderIndex][7] = order[2]
                      tempcanceledorders[canceledOrderIndex][8] = order[8];
                    } else {
                      if (temporders[orderIndex]?.[10] && typeof temporders[orderIndex][10].setQuantity === 'function') {
                        try {
                          temporders[orderIndex][10].setQuantity(formatDisplay(customRound((size / order[0]) / 10 ** Number(markets[order[4]].baseDecimals), 3)))
                        }
                        catch { }
                      }
                      temporders[orderIndex][7] =
                        order[2] - size / order[0];
                      tempcanceledorders[canceledOrderIndex][7] =
                        order[2] - size / order[0];
                    }
                  }
                }
                tradesByMarketChanged = true;
                if (!Array.isArray(temptradesByMarket[marketKey])) {
                  temptradesByMarket[marketKey] = [];
                }
                let amountIn = parseInt(log['data'].slice(66, 130), 16);
                let amountOut = parseInt(log['data'].slice(130, 194), 16);
                let buy = parseInt(log['data'].slice(65, 66), 16);
                let price = parseInt(log['data'].slice(258, 322), 16);
                temptradesByMarket[marketKey].unshift([
                  amountIn,
                  amountOut,
                  buy,
                  price,
                  marketKey,
                  log['transactionHash'],
                  _timestamp,
                ]);
                if (!Array.isArray(temptrades[marketKey])) {
                  temptrades[marketKey] = [];
                }
                temptrades[marketKey].unshift([
                  amountIn,
                  amountOut,
                  buy,
                  price,
                  marketKey,
                  log['transactionHash'],
                  _timestamp,
                  parseInt(log['data'].slice(194, 258), 16),
                ])
                if (
                  log['topics'][2].slice(26) ==
                  address?.slice(2).toLowerCase()
                ) {
                  tradeHistoryChanged = true;
                  temptradehistory.push([
                    amountIn,
                    amountOut,
                    buy,
                    price,
                    marketKey,
                    log['transactionHash'],
                    _timestamp,
                    1,
                  ])
                  let quoteasset =
                    markets[marketKey].quoteAddress;
                  let baseasset =
                    markets[marketKey].baseAddress;
                  let popupAmountIn = customRound(
                    amountIn /
                    10 **
                    Number(
                      buy
                        ? markets[marketKey]
                          .quoteDecimals
                        : markets[marketKey]
                          .baseDecimals,
                    ),
                    3,
                  );
                  let popupAmountOut = customRound(
                    amountOut /
                    10 **
                    Number(
                      buy
                        ? markets[marketKey]
                          .baseDecimals
                        : markets[marketKey]
                          .quoteDecimals,
                    ),
                    3,
                  );
                  newTxPopup(
                    log['transactionHash'],
                    'swap',
                    buy ? quoteasset : baseasset,
                    buy ? baseasset : quoteasset,
                    popupAmountIn,
                    popupAmountOut,
                    '',
                    '',
                  );
                }
              }
            }
            if (tradesByMarketChanged) {
              setChartData(([existingBars, existingIntervalLabel, existingShowOutliers]) => {
                const marketKey = existingIntervalLabel?.match(/^\D*/)?.[0];
                const updatedBars = [...existingBars];
                let rawVolume;
                if (marketKey && Array.isArray(temptrades?.[marketKey])) {
                  const barSizeSec =
                    existingIntervalLabel?.match(/\d.*/)?.[0] === '1' ? 60 :
                      existingIntervalLabel?.match(/\d.*/)?.[0] === '5' ? 5 * 60 :
                        existingIntervalLabel?.match(/\d.*/)?.[0] === '15' ? 15 * 60 :
                          existingIntervalLabel?.match(/\d.*/)?.[0] === '30' ? 30 * 60 :
                            existingIntervalLabel?.match(/\d.*/)?.[0] === '60' ? 60 * 60 :
                              existingIntervalLabel?.match(/\d.*/)?.[0] === '240' ? 4 * 60 * 60 :
                                existingIntervalLabel?.match(/\d.*/)?.[0] === '1D' ? 24 * 60 * 60 :
                                  5 * 60;
                  const priceFactor = Number(markets[marketKey].priceFactor);
                  for (const lastTrade of temptrades[marketKey]) {
                    const lastBarIndex = updatedBars.length - 1;
                    const lastBar = updatedBars[lastBarIndex];

                    let openPrice = parseFloat((lastTrade[7] / priceFactor).toFixed(Math.floor(Math.log10(priceFactor))));
                    let closePrice = parseFloat((lastTrade[3] / priceFactor).toFixed(Math.floor(Math.log10(priceFactor))));
                    rawVolume =
                      (lastTrade[2] == 0 ? lastTrade[0] : lastTrade[1]) /
                      10 ** Number(markets[marketKey].baseDecimals);

                    const tradeTimeSec = lastTrade[6];
                    const flooredTradeTimeSec = Math.floor(tradeTimeSec / barSizeSec) * barSizeSec;
                    const lastBarTimeSec = Math.floor(new Date(lastBar?.time).getTime() / 1000);
                    if (flooredTradeTimeSec === lastBarTimeSec) {
                      updatedBars[lastBarIndex] = {
                        ...lastBar,
                        high: Math.max(lastBar.high, Math.max(openPrice, closePrice)),
                        low: Math.min(lastBar.low, Math.min(openPrice, closePrice)),
                        close: closePrice,
                        volume: lastBar.volume + rawVolume,
                      };
                      if (realtimeCallbackRef.current[existingIntervalLabel]) {
                        realtimeCallbackRef.current[existingIntervalLabel]({
                          ...lastBar,
                          high: Math.max(lastBar.high, Math.max(openPrice, closePrice)),
                          low: Math.min(lastBar.low, Math.min(openPrice, closePrice)),
                          close: closePrice,
                          volume: lastBar.volume + rawVolume,
                        });
                      }
                    } else {
                      updatedBars.push({
                        time: flooredTradeTimeSec * 1000,
                        open: lastBar?.close ?? openPrice,
                        high: Math.max(lastBar?.close ?? openPrice, closePrice),
                        low: Math.min(lastBar?.close ?? openPrice, closePrice),
                        close: closePrice,
                        volume: rawVolume,
                      });
                      if (realtimeCallbackRef.current[existingIntervalLabel]) {
                        realtimeCallbackRef.current[existingIntervalLabel]({
                          time: flooredTradeTimeSec * 1000,
                          open: lastBar?.close ?? openPrice,
                          high: Math.max(lastBar?.close ?? openPrice, closePrice),
                          low: Math.min(lastBar?.close ?? openPrice, closePrice),
                          close: closePrice,
                          volume: rawVolume,
                        });
                      }
                    }
                  }
                }
                setMarketsData((marketsData) =>
                  marketsData.map((market) => {
                    if (!market) return;
                    const marketKey = market?.marketKey.replace(
                      new RegExp(`^${wethticker}|${wethticker}$`, 'g'),
                      ethticker
                    );
                    const newTrades = temptrades?.[marketKey]
                    if (!Array.isArray(newTrades) || newTrades.length < 1) return market;
                    const firstKlineOpen: number =
                      market?.mini && Array.isArray(market?.mini) && market?.mini.length > 0
                        ? Number(market?.mini[0].value * Number(market.priceFactor))
                        : 0;
                    const currentPriceRaw = Number(newTrades[newTrades.length - 1][3]);
                    const percentageChange = firstKlineOpen === 0 ? 0 : ((currentPriceRaw - firstKlineOpen) / firstKlineOpen) * 100;
                    const quotePrice = market.quoteAsset == 'USDC' ? 1 : temptradesByMarket[(market.quoteAsset == settings.chainConfig[activechain].wethticker ? settings.chainConfig[activechain].ethticker : market.quoteAsset) + 'USDC']?.[0]?.[3]
                      / Number(markets[(market.quoteAsset == settings.chainConfig[activechain].wethticker ? settings.chainConfig[activechain].ethticker : market.quoteAsset) + 'USDC']?.priceFactor)
                    let high = market.high24h ? Number(market.high24h.replace(/,/g, '')) : null;
                    let low = market.low24h ? Number(market.low24h.replace(/,/g, '')) : null;
                    const volume = newTrades.reduce((sum: number, trade: any) => {
                      if (high && trade[3] / Number(market.priceFactor) > high) {
                        high = trade[3] / Number(market.priceFactor)
                      }
                      if (low && trade[3] / Number(market.priceFactor) < low) {
                        low = trade[3] / Number(market.priceFactor)
                      }
                      const amount = Number(trade[2] === 1 ? trade[0] : trade[1]);
                      return sum + amount;
                    }, 0) / 10 ** Number(market?.quoteDecimals) * quotePrice;

                    return {
                      ...market,
                      volume: formatCommas(
                        (parseFloat(market.volume.replace(/,/g, '')) + volume).toFixed(2)
                      ),
                      currentPrice: formatSig(
                        (currentPriceRaw / Number(market.priceFactor)).toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
                      ),
                      priceChange: `${percentageChange >= 0 ? '+' : ''}${percentageChange.toFixed(2)}`,
                      priceChangeAmount: formatSig(((currentPriceRaw - firstKlineOpen) / Number(market.priceFactor)).toFixed(formatSig(
                        (currentPriceRaw / Number(market.priceFactor)).toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
                      ).split('.')[1]?.length || 0)),
                      ...(high != null && {
                        high24h: formatSig(
                          high.toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
                        )
                      }),
                      ...(low != null && {
                        low24h: formatSig(
                          low.toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
                        )
                      })
                    };
                  })
                );
                return [updatedBars, existingIntervalLabel, existingShowOutliers];
              });
            }
          }
          if (Array.isArray(orderlogs)) {
            for (const log of orderlogs) {
              const logIdentifier = `${log['transactionHash']}-${log['logIndex']}`;
              const marketKey = addresstoMarket['0x' + log['topics'][1].slice(26)];
              if (!tempset.has(logIdentifier) && marketKey && log['topics'][2].slice(26) ==
                address?.slice(2).toLowerCase()) {
                if (tempset.size >= 10000) {
                  const first = tempset.values().next().value;
                  if (first !== undefined) {
                    tempset.delete(first);
                  }
                }
                tempset.add(logIdentifier);
                const resolve = txReceiptResolvers.current.get(log['transactionHash']);
                if (resolve) {
                  resolve();
                  txReceiptResolvers.current.delete(log['transactionHash']);
                }
                let _timestamp = parseInt(log['blockTimestamp'], 16);
                let _orderdata = log['data'].slice(130);
                for (let i = 0; i < _orderdata.length; i += 64) {
                  let chunk = _orderdata.slice(i, i + 64);
                  let _isplace = parseInt(chunk.slice(0, 1), 16) >= 2;
                  if (_isplace) {
                    let buy = 3 - parseInt(chunk.slice(0, 1), 16);
                    let price = parseInt(chunk.slice(2, 22), 16);
                    let id = parseInt(chunk.slice(22, 36), 16);
                    let size = parseInt(chunk.slice(36, 64), 16);
                    let alreadyExist = tempcanceledorders.some(
                      (o: any) => o[0] == price && o[1] == id && o[4] == marketKey
                    );
                    buy ? size *= Number(markets[marketKey].scaleFactor) : size *= price
                    if (!alreadyExist) {
                      ordersChanged = true;
                      canceledOrdersChanged = true;
                      let order = [
                        price,
                        id,
                        size /
                        price,
                        buy,
                        marketKey,
                        log['transactionHash'],
                        _timestamp,
                        0,
                        size,
                        2,
                      ];
                      temporders.push(order)
                      tempcanceledorders.push([
                        price,
                        id,
                        size /
                        price,
                        buy,
                        marketKey,
                        log['transactionHash'],
                        _timestamp,
                        0,
                        size,
                        2,
                      ])
                      let quoteasset =
                        markets[marketKey].quoteAddress;
                      let baseasset =
                        markets[marketKey].baseAddress;
                      let amountquote = (
                        size /
                        (Number(
                          markets[marketKey].scaleFactor,
                        ) *
                          10 **
                          Number(
                            markets[marketKey]
                              .quoteDecimals,
                          ))
                      ).toFixed(2);
                      let amountbase = customRound(
                        size /
                        price /
                        10 **
                        Number(
                          markets[marketKey]
                            .baseDecimals,
                        ),
                        3,
                      );
                      newTxPopup(
                        log['transactionHash'],
                        'limit',
                        buy ? quoteasset : baseasset,
                        buy ? baseasset : quoteasset,
                        buy ? amountquote : amountbase,
                        buy ? amountbase : amountquote,
                        `${price / Number(markets[marketKey].priceFactor)} ${markets[marketKey].quoteAsset}`,
                        '',
                      );
                    }
                  } else {
                    let buy = parseInt(chunk.slice(0, 1), 16) == 0;
                    let price = parseInt(chunk.slice(2, 22), 16);
                    let id = parseInt(chunk.slice(22, 36), 16);
                    let size = parseInt(chunk.slice(36, 64), 16);
                    let index = temporders.findIndex(
                      (o: any) =>
                        o[0] == price &&
                        o[1] == id &&
                        o[4] == marketKey,
                    );
                    if (index != -1) {
                      ordersChanged = true;
                      canceledOrdersChanged = true;
                      let canceledOrderIndex: number;
                      canceledOrderIndex = tempcanceledorders.findIndex(
                        (canceledOrder: any) =>
                          canceledOrder[0] ==
                          price &&
                          canceledOrder[1] ==
                          id &&
                          canceledOrder[4] ==
                          marketKey,
                      );
                      if (canceledOrderIndex !== -1 && tempcanceledorders[canceledOrderIndex][9] != 0) {
                        tempcanceledorders[canceledOrderIndex] = [...tempcanceledorders[canceledOrderIndex]]
                        tempcanceledorders[canceledOrderIndex][9] = 0;
                        tempcanceledorders[canceledOrderIndex][8] =
                          tempcanceledorders[canceledOrderIndex][8] -
                          size;
                        tempcanceledorders[canceledOrderIndex][6] =
                          _timestamp;
                      }
                      if (temporders[index]?.[10] && typeof temporders[index][10].remove === 'function') {
                        temporders[index] = [...temporders[index]]
                        try {
                          temporders[index][10].remove();
                        }
                        catch { }
                        temporders[index].splice(10, 1)
                      }
                      temporders.splice(index, 1);
                      let quoteasset =
                        markets[marketKey].quoteAddress;
                      let baseasset =
                        markets[marketKey].baseAddress;
                      let amountquote = (
                        (buy ? size : size * price / Number(
                          markets[marketKey].scaleFactor
                        )) /
                        (10 **
                          Number(
                            markets[marketKey]
                              .quoteDecimals,
                          ))
                      ).toFixed(2);
                      let amountbase = customRound(
                        (buy ? size * Number(
                          markets[marketKey].scaleFactor
                        ) / price : size) /
                        10 **
                        Number(
                          markets[marketKey]
                            .baseDecimals,
                        ),
                        3,
                      );
                      newTxPopup(
                        log['transactionHash'],
                        'cancel',
                        buy ? quoteasset : baseasset,
                        buy ? baseasset : quoteasset,
                        buy ? amountquote : amountbase,
                        buy ? amountbase : amountquote,
                        `${price / Number(markets[marketKey].priceFactor)} ${markets[marketKey].quoteAsset}`,
                        '',
                      );
                    }
                  }
                }
              }
            }
          }
          if (Array.isArray(filllogs)) {
            for (const log of filllogs) {
              const logIdentifier = `${log['transactionHash']}-${log['logIndex']}`;
              const marketKey = addresstoMarket['0x' + log['topics'][1].slice(26)];
              if (!tempset.has(logIdentifier) && marketKey && log['topics'][2].slice(26) ==
                address?.slice(2).toLowerCase()) {
                if (tempset.size >= 10000) {
                  const first = tempset.values().next().value;
                  if (first !== undefined) {
                    tempset.delete(first);
                  }
                }
                tempset.add(logIdentifier);
                let _timestamp = Math.floor(Date.now() / 1000);
                let _orderdata = log['data'].slice(2);
                let buy = 1 - parseInt(_orderdata.slice(0, 1), 16);
                let price = parseInt(_orderdata.slice(1, 22), 16);
                let id = parseInt(_orderdata.slice(22, 36), 16);
                let size = parseInt(_orderdata.slice(36, 64), 16);
                buy ? size *= price : size *= Number(markets[marketKey].scaleFactor)
                let orderIndex = temporders.findIndex(
                  (sublist: any) =>
                    sublist[0] ==
                    price &&
                    sublist[1] ==
                    id &&
                    sublist[4] == marketKey,
                );
                let canceledOrderIndex = tempcanceledorders.findIndex(
                  (sublist: any) =>
                    sublist[0] ==
                    price &&
                    sublist[1] ==
                    id &&
                    sublist[4] == marketKey,
                );
                if (orderIndex != -1 && canceledOrderIndex != -1) {
                  ordersChanged = true;
                  temporders[orderIndex] = [...temporders[orderIndex]]
                  let order = [...temporders[orderIndex]];
                  let buy = order[3];
                  let quoteasset =
                    markets[marketKey]
                      .quoteAddress;
                  let baseasset =
                    markets[marketKey]
                      .baseAddress;
                  let amountquote = (
                    ((order[2] - order[7] - size / order[0]) *
                      order[0]) /
                    (Number(
                      markets[marketKey]
                        .scaleFactor,
                    ) *
                      10 **
                      Number(
                        markets[marketKey]
                          .quoteDecimals,
                      ))
                  ).toFixed(2);
                  let amountbase = customRound(
                    (order[2] - order[7] - size / order[0]) /
                    10 **
                    Number(
                      markets[marketKey]
                        .baseDecimals,
                    ),
                    3,
                  );
                  newTxPopup(
                    log['transactionHash'],
                    'fill',
                    buy ? quoteasset : baseasset,
                    buy ? baseasset : quoteasset,
                    buy ? amountquote : amountbase,
                    buy ? amountbase : amountquote,
                    `${order[0] / Number(markets[marketKey].priceFactor)} ${markets[marketKey].quoteAsset}`,
                    '',
                  );
                  if (size == 0) {
                    tradeHistoryChanged = true;
                    temptradehistory.push([
                      order[3] == 1
                        ? (order[2] * order[0]) /
                        Number(markets[order[4]].scaleFactor)
                        : order[2],
                      order[3] == 1
                        ? order[2]
                        : (order[2] * order[0]) /
                        Number(markets[order[4]].scaleFactor),
                      order[3],
                      order[0],
                      order[4],
                      order[5],
                      _timestamp,
                      0,
                    ]);
                    if (temporders[orderIndex]?.[10] && typeof temporders[orderIndex][10].remove === 'function') {
                      try {
                        temporders[orderIndex][10].remove();
                      }
                      catch { }
                      temporders[orderIndex].splice(10, 1)
                    }
                    temporders.splice(orderIndex, 1);
                    tempcanceledorders[canceledOrderIndex][9] =
                      1;
                    tempcanceledorders[canceledOrderIndex][7] = order[2]
                    tempcanceledorders[canceledOrderIndex][8] = order[8];
                  } else {
                    if (temporders[orderIndex]?.[10] && typeof temporders[orderIndex][10].setQuantity === 'function') {
                      try {
                        temporders[orderIndex][10].setQuantity(formatDisplay(customRound((size / order[0]) / 10 ** Number(markets[order[4]].baseDecimals), 3)))
                      }
                      catch { }
                    }
                    temporders[orderIndex][7] =
                      order[2] - size / order[0];
                  }
                  if (canceledOrderIndex != -1) {
                    canceledOrdersChanged = true;
                    tempcanceledorders[canceledOrderIndex] = [...tempcanceledorders[canceledOrderIndex]]
                    if (size == 0) {
                      tempcanceledorders[canceledOrderIndex][9] =
                        1;
                      tempcanceledorders[canceledOrderIndex][7] = order[2]
                      tempcanceledorders[canceledOrderIndex][8] = order[8];
                    }
                    else {
                      tempcanceledorders[canceledOrderIndex][7] =
                        order[2] - size / order[0];
                    }
                  }
                }
              }
            }
          }
          if (tradeHistoryChanged) {
            settradehistory(temptradehistory)
          }
          if (tradesByMarketChanged) {
            settradesByMarket(temptradesByMarket)
          }
          if (canceledOrdersChanged) {
            setcanceledorders(tempcanceledorders)
          }
          if (ordersChanged) {
            setorders(temporders)
          }
          return tempset;
        })
      } catch {
      }
    };

    (async () => {
      if (address) {
        setTransactions([]);
        settradehistory([]);
        setorders([]);
        setcanceledorders([]);
        setrecipient('');
        isAddressInfoFetching = true;
        try {
          ;
          const query = `
            query {
              account(id: "${address}") {
                id
                userIds {
                  id
                }
                openOrderMap {
                  shards(first: 1000) { batches(first: 1000) { orders(first: 1000) {
                    id
                    market { id baseAsset quoteAsset }
                    isBuy
                    price
                    originalSize
                    remainingSize
                    status
                    placedAt
                    updatedAt
                    txHash
                  }}}
                }
                orderMap {
                  shards(first: 1000) { batches(first: 1000) { orders(first: 1000) {
                    id
                    market { id baseAsset quoteAsset }
                    isBuy
                    price
                    originalSize
                    remainingSize
                    status
                    placedAt
                    updatedAt
                    txHash
                  }}}
                }
                tradeMap {
                  shards(first: 1000) { batches(first: 1000) { trades(first: 1000) {
                    id
                    market { id baseAsset quoteAsset }
                    amountIn
                    amountOut
                    startPrice
                    endPrice
                    isBuy
                    timestamp
                    tx
                  }}}
                }
              }
            }
          `;

          const response = await fetch(SUBGRAPH_URL, {
            method: "POST",
            headers: { "content-type": "application/json" },
            body: JSON.stringify({ query }),
          });
          if (!response.ok) throw new Error(`http ${response.status} ${response.statusText}`);

          const result = await response.json();
          if (result?.errors?.length) throw new Error(result.errors[0]?.message || "graphql error");

          if (!isAddressInfoFetching) return;

          const flatten = (map: any, key: "orders" | "trades") =>
            (map?.shards ?? [])
              .flatMap((s: any) => s?.batches ?? [])
              .flatMap((b: any) => b?.[key] ?? []);

          const statusCode = (s: any) => {
            if (typeof s === "number") return s;
            const m: Record<string, number> = { open: 0, filled: 1, cancelled: 2, canceled: 2, expired: 3 };
            return m[(s ?? "").toString().toLowerCase()] ?? -1;
          };

          const getMarketKey = (m: any) => {
            if (m?.id && addresstoMarket?.[m.id]) return addresstoMarket[m.id];
            return ''
          };

          const acct = result?.data?.account;
          let temptradehistory: any[] = [];
          let temporders: any[] = [];
          let tempcanceledorders: any[] = [];

          if (acct) {
            const trades = flatten(acct.tradeMap, "trades") || [];
            for (const t of trades) {
              const marketKey = getMarketKey(t.market);
              if (marketKey) {
                temptradehistory.push([
                  Number(t.amountIn ?? 0),
                  Number(t.amountOut ?? 0),
                  t.isBuy ? 1 : 0,
                  Number((t.endPrice ?? t.startPrice) ?? 0),
                  marketKey,
                  t.tx,
                  Number(t.timestamp ?? 0),
                  1,
                ]);
              }
            }

            const openOrders = flatten(acct.openOrderMap, "orders") || [];
            for (const o of openOrders) {
              const marketKey = getMarketKey(o.market);
              if (marketKey) {
                const idParts = (o.id ?? "").split(":");
                const price = Number(o.price);
                const tail = parseInt(idParts[idParts.length - 1] ?? "0", 10) || 0;
                const original = Number(o.originalSize ?? 0);
                const remaining = Number(o.remainingSize ?? 0);
                const filled = Math.max(0, original - remaining);

                temporders.push([
                  price,
                  tail,
                  o.isBuy ? original * Number(markets[marketKey].scaleFactor) / price : original,
                  o.isBuy ? 1 : 0,
                  marketKey,
                  o.txHash,
                  Number(o.placedAt ?? o.updatedAt ?? 0),
                  o.isBuy ? filled * Number(markets[marketKey].scaleFactor) / price : filled,
                  o.isBuy ? original * Number(markets[marketKey].scaleFactor) : Number(o.price ?? 0) * original,
                  statusCode(o.status),
                ]);
              }
            }

            const allOrders = flatten(acct.orderMap, "orders") || [];
            for (const o of allOrders) {
              const marketKey = getMarketKey(o.market);
              if (marketKey) {
                const idParts = (o.id ?? "").split(":");
                const price = Number(o.price);
                const tail = parseInt(idParts[idParts.length - 1] ?? "0", 10) || 0;
                const original = Number(o.originalSize ?? 0);
                const remaining = Number(o.remainingSize ?? 0);
                const filled = Math.max(0, original - remaining);

                tempcanceledorders.push([
                  price,
                  tail,
                  o.isBuy ? original * Number(markets[marketKey].scaleFactor) / price : original,
                  o.isBuy ? 1 : 0,
                  marketKey,
                  o.txHash,
                  Number(o.updatedAt ?? o.placedAt ?? 0),
                  o.isBuy ? filled * Number(markets[marketKey].scaleFactor) / price : filled,
                  o.isBuy ? original * Number(markets[marketKey].scaleFactor) : Number(o.price ?? 0) * original,
                  statusCode(o.status),
                ]);
              }
            }
          }

          settradehistory(temptradehistory);
          setorders(temporders);
          setcanceledorders(tempcanceledorders);
          setaddressinfoloading(false);
          isAddressInfoFetching = false;
        } catch (error) {
          console.error("Error fetching logs:", error);
          setaddressinfoloading(false);
          isAddressInfoFetching = false;
        }
      }
      else if (!user) {
        setSliderPercent(0)
        const slider = document.querySelector('.balance-amount-slider');
        const popup = document.querySelector('.slider-percentage-popup');
        if (slider && popup) {
          (popup as HTMLElement).style.left = `${15 / 2}px`;
        }
        setTransactions([]);
        settradehistory([]);
        setorders([]);
        setcanceledorders([]);
        setaddressinfoloading(false);
      }
    })();

    const connectWebSocket = () => {
      if (liveStreamCancelled) return;
      wsRef.current = new WebSocket(WS_URL);

      wsRef.current.onopen = async () => {
        const subscriptionMessages = [
          JSON.stringify({
            jsonrpc: '2.0',
            id: 'sub1',
            method: 'eth_subscribe',
            params: [
              'monadLogs',
              {
                address: router,
                topics: [
                  '0x9adcf0ad0cda63c4d50f26a48925cf6405df27d422a39c456b5f03f661c82982',
                ],
              },
            ],
          }), ...(address?.slice(2) ? [JSON.stringify({
            jsonrpc: '2.0',
            id: 'sub2',
            method: 'eth_subscribe',
            params: [
              'monadLogs',
              {
                address: router,
                topics: [
                  ['0xa195980963150be5fcca4acd6a80bf5a9de7f9c862258501b7c705e7d2c2d2f4', '0x7ebb55d14fb18179d0ee498ab0f21c070fad7368e44487d51cdac53d6f74812c'],
                  null,
                  '0x000000000000000000000000' + address?.slice(2),
                ],
              },
            ],
          })] : [])
        ];

        pingIntervalRef.current = setInterval(() => {
          if (wsRef.current?.readyState === WebSocket.OPEN) {
            wsRef.current.send(JSON.stringify({
              jsonrpc: '2.0',
              id: 'ping',
              method: 'eth_syncing'
            }));
          }
        }, 15000);

        subscriptionMessages.forEach((message) => {
          wsRef.current?.send(message);
        });

        if (blockNumber.current) {
          startBlockNumber = '0x' + (blockNumber.current - BigInt(80)).toString(16)
          endBlockNumber = '0x' + (blockNumber.current + BigInt(10)).toString(16)
        } else {
          let firstBlockNumber = await getBlockNumber(config);
          startBlockNumber = '0x' + (firstBlockNumber - BigInt(80)).toString(16)
          endBlockNumber = '0x' + (firstBlockNumber + BigInt(10)).toString(16)
        }
        fetchData();
      };

      wsRef.current.onmessage = (event) => {
        const message = JSON.parse(event.data);
        if (message?.params?.result && message?.params?.result?.commitState == "Proposed") {
          const log = message?.params?.result;
          let ordersChanged = false;
          let canceledOrdersChanged = false;
          let tradesByMarketChanged = false;
          let tradeHistoryChanged = false;
          let temporders: any;
          let tempcanceledorders: any;
          let temptradesByMarket: any;
          let temptradehistory: any;
          setorders((orders) => {
            temporders = [...orders];
            return orders;
          })
          setcanceledorders((canceledorders) => {
            tempcanceledorders = [...canceledorders];
            return canceledorders;
          })
          settradesByMarket((tradesByMarket: any) => {
            temptradesByMarket = { ...tradesByMarket };
            return tradesByMarket;
          })
          settradehistory((tradehistory: any) => {
            temptradehistory = [...tradehistory];
            return tradehistory;
          })
          setProcessedLogs(prev => {
            let tempset = new Set(prev);
            let temptrades: any = {};
            if (log['topics']?.[0] == '0x9adcf0ad0cda63c4d50f26a48925cf6405df27d422a39c456b5f03f661c82982') {
              const logIdentifier = `${log['transactionHash']}-${log['logIndex']}`;
              const marketKey = addresstoMarket['0x' + log['topics'][1].slice(26)];
              if (!tempset.has(logIdentifier) && marketKey && !temptradesByMarket[marketKey]?.some((trade: any) =>
                trade[0] == parseInt(log['data'].slice(66, 130), 16) &&
                trade[1] == parseInt(log['data'].slice(130, 194), 16) &&
                trade[5] == log['transactionHash'])) {
                if (tempset.size >= 10000) {
                  const first = tempset.values().next().value;
                  if (first !== undefined) {
                    tempset.delete(first);
                  }
                }
                tempset.add(logIdentifier);
                const resolve = txReceiptResolvers.current.get(log['transactionHash']);
                if (resolve) {
                  resolve();
                  txReceiptResolvers.current.delete(log['transactionHash']);
                }
                let _timestamp = Math.floor(Date.now() / 1000);
                tradesByMarketChanged = true;
                if (!Array.isArray(temptradesByMarket[marketKey])) {
                  temptradesByMarket[marketKey] = [];
                }
                let amountIn = parseInt(log['data'].slice(66, 130), 16);
                let amountOut = parseInt(log['data'].slice(130, 194), 16);
                let buy = parseInt(log['data'].slice(65, 66), 16);
                let price = parseInt(log['data'].slice(258, 322), 16);
                temptradesByMarket[marketKey].unshift([
                  amountIn,
                  amountOut,
                  buy,
                  price,
                  marketKey,
                  log['transactionHash'],
                  _timestamp,
                ]);
                if (!Array.isArray(temptrades[marketKey])) {
                  temptrades[marketKey] = [];
                }
                temptrades[marketKey].unshift([
                  amountIn,
                  amountOut,
                  buy,
                  price,
                  marketKey,
                  log['transactionHash'],
                  _timestamp,
                  parseInt(log['data'].slice(194, 258), 16),
                ])
                if (
                  log['topics'][2].slice(26) ==
                  address?.slice(2).toLowerCase()
                ) {
                  tradeHistoryChanged = true;
                  temptradehistory.push([
                    amountIn,
                    amountOut,
                    buy,
                    price,
                    marketKey,
                    log['transactionHash'],
                    _timestamp,
                    1,
                  ])
                  let quoteasset =
                    markets[marketKey].quoteAddress;
                  let baseasset =
                    markets[marketKey].baseAddress;
                  let popupAmountIn = customRound(
                    amountIn /
                    10 **
                    Number(
                      buy
                        ? markets[marketKey]
                          .quoteDecimals
                        : markets[marketKey]
                          .baseDecimals,
                    ),
                    3,
                  );
                  let popupAmountOut = customRound(
                    amountOut /
                    10 **
                    Number(
                      buy
                        ? markets[marketKey]
                          .baseDecimals
                        : markets[marketKey]
                          .quoteDecimals,
                    ),
                    3,
                  );
                  newTxPopup(
                    log['transactionHash'],
                    'swap',
                    buy ? quoteasset : baseasset,
                    buy ? baseasset : quoteasset,
                    popupAmountIn,
                    popupAmountOut,
                    '',
                    '',
                  );
                }
              }
              if (tradesByMarketChanged) {
                setChartData(([existingBars, existingIntervalLabel, existingShowOutliers]) => {
                  const marketKey = existingIntervalLabel?.match(/^\D*/)?.[0];
                  const updatedBars = [...existingBars];
                  let rawVolume;
                  if (marketKey && Array.isArray(temptrades?.[marketKey])) {
                    const barSizeSec =
                      existingIntervalLabel?.match(/\d.*/)?.[0] === '1' ? 60 :
                        existingIntervalLabel?.match(/\d.*/)?.[0] === '5' ? 5 * 60 :
                          existingIntervalLabel?.match(/\d.*/)?.[0] === '15' ? 15 * 60 :
                            existingIntervalLabel?.match(/\d.*/)?.[0] === '30' ? 30 * 60 :
                              existingIntervalLabel?.match(/\d.*/)?.[0] === '60' ? 60 * 60 :
                                existingIntervalLabel?.match(/\d.*/)?.[0] === '240' ? 4 * 60 * 60 :
                                  existingIntervalLabel?.match(/\d.*/)?.[0] === '1D' ? 24 * 60 * 60 :
                                    5 * 60;
                    const priceFactor = Number(markets[marketKey].priceFactor);
                    for (const lastTrade of temptrades[marketKey]) {
                      const lastBarIndex = updatedBars.length - 1;
                      const lastBar = updatedBars[lastBarIndex];

                      let openPrice = parseFloat((lastTrade[7] / priceFactor).toFixed(Math.floor(Math.log10(priceFactor))));
                      let closePrice = parseFloat((lastTrade[3] / priceFactor).toFixed(Math.floor(Math.log10(priceFactor))));
                      rawVolume =
                        (lastTrade[2] == 0 ? lastTrade[0] : lastTrade[1]) /
                        10 ** Number(markets[marketKey].baseDecimals);

                      const tradeTimeSec = lastTrade[6];
                      const flooredTradeTimeSec = Math.floor(tradeTimeSec / barSizeSec) * barSizeSec;
                      const lastBarTimeSec = Math.floor(new Date(lastBar?.time).getTime() / 1000);
                      if (flooredTradeTimeSec === lastBarTimeSec) {
                        updatedBars[lastBarIndex] = {
                          ...lastBar,
                          high: Math.max(lastBar.high, Math.max(openPrice, closePrice)),
                          low: Math.min(lastBar.low, Math.min(openPrice, closePrice)),
                          close: closePrice,
                          volume: lastBar.volume + rawVolume,
                        };
                        if (realtimeCallbackRef.current[existingIntervalLabel]) {
                          realtimeCallbackRef.current[existingIntervalLabel]({
                            ...lastBar,
                            high: Math.max(lastBar.high, Math.max(openPrice, closePrice)),
                            low: Math.min(lastBar.low, Math.min(openPrice, closePrice)),
                            close: closePrice,
                            volume: lastBar.volume + rawVolume,
                          });
                        }
                      } else {
                        updatedBars.push({
                          time: flooredTradeTimeSec * 1000,
                          open: lastBar?.close ?? openPrice,
                          high: Math.max(lastBar?.close ?? openPrice, closePrice),
                          low: Math.min(lastBar?.close ?? openPrice, closePrice),
                          close: closePrice,
                          volume: rawVolume,
                        });
                        if (realtimeCallbackRef.current[existingIntervalLabel]) {
                          realtimeCallbackRef.current[existingIntervalLabel]({
                            time: flooredTradeTimeSec * 1000,
                            open: lastBar?.close ?? openPrice,
                            high: Math.max(lastBar?.close ?? openPrice, closePrice),
                            low: Math.min(lastBar?.close ?? openPrice, closePrice),
                            close: closePrice,
                            volume: rawVolume,
                          });
                        }
                      }
                    }
                  }
                  setMarketsData((marketsData) =>
                    marketsData.map((market) => {
                      if (!market) return;
                      const marketKey = market?.marketKey.replace(
                        new RegExp(`^${wethticker}|${wethticker}$`, 'g'),
                        ethticker
                      );
                      const newTrades = temptrades?.[marketKey]
                      if (!Array.isArray(newTrades) || newTrades.length < 1) return market;
                      const firstKlineOpen: number =
                        market?.mini && Array.isArray(market?.mini) && market?.mini.length > 0
                          ? Number(market?.mini[0].value * Number(market.priceFactor))
                          : 0;
                      const currentPriceRaw = Number(newTrades[newTrades.length - 1][3]);
                      const percentageChange = firstKlineOpen === 0 ? 0 : ((currentPriceRaw - firstKlineOpen) / firstKlineOpen) * 100;
                      const quotePrice = market.quoteAsset == 'USDC' ? 1 : temptradesByMarket[(market.quoteAsset == settings.chainConfig[activechain].wethticker ? settings.chainConfig[activechain].ethticker : market.quoteAsset) + 'USDC']?.[0]?.[3]
                        / Number(markets[(market.quoteAsset == settings.chainConfig[activechain].wethticker ? settings.chainConfig[activechain].ethticker : market.quoteAsset) + 'USDC']?.priceFactor)
                      let high = market.high24h ? Number(market.high24h.replace(/,/g, '')) : null;
                      let low = market.low24h ? Number(market.low24h.replace(/,/g, '')) : null;
                      const volume = newTrades.reduce((sum: number, trade: any) => {
                        if (high && trade[3] / Number(market.priceFactor) > high) {
                          high = trade[3] / Number(market.priceFactor)
                        }
                        if (low && trade[3] / Number(market.priceFactor) < low) {
                          low = trade[3] / Number(market.priceFactor)
                        }
                        const amount = Number(trade[2] === 1 ? trade[0] : trade[1]);
                        return sum + amount;
                      }, 0) / 10 ** Number(market?.quoteDecimals) * quotePrice;

                      return {
                        ...market,
                        volume: formatCommas(
                          (parseFloat(market.volume.replace(/,/g, '')) + volume).toFixed(2)
                        ),
                        currentPrice: formatSig(
                          (currentPriceRaw / Number(market.priceFactor)).toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
                        ),
                        priceChange: `${percentageChange >= 0 ? '+' : ''}${percentageChange.toFixed(2)}`,
                        priceChangeAmount: formatSig(((currentPriceRaw - firstKlineOpen) / Number(market.priceFactor)).toFixed(formatSig(
                          (currentPriceRaw / Number(market.priceFactor)).toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
                        ).split('.')[1]?.length || 0)),
                        ...(high != null && {
                          high24h: formatSig(
                            high.toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
                          )
                        }),
                        ...(low != null && {
                          low24h: formatSig(
                            low.toFixed(Math.floor(Math.log10(Number(market.priceFactor)))), market.marketType != 0
                          )
                        })
                      };
                    })
                  );
                  return [updatedBars, existingIntervalLabel, existingShowOutliers];
                });
              }
            }
            else if (log['topics']?.[0] == '0x7ebb55d14fb18179d0ee498ab0f21c070fad7368e44487d51cdac53d6f74812c') {
              const logIdentifier = `${log['transactionHash']}-${log['logIndex']}`;
              const marketKey = addresstoMarket['0x' + log['topics'][1].slice(26)];
              if (!tempset.has(logIdentifier) && marketKey && log['topics'][2].slice(26) ==
                address?.slice(2).toLowerCase()) {
                if (tempset.size >= 10000) {
                  const first = tempset.values().next().value;
                  if (first !== undefined) {
                    tempset.delete(first);
                  }
                }
                tempset.add(logIdentifier);
                const resolve = txReceiptResolvers.current.get(log['transactionHash']);
                if (resolve) {
                  resolve();
                  txReceiptResolvers.current.delete(log['transactionHash']);
                }
                let _timestamp = Math.floor(Date.now() / 1000);
                let _orderdata = log['data'].slice(130);
                for (let i = 0; i < _orderdata.length; i += 64) {
                  let chunk = _orderdata.slice(i, i + 64);
                  let _isplace = parseInt(chunk.slice(0, 1), 16) >= 2;
                  if (_isplace) {
                    let buy = 3 - parseInt(chunk.slice(0, 1), 16);
                    let price = parseInt(chunk.slice(2, 22), 16);
                    let id = parseInt(chunk.slice(22, 36), 16);
                    let size = parseInt(chunk.slice(36, 64), 16);
                    let alreadyExist = tempcanceledorders.some(
                      (o: any) => o[0] == price && o[1] == id && o[4] == marketKey
                    );
                    buy ? size *= Number(markets[marketKey].scaleFactor) : size *= price
                    if (!alreadyExist) {
                      ordersChanged = true;
                      canceledOrdersChanged = true;
                      let order = [
                        price,
                        id,
                        size /
                        price,
                        buy,
                        marketKey,
                        log['transactionHash'],
                        _timestamp,
                        0,
                        size,
                        2,
                      ];
                      temporders.push(order)
                      tempcanceledorders.push([
                        price,
                        id,
                        size /
                        price,
                        buy,
                        marketKey,
                        log['transactionHash'],
                        _timestamp,
                        0,
                        size,
                        2,
                      ])
                      let quoteasset =
                        markets[marketKey].quoteAddress;
                      let baseasset =
                        markets[marketKey].baseAddress;
                      let amountquote = (
                        size /
                        (Number(
                          markets[marketKey].scaleFactor,
                        ) *
                          10 **
                          Number(
                            markets[marketKey]
                              .quoteDecimals,
                          ))
                      ).toFixed(2);
                      let amountbase = customRound(
                        size /
                        price /
                        10 **
                        Number(
                          markets[marketKey]
                            .baseDecimals,
                        ),
                        3,
                      );
                      newTxPopup(
                        log['transactionHash'],
                        'limit',
                        buy ? quoteasset : baseasset,
                        buy ? baseasset : quoteasset,
                        buy ? amountquote : amountbase,
                        buy ? amountbase : amountquote,
                        `${price / Number(markets[marketKey].priceFactor)} ${markets[marketKey].quoteAsset}`,
                        '',
                      );
                    }
                  } else {
                    let buy = parseInt(chunk.slice(0, 1), 16) == 0;
                    let price = parseInt(chunk.slice(2, 22), 16);
                    let id = parseInt(chunk.slice(22, 36), 16);
                    let size = parseInt(chunk.slice(36, 64), 16);
                    let index = temporders.findIndex(
                      (o: any) =>
                        o[0] == price &&
                        o[1] == id &&
                        o[4] == marketKey,
                    );
                    if (index != -1) {
                      ordersChanged = true;
                      canceledOrdersChanged = true;
                      let canceledOrderIndex: number;
                      canceledOrderIndex = tempcanceledorders.findIndex(
                        (canceledOrder: any) =>
                          canceledOrder[0] ==
                          price &&
                          canceledOrder[1] ==
                          id &&
                          canceledOrder[4] ==
                          marketKey,
                      );
                      if (canceledOrderIndex !== -1 && tempcanceledorders[canceledOrderIndex][9] != 0) {
                        tempcanceledorders[canceledOrderIndex] = [...tempcanceledorders[canceledOrderIndex]]
                        tempcanceledorders[canceledOrderIndex][9] = 0;
                        tempcanceledorders[canceledOrderIndex][8] =
                          tempcanceledorders[canceledOrderIndex][8] -
                          size;
                        tempcanceledorders[canceledOrderIndex][6] =
                          _timestamp;
                      }
                      if (temporders[index]?.[10] && typeof temporders[index][10].remove === 'function') {
                        temporders[index] = [...temporders[index]]
                        try {
                          temporders[index][10].remove();
                        }
                        catch { }
                        temporders[index].splice(10, 1)
                      }
                      temporders.splice(index, 1);
                      let quoteasset =
                        markets[marketKey].quoteAddress;
                      let baseasset =
                        markets[marketKey].baseAddress;
                      let amountquote = (
                        (buy ? size : size * price / Number(
                          markets[marketKey].scaleFactor
                        )) /
                        (10 **
                          Number(
                            markets[marketKey]
                              .quoteDecimals,
                          ))
                      ).toFixed(2);
                      let amountbase = customRound(
                        (buy ? size * Number(
                          markets[marketKey].scaleFactor
                        ) / price : size) /
                        10 **
                        Number(
                          markets[marketKey]
                            .baseDecimals,
                        ),
                        3,
                      );
                      newTxPopup(
                        log['transactionHash'],
                        'cancel',
                        buy ? quoteasset : baseasset,
                        buy ? baseasset : quoteasset,
                        buy ? amountquote : amountbase,
                        buy ? amountbase : amountquote,
                        `${price / Number(markets[marketKey].priceFactor)} ${markets[marketKey].quoteAsset}`,
                        '',
                      );
                    }
                  }
                }
              }
            }
            else {
              const logIdentifier = `${log['transactionHash']}-${log['logIndex']}`;
              const marketKey = addresstoMarket['0x' + log['topics'][1].slice(26)];
              if (!tempset.has(logIdentifier) && marketKey && log['topics'][2].slice(26) ==
                address?.slice(2).toLowerCase()) {
                if (tempset.size >= 10000) {
                  const first = tempset.values().next().value;
                  if (first !== undefined) {
                    tempset.delete(first);
                  }
                }
                tempset.add(logIdentifier);
                let _timestamp = Math.floor(Date.now() / 1000);
                let _orderdata = log['data'].slice(2);
                let buy = 1 - parseInt(_orderdata.slice(0, 1), 16);
                let price = parseInt(_orderdata.slice(1, 22), 16);
                let id = parseInt(_orderdata.slice(22, 36), 16);
                let size = parseInt(_orderdata.slice(36, 64), 16);
                buy ? size *= price : size *= Number(markets[marketKey].scaleFactor)
                let orderIndex = temporders.findIndex(
                  (sublist: any) =>
                    sublist[0] ==
                    price &&
                    sublist[1] ==
                    id &&
                    sublist[4] == marketKey,
                );
                let canceledOrderIndex = tempcanceledorders.findIndex(
                  (sublist: any) =>
                    sublist[0] ==
                    price &&
                    sublist[1] ==
                    id &&
                    sublist[4] == marketKey,
                );
                if (orderIndex != -1 && canceledOrderIndex != -1) {
                  ordersChanged = true;
                  temporders[orderIndex] = [...temporders[orderIndex]]
                  let order = [...temporders[orderIndex]];
                  let buy = order[3];
                  let quoteasset =
                    markets[marketKey]
                      .quoteAddress;
                  let baseasset =
                    markets[marketKey]
                      .baseAddress;
                  let amountquote = (
                    ((order[2] - order[7] - size / order[0]) *
                      order[0]) /
                    (Number(
                      markets[marketKey]
                        .scaleFactor,
                    ) *
                      10 **
                      Number(
                        markets[marketKey]
                          .quoteDecimals,
                      ))
                  ).toFixed(2);
                  let amountbase = customRound(
                    (order[2] - order[7] - size / order[0]) /
                    10 **
                    Number(
                      markets[marketKey]
                        .baseDecimals,
                    ),
                    3,
                  );
                  newTxPopup(
                    log['transactionHash'],
                    'fill',
                    buy ? quoteasset : baseasset,
                    buy ? baseasset : quoteasset,
                    buy ? amountquote : amountbase,
                    buy ? amountbase : amountquote,
                    `${order[0] / Number(markets[marketKey].priceFactor)} ${markets[marketKey].quoteAsset}`,
                    '',
                  );
                  if (size == 0) {
                    tradeHistoryChanged = true;
                    temptradehistory.push([
                      order[3] == 1
                        ? (order[2] * order[0]) /
                        Number(markets[order[4]].scaleFactor)
                        : order[2],
                      order[3] == 1
                        ? order[2]
                        : (order[2] * order[0]) /
                        Number(markets[order[4]].scaleFactor),
                      order[3],
                      order[0],
                      order[4],
                      order[5],
                      _timestamp,
                      0,
                    ]);
                    if (temporders[orderIndex]?.[10] && typeof temporders[orderIndex][10].remove === 'function') {
                      try {
                        temporders[orderIndex][10].remove();
                      }
                      catch { }
                      temporders[orderIndex].splice(10, 1)
                    }
                    temporders.splice(orderIndex, 1);
                    tempcanceledorders[canceledOrderIndex][9] =
                      1;
                    tempcanceledorders[canceledOrderIndex][7] = order[2]
                    tempcanceledorders[canceledOrderIndex][8] = order[8];
                  } else {
                    if (temporders[orderIndex]?.[10] && typeof temporders[orderIndex][10].setQuantity === 'function') {
                      try {
                        temporders[orderIndex][10].setQuantity(formatDisplay(customRound((size / order[0]) / 10 ** Number(markets[order[4]].baseDecimals), 3)))
                      }
                      catch { }
                    }
                    temporders[orderIndex][7] =
                      order[2] - size / order[0];
                  }
                  if (canceledOrderIndex != -1) {
                    canceledOrdersChanged = true;
                    tempcanceledorders[canceledOrderIndex] = [...tempcanceledorders[canceledOrderIndex]]
                    if (size == 0) {
                      tempcanceledorders[canceledOrderIndex][9] =
                        1;
                      tempcanceledorders[canceledOrderIndex][7] = order[2]
                      tempcanceledorders[canceledOrderIndex][8] = order[8];
                    }
                    else {
                      tempcanceledorders[canceledOrderIndex][7] =
                        order[2] - size / order[0];
                    }
                  }
                }
              }
            }
            if (tradeHistoryChanged) {
              settradehistory(temptradehistory)
            }
            if (tradesByMarketChanged) {
              settradesByMarket(temptradesByMarket)
            }
            if (canceledOrdersChanged) {
              setcanceledorders(tempcanceledorders)
            }
            if (ordersChanged) {
              setorders(temporders)
            }
            return tempset;
          })
        }
      }

      wsRef.current.onclose = () => {
        if (pingIntervalRef.current) {
          clearInterval(pingIntervalRef.current);
          pingIntervalRef.current = null;
        }
        reconnectIntervalRef.current = setTimeout(() => {
          connectWebSocket();
        }, 500);
      };

      wsRef.current.onerror = (error) => {
        console.error(error);
      };
    };

    connectWebSocket();

    return () => {
      liveStreamCancelled = true;
      isAddressInfoFetching = false;
      if (pingIntervalRef.current) {
        clearInterval(pingIntervalRef.current);
        pingIntervalRef.current = null;
      }
      if (wsRef.current) {
        wsRef.current.close();
        wsRef.current = null;
      }
      if (reconnectIntervalRef.current) {
        clearTimeout(reconnectIntervalRef.current);
        reconnectIntervalRef.current = null;
      }
    };
  }, [activechain, address]);

  // klines + trades
  useEffect(() => {
    (async () => {
      try {
        settradesloading(true);

        const query = `
          query {
            markets(first: 100, orderBy: volume, orderDirection: desc, where: {isCanonical:true}) {
              id
              baseAsset
              quoteAsset
              baseDecimals
              quoteDecimals
              baseTicker
              quoteTicker
              baseName
              quoteName
              marketType
              scaleFactor
              tickSize
              minSize
              maxPrice
              takerFee
              makerRebate
              volume
              latestPrice
              series(where:{intervalSeconds:3600}) {
                intervalSeconds
                klines(orderBy:time, orderDirection: desc) {
                  time
                  open
                  high
                  low
                  close
                  usdVolume
                }
              }
              trades(first: 100, orderBy: timestamp, orderDirection: desc) {
                id
                amountIn
                amountOut
                isBuy
                timestamp
                tx
                endPrice
              }
            }
          }
        `;
        const res = await fetch(SUBGRAPH_URL, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ query }),
        });
        const json = await res.json();
        const list = Array.isArray(json?.data?.markets) ? [...json.data.markets].reverse() : []

        const ETH_ADDR = settings.chainConfig[activechain].eth;
        const WETH_ADDR = settings.chainConfig[activechain].weth;
        const ETH_TICKER = settings.chainConfig[activechain].ethticker;
        const WETH_TICKER = settings.chainConfig[activechain].wethticker;
        const newMarkets: Record<string, any> = settings.chainConfig[activechain].markets;
        for (const m of list) {
          const baseAddr0 = getAddress(String(m.baseAsset || ''));
          const quoteAddr0 = getAddress(String(m.quoteAsset || ''));
          if (!tokendict[baseAddr0]) {
            tokendict[baseAddr0] = {
              address: baseAddr0,
              decimals: BigInt(Number(m.baseDecimals ?? 18)),
              image: '',
              name: m.baseName,
              ticker: m.baseTicker,
              website: '',
              autofetched: true,
            }
          }
          if (!tokendict[quoteAddr0]) {
            tokendict[quoteAddr0] = {
              address: quoteAddr0,
              decimals: BigInt(Number(m.quoteDecimals ?? 18)),
              image: '',
              name: m.quoteName,
              ticker: m.quoteTicker,
              website: '',
              autofetched: true,
            }
          }
          const scaleExp = Number(m.scaleFactor ?? 0);
          const scaleFactor = (BigInt(10) ** BigInt(scaleExp));
          const baseDec = Number(m.baseDecimals ?? 18);
          const quoteDec = Number(m.quoteDecimals ?? 18);
          const pfExp = Math.max(0, quoteDec + scaleExp - baseDec);
          const priceFactor = (BigInt(10) ** BigInt(pfExp));

          const common = {
            address: String(m.id ?? '').toLowerCase(),
            marketType: Number(m.marketType ?? 0),
            precision: 5,
            scaleFactor,
            priceFactor,
            tickSize: BigInt(m.tickSize ?? 1),
            minSize: BigInt(m.minSize ?? 0),
            maxPrice: BigInt(m.maxPrice ?? 0),
            fee: BigInt(m.takerFee ?? 100000),
            makerRebate: BigInt(m.makerRebate ?? 100000),
            baseDecimals: BigInt(baseDec),
            quoteDecimals: BigInt(quoteDec),
          };

          const baseIsEthish = baseAddr0 === ETH_ADDR || baseAddr0 === WETH_ADDR;
          const quoteIsEthish = quoteAddr0 === ETH_ADDR || quoteAddr0 === WETH_ADDR;

          const variants: Array<{ baseAddr: string; quoteAddr: string, baseAsset: string, quoteAsset: string }> = [];
          if (baseIsEthish) {
            variants.push({ baseAddr: ETH_ADDR, quoteAddr: quoteAddr0, baseAsset: ETH_TICKER, quoteAsset: m.quoteTicker });
            variants.push({ baseAddr: WETH_ADDR, quoteAddr: quoteAddr0, baseAsset: WETH_TICKER, quoteAsset: m.quoteTicker });
          } else if (quoteIsEthish) {
            variants.push({ baseAddr: baseAddr0, quoteAddr: ETH_ADDR, baseAsset: m.baseTicker, quoteAsset: ETH_TICKER });
            variants.push({ baseAddr: baseAddr0, quoteAddr: WETH_ADDR, baseAsset: m.baseTicker, quoteAsset: WETH_TICKER });
          } else {
            variants.push({ baseAddr: baseAddr0, quoteAddr: quoteAddr0, baseAsset: m.baseTicker, quoteAsset: m.quoteTicker });
          }

          for (const v of variants) {
            const bTok = tokendict[v.baseAddr];

            const marketKey = `${v.baseAsset}${v.quoteAsset}`;
            const image = (bTok?.image ?? settings.chainConfig[activechain].image ?? null);
            const website = (bTok?.website ?? '');
            newMarkets[marketKey] = {
              baseAsset: v.baseAsset,
              quoteAsset: v.quoteAsset,
              baseAddress: v.baseAddr,
              quoteAddress: v.quoteAddr,
              path: [v.quoteAddr, v.baseAddr],
              image,
              website,
              marketKey,
              ...common,
            };
          }
        }
        settings.chainConfig[activechain].markets = newMarkets;
        const newAddrToMarket: Record<string, string> = {};
        Object.values(newMarkets).reverse().forEach((m: any) => {
          if (m?.address) newAddrToMarket[String(m.address).toLowerCase()] = m.marketKey;
        });
        settings.chainConfig[activechain].addresstomarket = newAddrToMarket;

        const temptradesByMarket: Record<string, any[]> = {};
        Object.keys(newMarkets).forEach((k) => { temptradesByMarket[k] = []; });

        const addrToKey: Record<string, string> = {};
        Object.values(newMarkets).forEach((m: any) => {
          if (m?.address) addrToKey[String(m.address).toLowerCase()] = m.marketKey;
        });

        const rows: any[] = [];
        const buildMiniPointsDesc = (mkt: any): Array<any> => {
          const oneHourSeries = Array.isArray(mkt.series)
            ? mkt.series.find((s: any) => Number(s?.intervalSeconds) === 3600)
            : null;

          const klinesDesc = Array.isArray(oneHourSeries?.klines) ? oneHourSeries.klines : [];

          const nowSec = Math.floor(Date.now() / 1000);
          const endBucket = Math.floor(nowSec / 3600) * 3600;
          const startCutoff = endBucket - 24 * 3600;

          return klinesDesc
            .filter((k: any) => {
              const t = Number(k.time ?? 0);
              return t >= startCutoff && t <= endBucket;
            })
            .map((k: any) => ({
              time: Number(k.time ?? 0),
              open: Number(k.open ?? 0),
              close: Number(k.close ?? 0),
              high: Number(k.high ?? 0),
              low: Number(k.low ?? 0),
              usdVolume: String(k.usdVolume ?? "0"),
            }));
        };
        for (const m of list) {
          const mk = addrToKey[String(m.id ?? '').toLowerCase()];
          if (!mk) continue;

          const cfg = newMarkets[mk];
          if (!cfg) continue;
          const isWMON = cfg.baseAsset === WETH_TICKER || cfg.quoteAsset === WETH_TICKER;

          const pf = Number(cfg.priceFactor);
          const decs = Math.max(0, Math.floor(Math.log10(pf)));
          const lastRaw = Number(m.latestPrice ?? 0);
          const last = pf ? lastRaw / pf : 0;

          const miniDesc = buildMiniPointsDesc(m);
          const r = [...miniDesc].reverse()
          const miniAsc = r[0]
            ? [{ time: Number(r[0].time) * 1000, value: Number(r[0].open) / pf, high: Number(r[0].high) / pf, low: Number(r[0].low) / pf },
            ...r.map((p: any) => ({
              time: Number(p.time) * 1000,
              value: Number(p.close) / pf,
              high: Number(p.high) / pf,
              low: Number(p.low) / pf,
              open: Number(p.open) / pf
            }))]
            : []
          const open24 = miniAsc.length ? miniAsc[0].value : last;
          const highs = miniAsc.length ? miniAsc.map((p) => p.high) : [last];
          const lows = miniAsc.length ? miniAsc.map((p) => p.low) : [last];
          const high24 = Math.max(...highs);
          const low24 = Math.min(...lows);
          const pct = open24 === 0 ? 0 : ((last - open24) / open24) * 100;
          const deltaRaw = last - open24;

          const volQ = Number((m.volume ?? 0) / 10 ** Number(6));
          const volumeDisplay = formatCommas(volQ.toFixed(2));

          const trades = Array.isArray(m.trades) ? m.trades : [];
          if (trades.length) {
            for (const t of trades) {
              if (temptradesByMarket[mk]) {
                temptradesByMarket[mk].push([
                  Number(t.amountIn ?? 0),
                  Number(t.amountOut ?? 0),
                  t.isBuy ? 1 : 0,
                  t.endPrice,
                  mk,
                  t.tx,
                  Number(t.timestamp ?? 0),
                ]);
              }
            }
          }

          if (!isWMON) {
            rows.push({
              ...cfg,
              pair: `${cfg.baseAsset}/${cfg.quoteAsset}`,
              mini: miniAsc,
              currentPrice: formatSig(last.toFixed(decs), m.marketType != 0),
              high24h: formatSig(high24.toFixed(decs), m.marketType != 0),
              low24h: formatSig(low24.toFixed(decs), m.marketType != 0),
              volume: volumeDisplay,
              priceChange: `${pct >= 0 ? '+' : ''}${pct.toFixed(2)}`,
              priceChangeAmount: formatSig(deltaRaw.toFixed(formatSig(last.toFixed(decs), m.marketType != 0).split('.')[1]?.length || 0)),
            });
          }

          const ETH_ADDR_LC = ETH_ADDR;
          const WETH_ADDR_LC = WETH_ADDR;
          const bIsEthish = cfg.baseAddress === ETH_ADDR_LC || cfg.baseAddress === WETH_ADDR_LC;
          const qIsEthish = cfg.quoteAddress === ETH_ADDR_LC || cfg.quoteAddress === WETH_ADDR_LC;

          if (bIsEthish || qIsEthish) {
            const sibBaseTicker = bIsEthish
              ? (cfg.baseAsset === ETH_TICKER ? WETH_TICKER : ETH_TICKER)
              : cfg.baseAsset;
            const sibQuoteTicker = qIsEthish
              ? (cfg.quoteAsset === ETH_TICKER ? WETH_TICKER : ETH_TICKER)
              : cfg.quoteAsset;
            const siblingKey = `${sibBaseTicker}${sibQuoteTicker}`;
            const siblingCfg = newMarkets[siblingKey];

            if (siblingCfg) {
              const isSiblingWMON =
                siblingCfg.baseAsset === wethticker || siblingCfg.quoteAsset === wethticker;

              if (!isSiblingWMON) {
                const pf2 = Number(siblingCfg.priceFactor);
                const decs2 = Math.max(0, Math.floor(Math.log10(pf2)));
                const last2 = pf2 ? lastRaw / pf2 : 0;

                if (trades.length && temptradesByMarket[siblingKey]) {
                  for (const t of trades) {
                    temptradesByMarket[siblingKey].push([
                      Number(t.amountIn ?? 0),
                      Number(t.amountOut ?? 0),
                      t.isBuy ? 1 : 0,
                      t.endPrice,
                      siblingKey,
                      t.tx,
                      Number(t.timestamp ?? 0),
                    ]);
                  }
                }

                rows.push({
                  ...siblingCfg,
                  pair: `${siblingCfg.baseAsset}/${siblingCfg.quoteAsset}`,
                  mini: miniAsc,
                  currentPrice: formatSig(last2.toFixed(decs2), m.marketType != 0),
                  high24h: formatSig(high24.toFixed(decs2), m.marketType != 0),
                  low24h: formatSig(low24.toFixed(decs2), m.marketType != 0),
                  volume: volumeDisplay,
                  priceChange: `${pct >= 0 ? '+' : ''}${pct.toFixed(2)}`,
                  priceChangeAmount: formatSig(deltaRaw.toFixed(formatSig(last.toFixed(decs2), m.marketType != 0).split('.')[1]?.length || 0)),
                });
              }
            }
          }
        }

        settradesByMarket(temptradesByMarket);
        setMarketsData(rows);
        settradesloading(false);

        if (
          sendInputString === '' &&
          location.pathname.slice(1) === 'send' &&
          amountIn &&
          BigInt(amountIn) !== BigInt(0)
        ) {
          const mkObj = getMarket(activeMarket.path.at(0), activeMarket.path.at(1));
          const wethticker = settings.chainConfig[activechain].wethticker;
          const ethticker = settings.chainConfig[activechain].ethticker;
          const mkKey = (({ baseAsset, quoteAsset }: any) =>
            (baseAsset === wethticker ? ethticker : baseAsset) +
            (quoteAsset === wethticker ? ethticker : quoteAsset)
          )(mkObj);

          setsendInputString(
            `$${calculateUSDValue(
              BigInt(amountIn),
              temptradesByMarket[mkKey],
              tokenIn,
              mkObj
            ).toFixed(2)}`
          );
        }
      } catch (error) {
        console.error("Error fetching data:", error);
        settradesloading(false);
      }
    })();
  }, [activechain]);

  // mobile trade
  useEffect(() => {
    const handleEscapeKey = (event: KeyboardEvent) => {
      if (event.key === 'Escape' && popup != 11) {
        setpopup(0);
        setSendUsdValue('');
        setSendInputAmount('');
        setSendAmountIn(BigInt(0));
        settokenString('');
        window.dispatchEvent(new Event('high-impact-cancel'));
        setSelectedConnector(null);

        if (showTrade && !simpleView) {
          document.body.style.overflow = 'auto'
          document.querySelector('.right-column')?.classList.add('hide');
          document.querySelector('.right-column')?.classList.remove('show');
          document.querySelector('.trade-mobile-switch')?.classList.remove('open');
          setShowTrade(false);
        }
      }
    };
    const handleMouseDown = (e: MouseEvent) => {
      setpopup((popup) => {
        if (showTrade && popup == 0 && !simpleView) {
          const rectangleElement = document.querySelector('.rectangle');
          if (
            rectangleElement &&
            !rectangleElement.contains(e.target as Node)
          ) {
            document.body.style.overflow = 'auto'
            document.querySelector('.right-column')?.classList.add('hide');
            document.querySelector('.right-column')?.classList.remove('show');
            document.querySelector('.trade-mobile-switch')?.classList.remove('open');
            setShowTrade(false);
          }
        }

        if (!popupref.current?.contains(e.target as Node) && popup != 11) {
          setSendUsdValue('');
          setSendInputAmount('');
          setSendAmountIn(BigInt(0));
          settokenString('');
          window.dispatchEvent(new Event('high-impact-cancel'));
          return 0;
        }
        return popup;
      });
    };
    const handleResize = () => setWindowWidth(window.innerWidth);
    document.addEventListener('keydown', handleEscapeKey);
    document.addEventListener('mousedown', handleMouseDown);
    window.addEventListener('resize', handleResize);
    return () => {
      document.removeEventListener('keydown', handleEscapeKey);
      document.removeEventListener('mousedown', handleMouseDown);
      window.removeEventListener('resize', handleResize);
    };
  }, [showTrade]);

  // url
  useEffect(() => {
    const path = location.pathname.slice(1);
    if (['swap', 'limit', 'send', 'scale', 'market'].includes(path)) {
      setSearchParams({
        ...(path != 'send' ? { tokenIn } : { token: tokenIn }),
        ...(tokenOut && path != 'send' && { tokenOut }),
        ...(switched && (path == 'swap' || path == 'market')
          ? { amountOut: amountOutSwap }
          : { amountIn }),
      });
    }
  }, [tokenIn, tokenOut, location.pathname.slice(1), amountIn, amountOutSwap, switched]);

  // update active tab
  useLayoutEffect(() => {
    const path = location.pathname.slice(1);
    if (path === 'swap') {
      setSimpleView(true);
    } else if (path === 'market') {
      setSimpleView(false);
    }
    if (path === 'send' || path === 'scale') {
      setCurrentProText(path.toLowerCase());
    } else {
      setCurrentProText('pro');
    }
    if (['swap', 'limit', 'send', 'scale', 'market'].includes(path)) {
      if (amountIn == BigInt(0)) {
        setInputString('');
      }
      const slider = document.querySelector('.balance-amount-slider');
      const popup = document.querySelector('.slider-percentage-popup');
      if (slider && popup) {
        const rect = slider.getBoundingClientRect();
        (popup as HTMLElement).style.left =
          `${(rect.width - 15) * (sliderPercent / 100) + 15 / 2}px`;
      }
      if (path == 'send') {
        setsendInputString(
          amountIn != BigInt(0)
            ? `$${calculateUSDValue(
              amountIn,
              tradesByMarket[
              (({ baseAsset, quoteAsset }) =>
                (baseAsset === wethticker ? ethticker : baseAsset) +
                (quoteAsset === wethticker ? ethticker : quoteAsset)
              )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
              ],
              tokenIn,
              getMarket(activeMarket.path.at(0), activeMarket.path.at(1)),
            ).toFixed(2)}`
            : '',
        );
      } else if (path == 'limit') {
        if (multihop || isWrap) {
          let token;
          let pricefetchmarket;
          let found = false;
          for (const market in markets) {
            if (markets[market].baseAddress === tokenOut) {
              token = tokendict[markets[market].quoteAddress];
              pricefetchmarket = getMarket(
                markets[market].quoteAddress,
                tokenOut,
              );
              setTokenIn(markets[market].quoteAddress);
              found = true;
              break;
            }
          }
          if (!found) {
            for (const market in markets) {
              if (markets[market].quoteAddress === tokenOut) {
                token = tokendict[markets[market].baseAddress];
                pricefetchmarket = getMarket(
                  markets[market].baseAddress,
                  tokenOut,
                );
                setTokenIn(markets[market].baseAddress);
                break;
              }
            }
          }
          setswitched(true);
          setamountIn(
            limitPrice != BigInt(0) && amountOutSwap != BigInt(0)
              ? token.address === pricefetchmarket?.baseAddress
                ? (amountOutSwap *
                  (pricefetchmarket.scaleFactor || BigInt(1))) /
                limitPrice
                : (amountOutSwap * limitPrice) /
                (pricefetchmarket.scaleFactor || BigInt(1))
              : BigInt(0),
          );
          setInputString(
            (limitPrice != BigInt(0) && amountOutSwap != BigInt(0)
              ? token.address === pricefetchmarket?.baseAddress
                ? customRound(
                  Number(
                    (amountOutSwap *
                      (pricefetchmarket.scaleFactor || BigInt(1))) /
                    limitPrice,
                  ) /
                  10 ** Number(token.decimals),
                  3,
                )
                : customRound(
                  Number(
                    (amountOutSwap * limitPrice) /
                    (pricefetchmarket.scaleFactor || BigInt(1)),
                  ) /
                  10 ** Number(token.decimals),
                  3,
                )
              : ''
            ).toString(),
          );
          const percentage = !tokenBalances[token.address]
            ? 0
            : Math.min(
              100,
              Math.floor(
                Number(
                  ((limitPrice != BigInt(0) && amountOutSwap != BigInt(0)
                    ? token === pricefetchmarket?.baseAddress
                      ? (amountOutSwap *
                        (pricefetchmarket.scaleFactor || BigInt(1))) /
                      limitPrice
                      : (amountOutSwap * limitPrice) /
                      (pricefetchmarket.scaleFactor || BigInt(1))
                    : BigInt(0)) *
                    BigInt(100)) /
                  tokenBalances[token.address],
                ),
              ),
            );
          setSliderPercent(percentage);
          const slider = document.querySelector('.balance-amount-slider');
          const popup = document.querySelector('.slider-percentage-popup');
          if (slider && popup) {
            const rect = slider.getBoundingClientRect();
            (popup as HTMLElement).style.left =
              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
          }
        } else {
          if (switched) {
            setamountIn(
              limitPrice !== BigInt(0) && amountOutSwap !== BigInt(0)
                ? tokenIn === activeMarket?.baseAddress
                  ? (amountOutSwap *
                    (activeMarket.scaleFactor || BigInt(1))) /
                  limitPrice
                  : (amountOutSwap * limitPrice) /
                  (activeMarket.scaleFactor || BigInt(1))
                : BigInt(0),
            );
            setInputString(
              (limitPrice !== BigInt(0) && amountOutSwap !== BigInt(0)
                ? tokenIn === activeMarket?.baseAddress
                  ? customRound(
                    Number(
                      (amountOutSwap *
                        (activeMarket.scaleFactor || BigInt(1))) /
                      limitPrice,
                    ) /
                    10 ** Number(tokendict[tokenIn].decimals),
                    3,
                  )
                  : customRound(
                    Number(
                      (amountOutSwap * limitPrice) /
                      (activeMarket.scaleFactor || BigInt(1)),
                    ) /
                    10 ** Number(tokendict[tokenIn].decimals),
                    3,
                  )
                : ''
              ).toString(),
            );
            const percentage =
              tokenBalances[tokenIn] === BigInt(0)
                ? 0
                : Math.min(
                  100,
                  Math.floor(
                    Number(
                      (limitPrice !== BigInt(0) &&
                        amountOutSwap !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (amountOutSwap *
                            (activeMarket.scaleFactor ||
                              BigInt(1))) /
                          limitPrice
                          : (amountOutSwap * limitPrice) /
                          (activeMarket.scaleFactor || BigInt(1))
                        : BigInt(0)) * BigInt(100) / tokenBalances[tokenIn]
                    )
                  ),
                );
            setSliderPercent(percentage);
            const slider = document.querySelector(
              '.balance-amount-slider',
            );
            const popup = document.querySelector(
              '.slider-percentage-popup',
            );
            if (slider && popup) {
              const rect = slider.getBoundingClientRect();
              (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                }px`;
            }
          }
          else {
            setamountOutSwap(
              limitPrice != BigInt(0) && amountIn != BigInt(0)
                ? tokenIn === activeMarket?.baseAddress
                  ? (amountIn * limitPrice) /
                  (activeMarket.scaleFactor || BigInt(1))
                  : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                  limitPrice
                : BigInt(0),
            );
            setoutputString(
              (limitPrice != BigInt(0) && amountIn != BigInt(0)
                ? tokenIn === activeMarket?.baseAddress
                  ? customRound(
                    Number(
                      (amountIn * limitPrice) /
                      (activeMarket.scaleFactor || BigInt(1)),
                    ) /
                    10 ** Number(tokendict[tokenOut].decimals),
                    3,
                  )
                  : customRound(
                    Number(
                      (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                      limitPrice,
                    ) /
                    10 ** Number(tokendict[tokenOut].decimals),
                    3,
                  )
                : ''
              )
                .toString()
                .replace(/(\.\d*?[1-9])0+$/g, '$1')
                .replace(/\.0+$/, ''),
            );
          }
        }
      } else if (path == 'swap' || path == 'market') {
      } else if (path == 'scale') {
        if (multihop || isWrap) {
          let token;
          let found = false;
          for (const market in markets) {
            if (markets[market].baseAddress === tokenOut) {
              token = tokendict[markets[market].quoteAddress];
              setTokenIn(markets[market].quoteAddress);
              found = true;
              break;
            }
          }
          if (!found) {
            for (const market in markets) {
              if (markets[market].quoteAddress === tokenOut) {
                token = tokendict[markets[market].baseAddress];
                setTokenIn(markets[market].baseAddress);
                break;
              }
            }
          }
          setamountIn(
            BigInt(0)
          );
          setInputString('')
          setScaleStart(BigInt(0))
          setScaleEnd(BigInt(0))
          setScaleStartString('')
          setScaleEndString('')
          const percentage = !tokenBalances[token.address]
            ? 0
            : Math.min(
              100,
              Math.floor(
                Number(
                  (BigInt(0) *
                    BigInt(100)) /
                  tokenBalances[token.address],
                ),
              ),
            );
          setSliderPercent(percentage);
          const slider = document.querySelector('.balance-amount-slider');
          const popup = document.querySelector('.slider-percentage-popup');
          if (slider && popup) {
            const rect = slider.getBoundingClientRect();
            (popup as HTMLElement).style.left =
              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
          }
        }
        else {
          if (scaleStart && scaleEnd && scaleOrders && scaleSkew) {
            if (switched) {
              const requiredInput = calculateScaleInput(
                amountOutSwap,
                Number(scaleStart),
                Number(scaleEnd),
                Number(scaleOrders),
                Number(scaleSkew)
              );
              setamountIn(requiredInput);
              setInputString(
                customRound(
                  Number(requiredInput) / 10 ** Number(tokendict[tokenIn].decimals),
                  3
                ).toString()
              );
              const percentage =
                tokenBalances[tokenIn] === BigInt(0)
                  ? 0
                  : Math.min(
                    100,
                    Math.floor(
                      Number(
                        (requiredInput) * BigInt(100) / tokenBalances[tokenIn])
                    ),
                  );
              setSliderPercent(percentage);
              const slider = document.querySelector(
                '.balance-amount-slider',
              );
              const popup = document.querySelector(
                '.slider-percentage-popup',
              );
              if (slider && popup) {
                const rect = slider.getBoundingClientRect();
                (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                  }px`;
              }
            }
            else {
              setScaleOutput(Number(amountIn), Number(scaleStart), Number(scaleEnd), Number(scaleOrders), Number(scaleSkew))
            }
          }
          else {
            if (switched) {
              const requiredInput = calculateScaleInput(
                amountOutSwap,
                Number(scaleStart),
                Number(scaleEnd),
                Number(0),
                Number(scaleSkew)
              );
              setamountIn(requiredInput);
              setInputString('');
              const percentage =
                tokenBalances[tokenIn] === BigInt(0)
                  ? 0
                  : Math.min(
                    100,
                    Math.floor(
                      Number(
                        (requiredInput) * BigInt(100) / tokenBalances[tokenIn])
                    ),
                  );
              setSliderPercent(percentage);
              const slider = document.querySelector(
                '.balance-amount-slider',
              );
              const popup = document.querySelector(
                '.slider-percentage-popup',
              );
              if (slider && popup) {
                const rect = slider.getBoundingClientRect();
                (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                  }px`;
              }
            }
            else {
              setScaleOutput(Number(amountIn), Number(scaleStart), Number(scaleEnd), Number(0), Number(scaleSkew))
            }
          }
        }
      }
    }
  }, [location.pathname.slice(1)]);

  // limit chase
  useEffect(() => {
    if (limitChase && !isLimitEditing && mids?.[activeMarketKey]?.[0]) {
      const price = tokenIn === activeMarket?.baseAddress ? mids[activeMarketKey][0] == mids[activeMarketKey][1] ? mids[activeMarketKey][2] : mids[activeMarketKey][0] : mids[activeMarketKey][0] == mids[activeMarketKey][2] ? mids[activeMarketKey][1] : mids[activeMarketKey][0]
      if (price) {
        setlimitPrice(price);
        setlimitPriceString(
          (
            Number(price) / Number(activeMarket.priceFactor)
          ).toFixed(Math.floor(Math.log10(activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10((Number(price) / Number(activeMarket.priceFactor)) || 1)) - 1) : Number(activeMarket.priceFactor)))),
        );
        if (switched && location.pathname.slice(1) == 'limit' && !multihop && !isWrap) {
          setamountIn(
            price !== BigInt(0) && amountOutSwap !== BigInt(0)
              ? tokenIn === activeMarket?.baseAddress
                ? (amountOutSwap *
                  (activeMarket.scaleFactor || BigInt(1))) /
                price
                : (amountOutSwap * price) /
                (activeMarket.scaleFactor || BigInt(1))
              : BigInt(0),
          );
          setInputString(
            (price !== BigInt(0) && amountOutSwap !== BigInt(0)
              ? tokenIn === activeMarket?.baseAddress
                ? customRound(
                  Number(
                    (amountOutSwap *
                      (activeMarket.scaleFactor || BigInt(1))) /
                    price,
                  ) /
                  10 ** Number(tokendict[tokenIn].decimals),
                  3,
                )
                : customRound(
                  Number(
                    (amountOutSwap * price) /
                    (activeMarket.scaleFactor || BigInt(1)),
                  ) /
                  10 ** Number(tokendict[tokenIn].decimals),
                  3,
                )
              : ''
            ).toString(),
          );
          const percentage =
            tokenBalances[tokenIn] === BigInt(0)
              ? 0
              : Math.min(
                100,
                Math.floor(
                  Number(
                    (price !== BigInt(0) &&
                      amountOutSwap !== BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? (amountOutSwap *
                          (activeMarket.scaleFactor ||
                            BigInt(1))) /
                        price
                        : (amountOutSwap * price) /
                        (activeMarket.scaleFactor || BigInt(1))
                      : BigInt(0)) * BigInt(100) / tokenBalances[tokenIn]
                  )
                ),
              );
          setSliderPercent(percentage);
          const slider = document.querySelector(
            '.balance-amount-slider',
          );
          const popup = document.querySelector(
            '.slider-percentage-popup',
          );
          if (slider && popup) {
            const rect = slider.getBoundingClientRect();
            (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
              }px`;
          }
        }
        else if (location.pathname.slice(1) == 'limit' && !multihop && !isWrap) {
          setamountOutSwap(
            price != BigInt(0) && amountIn != BigInt(0)
              ? tokenIn === activeMarket?.baseAddress
                ? (amountIn * price) /
                (activeMarket.scaleFactor || BigInt(1))
                : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                price
              : BigInt(0),
          );
          setoutputString(
            (price != BigInt(0) && amountIn != BigInt(0)
              ? tokenIn === activeMarket?.baseAddress
                ? customRound(
                  Number(
                    (amountIn * price) /
                    (activeMarket.scaleFactor || BigInt(1)),
                  ) /
                  10 ** Number(tokendict[tokenOut].decimals),
                  3,
                )
                : customRound(
                  Number(
                    (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                    price,
                  ) /
                  10 ** Number(tokendict[tokenOut].decimals),
                  3,
                )
              : ''
            ).toString(),
          );
        }
      }
    }
  }, [limitChase, activechain, mids?.[activeMarketKey]?.[0], activeMarketKey, tokenIn, location.pathname.slice(1), isLimitEditing]);

  // tx popup time
  useEffect(() => {
    const interval = setInterval(() => {
      setTransactions((prevTransactions) => {
        const time = Date.now();
        const filteredTransactions = prevTransactions
          .filter((tx) => time - tx.timestamp < 9950)
          .map((tx) => ({
            ...tx,
            isNew: time - tx.timestamp < 300 ? true : false,
            isExiting: time - tx.timestamp > 9700 ? true : false,
          }));
        return filteredTransactions.length !== prevTransactions.length ||
          filteredTransactions.some(
            (tx, i) => tx.isNew !== prevTransactions[i]?.isNew,
          ) ||
          filteredTransactions.some(
            (tx, i) => tx.isExiting !== prevTransactions[i]?.isExiting,
          )
          ? filteredTransactions
          : prevTransactions;
      });
    }, 100);

    return () => clearInterval(interval);
  }, []);

  // popup
  useEffect(() => {
    if (user && !connected && !loading) {
      setpopup(11);
    }
    else if (connected && popup === 11) {
      setpopup(12);
    }
  }, [popup, connected, user != null, loading]);

  const isValidInput = (value: string) => {
    const regex = /^[a-zA-Z0-9-]{0,20}$/;
    return regex.test(value);
  };

  const handleWelcomeTransition = () => {
    audio.currentTime = 0;
    audio.play();

    setIsTransitioning(true);
    setIsWelcomeExiting(true);

    setTimeout(() => {
      setIsConnectEntering(true);
    }, 200);

    setTimeout(() => {
      setShowWelcomeScreen(false);
      setIsTransitioning(false);
      setIsWelcomeExiting(false);
    }, 200);
  };

  const handleSetRef = async (used: string) => {
    let lookup
    setIsRefSigning(true);
    if (used !== '') {
      lookup = (await readContracts(config, {
        contracts: [
          {
            abi: CrystalReferralAbi,
            address: settings.chainConfig[activechain].referralManager,
            functionName: 'refCodeToAddress',
            args: [used.toLowerCase()],
          },
        ],
      })) as any[];

      if (lookup[0].result === '0x0000000000000000000000000000000000000000') {
        setError(t('setRefFailed'));
        setIsRefSigning(false);
        return false;
      }
    }

    if (used === '') {
      try {
        await sendUserOperationAsync({
          uo: {
            target: settings.chainConfig[activechain].referralManager,
            data: encodeFunctionData({
              abi: CrystalReferralAbi,
              functionName: 'setUsedRef',
              args: [used],
            }),
            value: 0n,
          },
        });
        setUsedRefLink(used);
        setUsedRefAddress('0x0000000000000000000000000000000000000000')
        setIsRefSigning(false);
        return true;
      } catch {
        setIsRefSigning(false);
        return false;
      }
    } else {
      try {
        await sendUserOperationAsync({
          uo: {
            target: settings.chainConfig[activechain].referralManager,
            data: encodeFunctionData({
              abi: CrystalReferralAbi,
              functionName: 'setUsedRef',
              args: [used],
            }),
            value: 0n,
          },
        });
        setUsedRefLink(used);
        setUsedRefAddress(lookup?.[0].result)
        setIsRefSigning(false);
        return true;
      } catch (error) {
        setIsRefSigning(false);
        return false;
      }
    }
  };

  const handleNextClick = () => {
    audio.currentTime = 0;
    audio.play();
    handleCompleteChallenge();
  };

  const handleBackClick = () => {
    if (backAudioRef.current) {
      backAudioRef.current.currentTime = 0;
      backAudioRef.current.play().catch(console.error);
    }
    if (currentStep > 0) {
      setCurrentStep(prevStep => prevStep - 1);
    }
  };

  const handleCompleteChallenge = () => {
    if (currentStep < 2) { setCurrentStep(c => c + 1); return; }

    setExitingChallenge(true);
    setTimeout(() => {
      localStorage.setItem('crystal_has_completed_onboarding', 'true');
      setpopup(0);
      setCurrentStep(0)
      setExitingChallenge(false);
    }, 250);
  };

  const handleEditUsername = async (_usernameInput: any) => {
    setUsernameError("");

    if (_usernameInput.length < 3) {
      setUsernameError(t("minUsernameLength"));
      return;
    }

    if (_usernameInput.length > 20) {
      setUsernameError(t("maxUsernameLength"));
      return;
    }

    if (!/^[a-zA-Z0-9_]+$/.test(_usernameInput)) {
      setUsernameError("Username can only contain letters, numbers, and underscores");
      return;
    }

    setIsUsernameSigning(true);

    try {
      /* const read = (await readContracts(config, {
        contracts: [
          {
            abi: CrystalReferralAbi,
            address: settings.chainConfig[activechain].referralManager,
            functionName: 'usernameToAddress',
            args: [_usernameInput],
          },
        ]
      })) as any[];

      if (read[0].result !== '0x0000000000000000000000000000000000000000') {
        setUsernameError(t("usernameAlreadyTaken"));
        setIsUsernameSigning(false);
        return;
      }

      const hash = await sendUserOperationAsync({
        uo: {
          target: settings.chainConfig[activechain].referralManager,
          data: encodeFunctionData({
            abi: CrystalReferralAbi,
            functionName: 'setUsername',
            args: [
              _usernameInput
            ],
          }),
          value: 0n,
        },
      }); */

      setUsername(_usernameInput);
      audio.currentTime = 0;
      audio.play();
      if (popup == 16) {
        setpopup(0)
      }
      else {
        setpopup(17);
      }
      return true;
    } catch (error) {
      return false;
    } finally {
      setIsUsernameSigning(false);
    }
  };

  const handleBackToUsernameWithAudio = () => {
    if (backAudioRef.current) {
      backAudioRef.current.currentTime = 0;
      backAudioRef.current.play().catch(console.error);
    }
    setIsTransitioning(true);
    setTransitionDirection('backward');
    setExitingChallenge(true);

    setTimeout(() => {
      setpopup(14);
      setCurrentStep(0);

      setTimeout(() => {
        setIsTransitioning(false);
        setExitingChallenge(false);
      });
    }, 10);
  };

  /* useEffect(() => {
    const fetchUsername = async () => {
      try {
        const read = await readContracts(config, {
          contracts: [
            {
              abi: CrystalReferralAbi,
              address: settings.chainConfig[activechain].referralManager,
              functionName: 'addressToUsername',
              args: [address as `0x${string}`],
            },
          ]
        });

        if (read[0]?.result?.length != null) {
          setUsernameInput(read[0]?.result?.length > 0 ? read[0]?.result : "");
          setUsername(read[0]?.result?.length > 0 ? read[0]?.result : "");
          setUsernameResolved(true);
        }
      } catch (error) {
        console.error("Failed to fetch username:", error);
      }
    };

    if (address) {
      fetchUsername();
    }
  }, [address, activechain, config]); */

  useEffect(() => {
    let animationStartTimer: ReturnType<typeof setTimeout> | undefined;
    let animatingTimer: ReturnType<typeof setTimeout> | undefined;

    if (currentStep === 0) {
      animationStartTimer = setTimeout(() => {
        setAnimationStarted(true);
      }, 100);
    } else {
      setAnimationStarted(false);
    }

    setAnimating(true);
    animatingTimer = setTimeout(() => {
      setAnimating(false);
    }, 300);

    return () => {
      if (animationStartTimer) clearTimeout(animationStartTimer);
      if (animatingTimer) clearTimeout(animatingTimer);
    };
  }, [currentStep]);

  const formatKeyDisplay = (key: string) => {
    if (!key) return '';
    const keyMap: { [key: string]: string } = {
      'Enter': 'Enter',
      'Escape': 'Esc',
      'Space': 'Space',
      'Slash': '/',
      'Backslash': '\\',
      'Comma': ',',
      'Period': '.',
      'Semicolon': ';',
      'Quote': "'",
      'BracketLeft': '[',
      'BracketRight': ']',
      'Backquote': '`',
      'Minus': '-',
      'Equal': '=',
      'Tab': 'Tab',
      'CapsLock': 'Caps Lock',
      'ShiftLeft': 'Shift',
      'ShiftRight': 'Shift',
      'ControlLeft': 'Ctrl',
      'ControlRight': 'Ctrl',
      'AltLeft': 'Alt',
      'AltRight': 'Alt',
      'MetaLeft': 'Cmd',
      'MetaRight': 'Cmd',
      'ArrowUp': '',
      'ArrowDown': '',
      'ArrowLeft': '',
      'ArrowRight': '',
      'Delete': 'Del',
      'Backspace': '',
    };

    if (keyMap[key]) return keyMap[key];
    if (key.startsWith('Key')) return key.slice(3).toUpperCase();
    if (key.startsWith('Digit')) return key.slice(5);
    if (key.startsWith('F') && key.length <= 3) return key.toUpperCase();
    return key;
  };

  const handleRefreshQuote = useCallback(async (e: any) => {
    e.preventDefault();
    if (isRefreshing) return;
    setIsRefreshing(true);
    setStateIsLoading(true);
    await refetch()
    setIsRefreshing(false);
  }, [isRefreshing, refetch]);

  const handleCancelTopOrder = useCallback(async () => {
    if (!connected || userchain !== activechain || orders.length === 0 || isSigning) {
      return;
    }

    try {
      const topOrder = orders[0];
      await cancelOrder(
        sendUserOperationAsync,
        router,
        topOrder[3] == 1
          ? markets[topOrder[4]].quoteAddress
          : markets[topOrder[4]].baseAddress,
        topOrder[3] == 1
          ? markets[topOrder[4]].baseAddress
          : markets[topOrder[4]].quoteAddress,
        BigInt(topOrder[0]),
        BigInt(topOrder[1]),
        BigInt(Math.floor(Date.now() / 1000) + 900)
      );

      refetch();

    } catch {
    }
  }, [connected, userchain, activechain, orders, router, markets, sendUserOperationAsync, refetch, isSigning]);

  const handleCancelAllOrders = useCallback(async () => {
    if (!connected || userchain !== activechain || orders.length === 0 || isSigning) {
      return;
    }

    try {
      const orderbatch: Record<string, any> = {}

      orders.forEach(order => {
        const k = markets[order[4]].address
        if (!orderbatch[k]) orderbatch[k] = []
        orderbatch[k].push({
          isRequireSuccess: false,
          action: 1n,
          param1: order[0], // price
          param2: order[1], // size/id
          param3: BigInt(0),  // cloid or extra id
        })
      })

      const batches: any = Object.entries(orderbatch).map(([market, actions]) => ({
        market: market as `0x${string}`,
        actions,
        options: BigInt(0)
      }))

      await sendUserOperationAsync({
        uo: multiBatchOrders(
          router,
          BigInt(0),
          batches,
          BigInt(Math.floor(Date.now() / 1000) + 900),
          '0x0000000000000000000000000000000000000000',
        )
      });

      refetch();

    } catch {
    }
  }, [connected, userchain, activechain, orders, markets, router, address, sendUserOperationAsync, refetch, isSigning]);

  const handleSubmitTransaction = useCallback(() => {
    if (popup !== 0) return;

    const currentPath = location.pathname.slice(1);
    if (!['swap', 'market', 'limit', 'send', 'scale'].includes(currentPath)) {
      return;
    }

    switch (currentPath) {
      case 'swap':
      case 'market':
        if (!swapButtonDisabled && !displayValuesLoading && !isSigning && connected && userchain === activechain) {
          const swapButton = document.querySelector('.swap-button') as HTMLButtonElement;
          if (swapButton && !swapButton.disabled) {
            swapButton.click();
          }
        }
        break;
      case 'limit':
        if (!limitButtonDisabled && !isSigning && connected && userchain === activechain) {
          const limitButton = document.querySelector('.limit-swap-button') as HTMLButtonElement;
          if (limitButton && !limitButton.disabled) {
            limitButton.click();
          }
        }
        break;
      case 'send':
        if (!sendButtonDisabled && !isSigning && connected && userchain === activechain) {
          const sendButton = document.querySelector('.send-swap-button') as HTMLButtonElement;
          if (sendButton && !sendButton.disabled) {
            sendButton.click();
          }
        }
        break;
      case 'scale':
        if (!scaleButtonDisabled && !isSigning && connected && userchain === activechain) {
          const scaleButton = document.querySelector('.limit-swap-button') as HTMLButtonElement;
          if (scaleButton && !scaleButton.disabled) {
            scaleButton.click();
          }
        }
        break;
    }
  }, [popup, location.pathname, swapButtonDisabled, displayValuesLoading, isSigning, connected, userchain, activechain, limitButtonDisabled, sendButtonDisabled, scaleButtonDisabled]);

  useEffect(() => {
    const handleKeyDown = (event: KeyboardEvent) => {
      if (isListeningForKey && editingKeybind) {
        event.preventDefault();
        event.stopPropagation();

        const forbiddenKeys = ['F5', 'F11', 'F12', 'Tab', 'AltLeft', 'AltRight', 'ControlLeft', 'ControlRight', 'Escape', 'ArrowUp', 'ArrowDown'];
        if (forbiddenKeys.includes(event.code)) {
          return;
        }

        const existingKeybindEntry = Object.entries(keybinds).find(
          ([key, value]) => value === event.code && key !== editingKeybind
        );

        if (existingKeybindEntry) {
          const [duplicateKey] = existingKeybindEntry;
          setKeybindError(`This key is already assigned to "${duplicateKey}"`);
          setDuplicateKeybind(duplicateKey);
          setTimeout(() => {
            setKeybindError(null);
            setDuplicateKeybind(null);
          }, 3000);

          return;
        }

        const newKeybinds = { ...keybinds, [editingKeybind]: event.code };
        setKeybinds(newKeybinds);
        localStorage.setItem('crystal_keybinds', JSON.stringify(newKeybinds));
        setEditingKeybind(null);
        setIsListeningForKey(false);

        setKeybindError(null);
        setDuplicateKeybind(null);
        return;
      }

      if (isListeningForKey || (popup !== 0 && event.code !== keybinds.cancelTopOrder)) {
        return;
      }

      const activeElement = document.activeElement;
      if (activeElement && event.code !== keybinds.submitTransaction && (
        activeElement.tagName === 'INPUT' ||
        activeElement.tagName === 'TEXTAREA' ||
        activeElement.hasAttribute('contenteditable')
      )) {
        return;
      }

      if (event.code === keybinds.submitTransaction) {
        event.preventDefault();
        handleSubmitTransaction();
        return;
      }

      if (event.code === keybinds.switchTokens && ['swap', 'limit', 'market', 'scale'].includes(location.pathname.slice(1))) {
        event.preventDefault();
        const switchButton = document.querySelector('.switch-button') as HTMLElement;
        if (switchButton) switchButton.click();
        return;
      }

      if (event.code === keybinds.maxAmount && ['swap', 'limit', 'send', 'scale', 'market'].includes(location.pathname.slice(1))) {
        event.preventDefault();
        const maxButton = document.querySelector('.max-button') as HTMLElement;
        if (maxButton) maxButton.click();
        return;
      }

      if (event.code === keybinds.focusInput && ['swap', 'limit', 'send', 'scale', 'market'].includes(location.pathname.slice(1))) {
        event.preventDefault();
        const mainInput = document.querySelector('.input') as HTMLInputElement;
        if (mainInput) mainInput.focus();
        return;
      }

      if (event.code === keybinds.openSettings) {
        event.preventDefault();
        setpopup(5);
        return;
      }

      if (event.code === keybinds.openWallet) {
        event.preventDefault();
        setpopup(4);
        return;
      }

      if (event.code === keybinds.openTokenInSelect && ['swap', 'limit', 'send', 'scale', 'market'].includes(location.pathname.slice(1))) {
        event.preventDefault();
        setpopup(1);
        return;
      }

      if (event.code === keybinds.openTokenOutSelect && ['swap', 'limit', 'scale', 'market'].includes(location.pathname.slice(1))) {
        event.preventDefault();
        setpopup(2);
        return;
      }

      if (event.code === keybinds.cancelAllOrders) {
        event.preventDefault();
        handleCancelAllOrders();
        return;
      }

      if (event.code === keybinds.cancelTopOrder) {
        event.preventDefault();
        handleCancelTopOrder();
        return;
      }

      if (event.code === keybinds.openMarketSearch) {
        event.preventDefault();
        setpopup(8);
        return;
      }

      if (event.code === keybinds.toggleFavorite && activeMarket) {
        event.preventDefault();
        toggleFavorite(activeMarket.baseAddress?.toLowerCase() ?? '');
        return;
      }

      if (event.code === keybinds.toggleSimpleView) {
        event.preventDefault();
        const newSimpleView = !simpleView;
        setSimpleView(newSimpleView);

        if (newSimpleView) {
          navigate('/swap');
        } else {
          navigate('/market');
        }
        return;
      }

      if (event.code === keybinds.refreshQuote && ['swap', 'limit', 'send', 'scale', 'market'].includes(location.pathname.slice(1))) {
        event.preventDefault();
        handleRefreshQuote(event as any);
        return;
      }

      if (isOrderCenterVisible && !simpleView) {
        if (event.code === keybinds.switchToOrders) {
          event.preventDefault();
          setActiveSection('orders');
          localStorage.setItem('crystal_oc_tab', 'orders');
          return;
        }

        if (event.code === keybinds.switchToTrades) {
          event.preventDefault();
          setActiveSection('tradeHistory');
          localStorage.setItem('crystal_oc_tab', 'tradeHistory');
          return;
        }

        if (event.code === keybinds.switchToHistory) {
          event.preventDefault();
          setActiveSection('orderHistory');
          localStorage.setItem('crystal_oc_tab', 'orderHistory');
          return;
        }
      }
    };

    document.addEventListener('keydown', handleKeyDown);

    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [
    keybinds,
    isListeningForKey,
    editingKeybind,
    popup,
    location.pathname,
    simpleView,
    isOrderCenterVisible,
    activeMarket,
    navigate,
    toggleFavorite,
    setSimpleView,
    setActiveSection,
    handleRefreshQuote,
    handleSubmitTransaction,
    handleCancelAllOrders,
    handleCancelTopOrder,
    setpopup
  ]);

  const renderKeybindButton = (keybindKey: string, labelText: string, descriptionText: string) => (
    <>
      <div className="keybind-setting-row">
        <div className="keybind-info">
          <span className="keybind-label">{labelText}</span>
          <span className="keybind-description">{descriptionText}</span>
        </div>
        <div className="keybind-button-container">
          <button
            className={`keybind-button ${editingKeybind === keybindKey && isListeningForKey ? 'listening' : ''
              } ${duplicateKeybind === keybindKey ? 'error' : ''
              }`}
            onClick={() => {
              if (editingKeybind === keybindKey && isListeningForKey) {
                setEditingKeybind(null);
                setIsListeningForKey(false);
                setKeybindError(null);
                setDuplicateKeybind(null);
              } else {
                setEditingKeybind(keybindKey);
                setIsListeningForKey(true);
                setKeybindError(null);
                setDuplicateKeybind(null);
              }
            }}
          >
            {editingKeybind === keybindKey && isListeningForKey
              ? t('pressAKey')
              : formatKeyDisplay(keybinds[keybindKey])}
          </button>
        </div>

      </div>
      {keybindError && editingKeybind === keybindKey && (
        <div className="keybind-error-message">
          {keybindError}
        </div>
      )}
    </>
  );

  // input tokenlist
  const TokenList1 = (
    <div className="tokenlistcontainer">
      <ul className="tokenlist">
        {Object.values(tokendict).filter(
          (token) =>
            token.ticker.toLowerCase().includes(tokenString.toLowerCase()) ||
            token.name.toLowerCase().includes(tokenString.toLowerCase()) ||
            token.address.toLowerCase().includes(tokenString.toLowerCase()),
        ).length === 0 ? (
          <div className="empty-token-list">
            <div className="empty-token-list-content">
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="empty-token-list-icon"
              >
                <circle cx="11" cy="11" r="8" />
                <path d="M21 21l-4.35-4.35" />
              </svg>
              <div className="empty-token-list-text">{t('noTokens')}</div>
            </div>
          </div>
        ) : (
          Object.values(tokendict)
            .filter(
              (token) =>
                token.ticker.toLowerCase().includes(tokenString.toLowerCase()) ||
                token.name.toLowerCase().includes(tokenString.toLowerCase()) ||
                token.address.toLowerCase().includes(tokenString.toLowerCase()),
            )
            .sort((a, b) => {
              return (Number(tokenBalances[b.address] ?? 0) == 0) !== (Number(tokenBalances[a.address] ?? 0) == 0)
                ? (Number(tokenBalances[a.address] ?? 0) == 0 ? 1 : -1)
                : a?.autofetched && !b?.autofetched ? 1 : !a?.autofetched && b?.autofetched ? -1 : (Number(tokenBalances[b.address] ?? 0) / 10 ** Number(b.decimals)) - (Number(tokenBalances[a.address] ?? 0) / 10 ** Number(a.decimals));
            })
            .map((token, index) => (
              <button
                className={`tokenbutton ${index === selectedTokenIndex ? 'selected' : ''}`}
                key={token.address}
                onMouseEnter={() => setSelectedTokenIndex(index)}
                onClick={() => {
                  if ((location.pathname.slice(1) == 'lending' || location.pathname.slice(1) == 'earn/liquidity') && onSelectTokenCallback) {
                    onSelectTokenCallback({
                      icon: token.image,
                      symbol: token.ticker
                    });
                    setpopup(0);
                    settokenString('');
                    return;
                  }
                  let pricefetchmarket;
                  let newTokenOut;
                  setpopup(0);
                  settokenString('');
                  setTokenIn(token.address);
                  setStateIsLoading(true);
                  if (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market') {
                    if (token.address !== tokenOut) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenOut].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenOut].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                        newTokenOut = tokenOut;
                      } else {
                        const path = findShortestPath(token.address, tokenOut);
                        if (path && path.length > 1 && (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market')) {
                          newTokenOut = tokenOut;
                        } else {
                          let found = false;
                          for (const market in markets) {
                            if (
                              markets[market].baseAddress === token.address
                            ) {
                              setTokenOut(markets[market].quoteAddress);
                              newTokenOut = markets[market].quoteAddress;
                              found = true;
                              break;
                            }
                          }
                          if (!found) {
                            for (const market in markets) {
                              if (
                                markets[market].quoteAddress === token.address
                              ) {
                                setTokenOut(markets[market].baseAddress);
                                newTokenOut = markets[market].baseAddress;
                                break;
                              }
                            }
                          }
                        }
                      }
                      if (
                        (tokenOut == eth && token.address == weth) ||
                        (tokenOut == weth && token.address == eth)
                      ) {
                        if (switched == false) {
                          setamountIn((amountIn * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenIn].decimals)
                          setamountOutSwap((amountIn * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenIn].decimals);
                          setoutputString(inputString);
                          const percentage = !tokenBalances[token.address]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  ((amountIn * BigInt(10) ** token.decimals) /
                                    BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                                  tokenBalances[token.address],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                        else {
                          setamountIn(amountOutSwap);
                          setInputString(outputString);
                          const percentage = !tokenBalances[token.address]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  (amountOutSwap * BigInt(100)) /
                                  tokenBalances[token.address],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                      } else {
                        if (switched === false && token.address != tokenIn) {
                          setamountIn(
                            (amountIn * BigInt(10) ** token.decimals) /
                            BigInt(10) ** tokendict[tokenIn].decimals
                          );
                          setamountOutSwap(BigInt(0));
                          setoutputString('');
                          const percentage = !tokenBalances[token.address]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  ((amountIn * BigInt(10) ** token.decimals) /
                                    BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                                  tokenBalances[token.address],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        } else if (newTokenOut != tokenOut) {
                          setamountOutSwap(
                            (amountOutSwap *
                              BigInt(10) ** tokendict[newTokenOut].decimals) /
                            BigInt(10) ** tokendict[tokenOut].decimals,
                          );
                          setamountIn(BigInt(0));
                          setInputString('');
                        }
                      }
                      setlimitChase(true);
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                    } else {
                      setTokenOut(tokenIn);
                      if (
                        (amountIn != BigInt(0) || amountOutSwap != BigInt(0)) &&
                        !isWrap
                      ) {
                        if (switched == false) {
                          setswitched(true);
                          setStateIsLoading(true);
                          setInputString('');
                          setamountIn(BigInt(0));
                          setamountOutSwap(amountIn);
                          setoutputString(
                            amountIn === BigInt(0)
                              ? ''
                              : String(
                                customRound(
                                  Number(amountIn) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                ),
                              ),
                          );
                        } else {
                          setswitched(false);
                          setStateIsLoading(true);
                          setoutputString('');
                          setamountOutSwap(BigInt(0));
                          setamountIn(amountOutSwap);
                          setInputString(
                            amountOutSwap === BigInt(0)
                              ? ''
                              : String(
                                customRound(
                                  Number(amountOutSwap) /
                                  10 **
                                  Number(tokendict[tokenOut].decimals),
                                  3,
                                ),
                              ),
                          );
                          const percentage = !tokenBalances[tokenOut]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  (amountOutSwap * BigInt(100)) /
                                  tokenBalances[tokenOut],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                      }
                    }
                  } else if (location.pathname.slice(1) == 'limit') {
                    if ((token.address == weth ? eth : token.address) != (tokenOut == weth ? eth : tokenOut)) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenOut].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenOut].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                      } else {
                        let found = false;
                        for (const market in markets) {
                          if (
                            markets[market].baseAddress === token.address
                          ) {
                            setTokenOut(markets[market].quoteAddress);
                            found = true;
                            break;
                          }
                        }
                        if (!found) {
                          for (const market in markets) {
                            if (markets[market].quoteAddress === token.address) {
                              setTokenOut(markets[market].baseAddress);
                              break;
                            }
                          }
                        }
                      }
                      setamountIn(
                        (amountIn * BigInt(10) ** token.decimals) /
                        BigInt(10) ** tokendict[tokenIn].decimals
                      );
                      setlimitChase(true);
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                      const percentage = !tokenBalances[token.address]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              ((amountIn * BigInt(10) ** token.decimals) /
                                BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                              tokenBalances[token.address],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left =
                          `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                      }
                    } else {
                      setTokenOut(tokenIn);
                      setswitched((switched) => { return !switched });
                      if (amountIn != BigInt(0)) {
                        if (limitChase && mids?.[activeMarketKey]?.[0]) {
                          const price = tokenOut === activeMarket?.baseAddress ? mids[activeMarketKey][0] == mids[activeMarketKey][1] ? mids[activeMarketKey][2] : mids[activeMarketKey][0] : mids[activeMarketKey][0] == mids[activeMarketKey][2] ? mids[activeMarketKey][1] : mids[activeMarketKey][0]
                          setlimitPrice(price);
                          setlimitPriceString(
                            (
                              Number(price) / Number(activeMarket.priceFactor)
                            ).toFixed(Math.floor(Math.log10(activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10((Number(price) / Number(activeMarket.priceFactor)) || 1)) - 1) : Number(activeMarket.priceFactor)))),
                          );
                          setamountOutSwap(
                            price != BigInt(0) && amountIn != BigInt(0)
                              ? tokenOut === activeMarket?.baseAddress
                                ? (amountIn * price) /
                                (activeMarket.scaleFactor || BigInt(1))
                                : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                                price
                              : BigInt(0),
                          );
                          setoutputString(
                            (price != BigInt(0) && amountIn != BigInt(0)
                              ? tokenOut === activeMarket?.baseAddress
                                ? customRound(
                                  Number(
                                    (amountIn * price) /
                                    (activeMarket.scaleFactor || BigInt(1)),
                                  ) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                )
                                : customRound(
                                  Number(
                                    (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                                    price,
                                  ) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        setInputString(outputString);
                        setoutputString(inputString);
                        setamountIn(amountOutSwap);
                        setamountOutSwap(amountIn);
                        const percentage = !tokenBalances[tokenOut]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (amountOutSwap * BigInt(100)) /
                                tokenBalances[tokenOut],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                    }
                  } else if (location.pathname.slice(1) == 'send') {
                    setlimitChase(true);
                    setScaleStart(BigInt(0))
                    setScaleEnd(BigInt(0))
                    setScaleStartString('')
                    setScaleEndString('')
                    if (((token.address == weth ? eth : token.address) != (tokenOut == weth ? eth : tokenOut)) && multihop == false) {
                      setTokenOut(tokenIn);
                      pricefetchmarket = getMarket(token.address, tokenIn);
                    } else if (
                      markets[
                      `${tokendict[token.address].ticker}${tokendict[tokenOut].ticker}`
                      ] ||
                      markets[
                      `${tokendict[tokenOut].ticker}${tokendict[token.address].ticker}`
                      ]
                    ) {
                      pricefetchmarket = getMarket(token.address, tokenOut);
                    } else {
                      let found = false;
                      for (const market in markets) {
                        if (
                          markets[market].baseAddress === token.address
                        ) {
                          setTokenOut(markets[market].quoteAddress);
                          pricefetchmarket = getMarket(
                            token.address,
                            markets[market].quoteAddress,
                          );
                          found = true;
                          break;
                        }
                      }
                      if (!found) {
                        for (const market in markets) {
                          if (markets[market].quoteAddress === token.address) {
                            setTokenOut(markets[market].baseAddress);
                            pricefetchmarket = getMarket(
                              token.address,
                              markets[market].baseAddress,
                            );
                            break;
                          }
                        }
                      }
                    }
                    if (displayMode == 'usd') {
                      setInputString(
                        customRound(
                          Number(
                            calculateTokenAmount(
                              sendInputString.replace(/^\$|,/g, ''),
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(pricefetchmarket)
                              ],
                              token.address,
                              pricefetchmarket,
                            ),
                          ) /
                          10 ** Number(token.decimals),
                          3,
                        ).toString(),
                      );
                      setamountIn(
                        calculateTokenAmount(
                          sendInputString.replace(/^\$|,/g, ''),
                          tradesByMarket[
                          (({ baseAsset, quoteAsset }) =>
                            (baseAsset === wethticker ? ethticker : baseAsset) +
                            (quoteAsset === wethticker ? ethticker : quoteAsset)
                          )(pricefetchmarket)
                          ],
                          token.address,
                          pricefetchmarket,
                        ),
                      );
                      const percentage = !tokenBalances[token.address]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (calculateTokenAmount(
                                sendInputString.replace(/^\$|,/g, ''),
                                tradesByMarket[
                                (({ baseAsset, quoteAsset }) =>
                                  (baseAsset === wethticker ? ethticker : baseAsset) +
                                  (quoteAsset === wethticker ? ethticker : quoteAsset)
                                )(pricefetchmarket)
                                ],
                                token.address,
                                pricefetchmarket,
                              ) * BigInt(100)) /
                              tokenBalances[token.address],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left =
                          `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                      }
                    } else {
                      setamountIn(
                        (amountIn * BigInt(10) ** token.decimals) /
                        BigInt(10) ** tokendict[tokenIn].decimals
                      );
                      setsendInputString(
                        `$${calculateUSDValue(
                          (amountIn * BigInt(10) ** token.decimals) /
                          BigInt(10) ** tokendict[tokenIn].decimals,
                          tradesByMarket[
                          (({ baseAsset, quoteAsset }) =>
                            (baseAsset === wethticker ? ethticker : baseAsset) +
                            (quoteAsset === wethticker ? ethticker : quoteAsset)
                          )(pricefetchmarket)
                          ],
                          token.address,
                          pricefetchmarket,
                        ).toFixed(2)}`,
                      );
                      const percentage = !tokenBalances[token.address]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              ((amountIn * BigInt(10) ** token.decimals) /
                                BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                              tokenBalances[token.address],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left =
                          `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                      }
                    }
                  } else if (location.pathname.slice(1) == 'scale') {
                    if ((token.address == weth ? eth : token.address) != (tokenOut == weth ? eth : tokenOut)) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenOut].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenOut].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                      } else {
                        let found = false;
                        for (const market in markets) {
                          if (
                            markets[market].baseAddress === token.address
                          ) {
                            setTokenOut(markets[market].quoteAddress);
                            found = true;
                            break;
                          }
                        }
                        if (!found) {
                          for (const market in markets) {
                            if (markets[market].quoteAddress === token.address) {
                              setTokenOut(markets[market].baseAddress);
                              break;
                            }
                          }
                        }
                      }
                      setamountIn(
                        BigInt(0)
                      );
                      setInputString('')
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                      setlimitChase(true);
                      const percentage = !tokenBalances[token.address]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              BigInt(0) /
                              tokenBalances[token.address],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left =
                          `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                      }
                    } else {
                      setTokenOut(tokenIn);
                      setswitched((switched) => { return !switched });
                      if (amountIn != BigInt(0) && scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                        setInputString(outputString);
                        setoutputString(inputString);
                        setamountIn(amountOutSwap);
                        setamountOutSwap(amountIn);
                        const percentage = !tokenBalances[tokenOut]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (amountOutSwap * BigInt(100)) /
                                tokenBalances[tokenOut],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector('.balance-amount-slider');
                        const popup = document.querySelector('.slider-percentage-popup');
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                      else {
                        setamountIn(BigInt(0))
                        setInputString('')
                      }
                    }
                  }
                }}
              >
                <img className="tokenlistimage" src={token.image} />
                <div className="tokenlisttext">
                  <div className="tokenlistname">
                    {token.ticker}
                  </div>
                  <div className="tokenlistticker">{token.name}</div>
                </div>
                <div className="token-right-content">
                  <div className="tokenlistbalance">
                    {formatSubscript(customRound(
                      Number(tokenBalances[token.address] ?? 0) /
                      10 ** Number(token.decimals ?? 18),
                      3,
                    )
                      .replace(/(\.\d*?[1-9])0+$/g, '$1')
                      .replace(/\.0+$/, ''))}
                  </div>
                  <div className="token-address-container">
                    <span className="token-address">
                      {`${token.address.slice(0, 6)}...${token.address.slice(-4)}`}
                    </span>
                    <div
                      className="copy-address-button"
                      onClick={(e) => {
                        e.stopPropagation();
                        navigator.clipboard.writeText(token.address);
                        const copyIcon =
                          e.currentTarget.querySelector('.copy-icon');
                        const checkIcon =
                          e.currentTarget.querySelector('.check-icon');
                        if (copyIcon && checkIcon) {
                          copyIcon.classList.add('hidden');
                          checkIcon.classList.add('visible');
                          setTimeout(() => {
                            copyIcon.classList.remove('hidden');
                            checkIcon.classList.remove('visible');
                          }, 2000);
                        }
                      }}
                    >
                      <svg
                        className="copy-icon"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <rect
                          x="9"
                          y="9"
                          width="13"
                          height="13"
                          rx="2"
                          ry="2"
                        ></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                      </svg>
                      <svg
                        className="check-icon"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <circle cx="12" cy="12" r="10" />
                        <path d="M8 12l3 3 6-6" />
                      </svg>
                    </div>
                  </div>
                </div>
              </button>
            ))
        )}
      </ul>
    </div>
  );

  // output tokenlist
  const TokenList2 = (
    <div className="tokenlistcontainer">
      <ul className="tokenlist">
        {Object.values(tokendict).filter(
          (token) =>
            token.ticker.toLowerCase().includes(tokenString.toLowerCase()) ||
            token.name.toLowerCase().includes(tokenString.toLowerCase()) ||
            token.address.toLowerCase().includes(tokenString.toLowerCase()),
        ).length === 0 ? (
          <div className="empty-token-list">
            <div className="empty-token-list-content">
              <svg
                width="24"
                height="24"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
                className="empty-token-list-icon"
              >
                <circle cx="11" cy="11" r="8" />
                <path d="M21 21l-4.35-4.35" />
              </svg>
              <div className="empty-token-list-text">{t('noTokens')}</div>
            </div>
          </div>
        ) : (
          Object.values(tokendict)
            .filter(
              (token) =>
                token.ticker.toLowerCase().includes(tokenString.toLowerCase()) ||
                token.name.toLowerCase().includes(tokenString.toLowerCase()) ||
                token.address.toLowerCase().includes(tokenString.toLowerCase()),
            )
            .map((token, index) => (
              <button
                className={`tokenbutton ${index === selectedTokenIndex ? 'selected' : ''}`}
                key={token.address}
                onMouseEnter={() => setSelectedTokenIndex(index)}
                onClick={() => {
                  let newTokenIn;
                  setpopup(0);
                  settokenString('');
                  setTokenOut(token.address);
                  setStateIsLoading(true);
                  if (location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market') {
                    if (token.address != tokenIn) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenIn].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenIn].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                        newTokenIn = tokenIn;
                      } else {
                        const path = findShortestPath(
                          tokendict[tokenIn].address,
                          token.address,
                        );
                        if (path && path.length > 1) {
                          newTokenIn = tokenIn;
                        } else {
                          let found = false;
                          for (const market in markets) {
                            if (
                              markets[market].baseAddress === token.address
                            ) {
                              setTokenIn(markets[market].quoteAddress);
                              newTokenIn = markets[market].quoteAddress;
                              found = true;
                              break;
                            }
                          }
                          if (!found) {
                            for (const market in markets) {
                              if (
                                markets[market].quoteAddress === token.address
                              ) {
                                setTokenIn(markets[market].baseAddress);
                                newTokenIn = markets[market].baseAddress;
                                break;
                              }
                            }
                          }
                        }
                      }
                      if (
                        (tokenIn == eth && token.address == weth) ||
                        (tokenIn == weth && token.address == eth)
                      ) {
                        if (switched == false) {
                          setamountOutSwap(amountIn);
                          setoutputString(inputString);
                        }
                        else {
                          setamountOutSwap((amountOutSwap * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenOut].decimals)
                          setamountIn((amountOutSwap * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenOut].decimals);
                          setInputString(outputString);
                          const percentage = !tokenBalances[tokenIn]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  ((amountOutSwap * BigInt(10) ** token.decimals) / BigInt(10) ** tokendict[tokenOut].decimals * BigInt(100)) /
                                  tokenBalances[tokenIn],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                      } else {
                        if (switched == false) {
                          setamountIn(
                            (amountIn *
                              BigInt(10) ** tokendict[newTokenIn].decimals) /
                            BigInt(10) ** tokendict[tokenIn].decimals
                          );
                          setamountOutSwap(BigInt(0));
                          setoutputString('');
                          const percentage = !tokenBalances[newTokenIn]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  ((amountIn *
                                    BigInt(10) ** tokendict[newTokenIn].decimals) /
                                    BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                                  tokenBalances[newTokenIn],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        } else if (token.address != tokenOut) {
                          setamountOutSwap(
                            (amountOutSwap * BigInt(10) ** token.decimals) /
                            BigInt(10) ** tokendict[tokenOut].decimals,
                          );
                          setamountIn(BigInt(0));
                          setInputString('');
                        }
                      }
                      setlimitChase(true);
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                    } else {
                      setTokenIn(tokenOut);
                      if (
                        (amountIn != BigInt(0) || amountOutSwap != BigInt(0)) &&
                        !isWrap
                      ) {
                        if (switched == false) {
                          setswitched(true);
                          setStateIsLoading(true);
                          setInputString('');
                          setamountIn(BigInt(0));
                          setamountOutSwap(amountIn);
                          setoutputString(
                            amountIn === BigInt(0)
                              ? ''
                              : String(
                                customRound(
                                  Number(amountIn) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                ),
                              ),
                          );
                        } else {
                          setswitched(false);
                          setStateIsLoading(true);
                          setoutputString('');
                          setamountOutSwap(BigInt(0));
                          setamountIn(amountOutSwap);
                          setInputString(
                            amountOutSwap === BigInt(0)
                              ? ''
                              : String(
                                customRound(
                                  Number(amountOutSwap) /
                                  10 **
                                  Number(tokendict[tokenOut].decimals),
                                  3,
                                ),
                              ),
                          );
                          const percentage = !tokenBalances[tokenOut]
                            ? 0
                            : Math.min(
                              100,
                              Math.floor(
                                Number(
                                  (amountOutSwap * BigInt(100)) /
                                  tokenBalances[tokenOut],
                                ),
                              ),
                            );
                          setSliderPercent(percentage);
                          const slider = document.querySelector(
                            '.balance-amount-slider',
                          );
                          const popup = document.querySelector(
                            '.slider-percentage-popup',
                          );
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left =
                              `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                          }
                        }
                      }
                    }
                  } else if (location.pathname.slice(1) == 'limit') {
                    if ((token.address == weth ? eth : token.address) != (tokenIn == weth ? eth : tokenIn)) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenIn].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenIn].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                        newTokenIn = tokenIn;
                      } else {
                        let found = false;
                        for (const market in markets) {
                          if (
                            markets[market].baseAddress === token.address
                          ) {
                            setTokenIn(markets[market].quoteAddress);
                            newTokenIn = markets[market].quoteAddress;
                            found = true;
                            break;
                          }
                        }
                        if (!found) {
                          for (const market in markets) {
                            if (markets[market].quoteAddress === token.address) {
                              setTokenIn(markets[market].baseAddress);
                              newTokenIn = markets[market].baseAddress;
                              break;
                            }
                          }
                        }
                      }
                      setamountIn(
                        (amountIn *
                          BigInt(10) ** tokendict[newTokenIn].decimals) /
                        BigInt(10) ** tokendict[tokenIn].decimals,
                      );
                      setlimitChase(true);
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                      const percentage = !tokenBalances[newTokenIn]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              ((amountIn * BigInt(10) ** tokendict[newTokenIn].decimals) /
                                BigInt(10) ** tokendict[tokenIn].decimals * BigInt(100)) /
                              tokenBalances[newTokenIn],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left =
                          `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                      }
                    } else {
                      setTokenIn(tokenOut);
                      setswitched((switched) => { return !switched });
                      if (amountIn != BigInt(0)) {
                        if (limitChase && mids?.[activeMarketKey]?.[0]) {
                          const price = tokenOut === activeMarket?.baseAddress ? mids[activeMarketKey][0] == mids[activeMarketKey][1] ? mids[activeMarketKey][2] : mids[activeMarketKey][0] : mids[activeMarketKey][0] == mids[activeMarketKey][2] ? mids[activeMarketKey][1] : mids[activeMarketKey][0]
                          setlimitPrice(price);
                          setlimitPriceString(
                            (
                              Number(price) / Number(activeMarket.priceFactor)
                            ).toFixed(Math.floor(Math.log10(activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10((Number(price) / Number(activeMarket.priceFactor)) || 1)) - 1) : Number(activeMarket.priceFactor)))),
                          );
                          setamountOutSwap(
                            price != BigInt(0) && amountIn != BigInt(0)
                              ? tokenOut === activeMarket?.baseAddress
                                ? (amountIn * price) /
                                (activeMarket.scaleFactor || BigInt(1))
                                : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                                price
                              : BigInt(0),
                          );
                          setoutputString(
                            (price != BigInt(0) && amountIn != BigInt(0)
                              ? tokenOut === activeMarket?.baseAddress
                                ? customRound(
                                  Number(
                                    (amountIn * price) /
                                    (activeMarket.scaleFactor || BigInt(1)),
                                  ) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                )
                                : customRound(
                                  Number(
                                    (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                                    price,
                                  ) /
                                  10 ** Number(tokendict[tokenIn].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        setInputString(outputString);
                        setoutputString(inputString);
                        setamountIn(amountOutSwap);
                        setamountOutSwap(amountIn);
                        const percentage = !tokenBalances[tokenOut]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (amountOutSwap * BigInt(100)) /
                                tokenBalances[tokenOut],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                    }
                  } else if (location.pathname.slice(1) == 'scale') {
                    if ((token.address == weth ? eth : token.address) != (tokenIn == weth ? eth : tokenIn)) {
                      if (
                        markets[
                        `${tokendict[token.address].ticker}${tokendict[tokenIn].ticker}`
                        ] ||
                        markets[
                        `${tokendict[tokenIn].ticker}${tokendict[token.address].ticker}`
                        ]
                      ) {
                        newTokenIn = tokenIn;
                      } else {
                        let found = false;
                        for (const market in markets) {
                          if (
                            markets[market].baseAddress === token.address
                          ) {
                            setTokenIn(markets[market].quoteAddress);
                            newTokenIn = markets[market].quoteAddress;
                            found = true;
                            break;
                          }
                        }
                        if (!found) {
                          for (const market in markets) {
                            if (markets[market].quoteAddress === token.address) {
                              setTokenIn(markets[market].baseAddress);
                              newTokenIn = markets[market].baseAddress;
                              break;
                            }
                          }
                        }
                      }
                      setamountIn(
                        BigInt(0)
                      );
                      setInputString('')
                      setScaleStart(BigInt(0))
                      setScaleEnd(BigInt(0))
                      setScaleStartString('')
                      setScaleEndString('')
                      setlimitChase(true);
                      const percentage = !tokenBalances[newTokenIn]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              BigInt(0) /
                              tokenBalances[newTokenIn],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left =
                          `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                      }
                    } else {
                      setTokenIn(tokenOut);
                      setswitched((switched) => { return !switched });
                      if (amountIn != BigInt(0) && scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                        setInputString(outputString);
                        setoutputString(inputString);
                        setamountIn(amountOutSwap);
                        setamountOutSwap(amountIn);
                        const percentage = !tokenBalances[tokenOut]
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (amountOutSwap * BigInt(100)) /
                                tokenBalances[tokenOut],
                              ),
                            ),
                          );
                        setSliderPercent(percentage);
                        const slider = document.querySelector('.balance-amount-slider');
                        const popup = document.querySelector('.slider-percentage-popup');
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left =
                            `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                        }
                      }
                      else {
                        setamountIn(BigInt(0))
                        setInputString('')
                      }
                    }
                  }
                }}
              >
                <img className="tokenlistimage" src={token.image} />
                <div className="tokenlisttext">
                  <div className="tokenlistname">
                    {token.ticker}
                  </div>
                  <div className="tokenlistticker">{token.name}</div>
                </div>
                <div className="token-right-content">
                  <div className="tokenlistbalance">
                    {formatSubscript(customRound(
                      Number(tokenBalances[token.address] ?? 0) /
                      10 ** Number(token.decimals ?? 18),
                      3,
                    )
                      .replace(/(\.\d*?[1-9])0+$/g, '$1')
                      .replace(/\.0+$/, ''))}
                  </div>
                  <div className="token-address-container">
                    <span className="token-address">
                      {`${token.address.slice(0, 6)}...${token.address.slice(-4)}`}
                    </span>
                    <div
                      className="copy-address-button"
                      onClick={(e) => {
                        e.stopPropagation();
                        navigator.clipboard.writeText(token.address);
                        const copyIcon =
                          e.currentTarget.querySelector('.copy-icon');
                        const checkIcon =
                          e.currentTarget.querySelector('.check-icon');
                        if (copyIcon && checkIcon) {
                          copyIcon.classList.add('hidden');
                          checkIcon.classList.add('visible');
                          setTimeout(() => {
                            copyIcon.classList.remove('hidden');
                            checkIcon.classList.remove('visible');
                          }, 2000);
                        }
                      }}
                    >
                      <svg
                        className="copy-icon"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <rect
                          x="9"
                          y="9"
                          width="13"
                          height="13"
                          rx="2"
                          ry="2"
                        ></rect>
                        <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                      </svg>
                      <svg
                        className="check-icon"
                        viewBox="0 0 24 24"
                        fill="none"
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <circle cx="12" cy="12" r="10" />
                        <path d="M8 12l3 3 6-6" />
                      </svg>
                    </div>
                  </div>
                </div>
              </button>
            ))
        )}
      </ul>
    </div>
  );

  const [explorerFiltersActiveTab, setExplorerFiltersActiveTab] = useState<'new' | 'graduating' | 'graduated'>(() => {
    const saved = localStorage.getItem('crystal_explorer_active_tab');
    return (saved as 'new' | 'graduating' | 'graduated') || 'new';
  });

  const [explorerFiltersActiveSection, setExplorerFiltersActiveSection] = useState<'audit' | 'metrics' | 'socials'>(() => {
    const saved = localStorage.getItem('crystal_explorer_active_section');
    return (saved as 'audit' | 'metrics' | 'socials') || 'audit';
  });

  const handleOpenFiltersForColumn = useCallback((columnType: 'new' | 'graduating' | 'graduated') => {
    setExplorerFiltersActiveTab(columnType);
    setpopup(24);
  }, []);

  const initialExplorerFilters = {
    ageMin: '', ageMax: '',
    holdersMin: '', holdersMax: '',
    proTradersMin: '', proTradersMax: '',
    top10HoldingMin: '', top10HoldingMax: '',
    devHoldingMin: '', devHoldingMax: '',
    sniperHoldingMin: '', sniperHoldingMax: '',
    insiderHoldingMin: '', insiderHoldingMax: '',
    marketCapMin: '', marketCapMax: '',
    volume24hMin: '', volume24hMax: '',
    globalFeesMin: '', globalFeesMax: '',
    buyTransactionsMin: '', buyTransactionsMax: '',
    sellTransactionsMin: '', sellTransactionsMax: '',
    priceMin: '', priceMax: '',
    searchKeywords: '',
    excludeKeywords: '',
    hasWebsite: false,
    hasTwitter: false,
    hasTelegram: false
  };

  const [explorerFilters, setExplorerFilters] = useState(() => {
    const saved = localStorage.getItem('crystal_explorer_filters');
    if (saved) {
      const parsed = JSON.parse(saved);
      // Handle migration from old single filter to per-tab filters
      if (!parsed.new && !parsed.graduating && !parsed.graduated) {
        return {
          new: parsed,
          graduating: initialExplorerFilters,
          graduated: initialExplorerFilters
        };
      }
      return parsed;
    }
    return {
      new: initialExplorerFilters,
      graduating: initialExplorerFilters,
      graduated: initialExplorerFilters
    };
  });

  const [appliedExplorerFilters, setAppliedExplorerFilters] = useState(() => {
    const saved = localStorage.getItem('crystal_applied_explorer_filters');
    if (saved) {
      const parsed = JSON.parse(saved);
      // Handle migration from old single filter to per-tab filters
      if (!parsed.new && !parsed.graduating && !parsed.graduated) {
        return {
          new: null,
          graduating: null,
          graduated: null
        };
      }
      return parsed;
    }
    return {
      new: null,
      graduating: null,
      graduated: null
    };
  });

  useEffect(() => {
    localStorage.setItem('crystal_explorer_active_tab', explorerFiltersActiveTab);
  }, [explorerFiltersActiveTab]);

  useEffect(() => {
    localStorage.setItem('crystal_explorer_active_section', explorerFiltersActiveSection);
  }, [explorerFiltersActiveSection]);

  useEffect(() => {
    localStorage.setItem('crystal_explorer_filters', JSON.stringify(explorerFilters));
  }, [explorerFilters]);

  useEffect(() => {
    const hasAnyFilters = Object.values(appliedExplorerFilters).some(tabFilters => tabFilters !== null);
    if (hasAnyFilters) {
      localStorage.setItem('crystal_applied_explorer_filters', JSON.stringify(appliedExplorerFilters));
    } else {
      localStorage.removeItem('crystal_applied_explorer_filters');
    }
  }, [appliedExplorerFilters]);

  const handleExplorerFilterInputChange = useCallback((field: string, value: string | boolean) => {
    setExplorerFilters((prev: any) => ({
      ...prev,
      [explorerFiltersActiveTab]: {
        ...prev[explorerFiltersActiveTab],
        [field]: value
      }
    }));
  }, [explorerFiltersActiveTab]);

  const handleExplorerFiltersReset = useCallback(() => {
    setExplorerFilters({
      new: initialExplorerFilters,
      graduating: initialExplorerFilters,
      graduated: initialExplorerFilters
    });
    setAppliedExplorerFilters({
      new: null,
      graduating: null,
      graduated: null
    });
    setExplorerFiltersActiveTab('new');
    setExplorerFiltersActiveSection('audit');
    localStorage.removeItem('crystal_explorer_filters');
    localStorage.removeItem('crystal_applied_explorer_filters');
    localStorage.setItem('crystal_explorer_active_tab', 'new');
    localStorage.setItem('crystal_explorer_active_section', 'audit');
  }, []);

  const handleExplorerFiltersImport = useCallback(() => {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.json';
    input.onchange = (e) => {
      const file = (e.target as HTMLInputElement).files?.[0];
      if (file) {
        const reader = new FileReader();
        reader.onload = (e) => {
          try {
            const importedFilters = JSON.parse(e.target?.result as string);
            setExplorerFilters((prev: any) => ({
              ...prev,
              [explorerFiltersActiveTab]: importedFilters
            }));
          } catch (error) {
            alert('Invalid JSON file');
          }
        };
        reader.readAsText(file);
      }
    };
    input.click();
  }, [explorerFiltersActiveTab]);

  const handleExplorerFiltersExport = useCallback(() => {
    const dataStr = JSON.stringify(explorerFilters[explorerFiltersActiveTab], null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `explorer-filters-${explorerFiltersActiveTab}.json`;
    link.click();
    URL.revokeObjectURL(url);
  }, [explorerFilters, explorerFiltersActiveTab]);

  const handleExplorerFiltersApply = useCallback(() => {
    const newAppliedFilters = { ...appliedExplorerFilters };
    (['new', 'graduating', 'graduated'] as const).forEach(tab => {
      const tabFilters = explorerFilters[tab];
      const hasActiveFilters = Object.values(tabFilters).some(value =>
        value !== '' && value !== false && value !== null && value !== undefined
      );

      newAppliedFilters[tab] = hasActiveFilters ? tabFilters : null;
    });

    setAppliedExplorerFilters(newAppliedFilters);
    setpopup(0);
  }, [explorerFilters, appliedExplorerFilters]);

  const handleExplorerTabSwitch = useCallback((newTab: 'new' | 'graduating' | 'graduated') => {
    setExplorerFiltersActiveTab(newTab);
  }, []);

  const handleTokenClick = (token: any) => {
    if (setTokenData) {
      setTokenData(token);
    }
    navigate(`/meme/${token.tokenAddress}`);
    setpopup(0);
  };

  const handleQuickBuy = useCallback(async (token: any, amt: string) => {
    const val = BigInt(amt || '0') * 10n ** 18n;
    if (val === 0n) return;

    const routerAddress = settings.chainConfig[activechain]?.launchpadRouter?.toLowerCase();
    if (!routerAddress) {
      console.error('Router address not found');
      return;
    }

    const txId = `quickbuy-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;

    try {
      if (showLoadingPopup) {
        showLoadingPopup(txId, {
          title: 'Sending transaction...',
          subtitle: `${amt} MON worth of ${token.symbol}`,
          amount: amt,
          amountUnit: 'MON',
          tokenImage: token.image
        });
      }

      const uo = {
        target: routerAddress,
        data: encodeFunctionData({
          abi: CrystalRouterAbi,
          functionName: 'buy',
          args: [true, token.tokenAddress as `0x${string}`, val, 0n]
        }),
        value: val,
      };

      if (updatePopup) {
        updatePopup(txId, {
          title: 'Confirming transaction...',
          subtitle: `${amt} MON worth of ${token.symbol}`,
          variant: 'info',
          tokenImage: token.image
        });
      }

      await sendUserOperationAsync({ uo });

      if (terminalRefetch) {
        terminalRefetch();
      }

      if (updatePopup) {
        updatePopup(txId, {
          title: 'Quick Buy Complete',
          subtitle: `Successfully bought ${token.symbol} with ${amt} MON`,
          variant: 'success',
          confirmed: true,
          isLoading: false,
          tokenImage: token.image
        });
      }
    } catch (e: any) {
      console.error('Quick buy failed', e);
      const msg = String(e?.message ?? '');
      if (updatePopup) {
        updatePopup(txId, {
          title: msg.toLowerCase().includes('insufficient') ? 'Insufficient Balance' : 'Quick Buy Failed',
          subtitle: msg || 'Please try again.',
          variant: 'error',
          confirmed: true,
          isLoading: false,
          tokenImage: token.image
        });
      }
    }
  }, [sendUserOperationAsync, activechain, terminalRefetch]);

  //popup modals
  const Modals = (
    <>
      <div className={`blur-background-popups ${popup != 0 ? 'active' : ''}`}>
        {popup === 1 ? ( // token select
          <div ref={popupref} className="tokenselectbg">
            <button
              className="tokenselect-close-button"
              onClick={() => {
                setpopup(0);
                settokenString('');
              }}
            >
              <img src={closebutton} className="close-button-icon" />
            </button>
            <div className="tokenselectheader1">{t('selectAToken')}</div>
            <div className="tokenselectheader2">{t('selectTokenSubtitle')}</div>
            <div className="tokenselectheader-divider"></div>
            <div style={{ position: 'relative' }}>
              <input
                className="tokenselect"
                onChange={(e) => {
                  settokenString(e.target.value);
                }}
                onKeyDown={handleTokenSelectKeyDown}
                placeholder={t('searchToken')}
                autoFocus={!(windowWidth <= 1020)}
              />
              {tokenString && (
                <button
                  className="tokenselect-clear visible"
                  onClick={() => {
                    settokenString('');
                    const input = document.querySelector(
                      '.tokenselect',
                    ) as HTMLInputElement;
                    if (input) {
                      input.value = '';
                      input.focus();
                    }
                  }}
                >
                  {t('clear')}
                </button>
              )}
            </div>
            {TokenList1}
          </div>
        ) : null}
        {popup === 2 ? ( // token select
          <div ref={popupref} className="tokenselectbg" >
            <button
              className="tokenselect-close-button"
              onClick={() => {
                setpopup(0);
                settokenString('');
              }}
            >
              <img src={closebutton} className="close-button-icon" />
            </button>
            <div className="tokenselectheader1">{t('selectAToken')}</div>
            <div className="tokenselectheader2">{t('selectTokenSubtitle')}</div>
            <div style={{ position: 'relative' }}>
              <input
                className="tokenselect"
                onChange={(e) => {
                  settokenString(e.target.value);
                }}
                onKeyDown={handleTokenSelectKeyDown}
                placeholder={t('searchToken')}
                autoFocus={!(windowWidth <= 1020)}
              />
              {tokenString && (
                <button
                  className="tokenselect-clear visible"
                  onClick={() => {
                    settokenString('');
                    const input = document.querySelector(
                      '.tokenselect',
                    ) as HTMLInputElement;
                    if (input) {
                      input.value = '';
                      input.focus();
                    }
                  }}
                >
                  {t('clear')}
                </button>
              )}
            </div>
            {TokenList2}
          </div>
        ) : null}
        {popup === 3 ? ( // send popup
          <div ref={popupref} className="send-popup-container">
            <div className="send-popup-background">
              <div className={`sendbg ${connected && sendAmountIn > tokenBalances[sendTokenIn] ? 'exceed-balance' : ''}`}>

                <div className="sendbutton1container">
                  <div className="send-Send">{t('send')}</div>
                  <button
                    className="send-button1"
                    onClick={() => {
                      setpopup(10);
                    }}
                  >
                    <img className="send-button1pic" src={tokendict[sendTokenIn].image} />
                    <span>{tokendict[sendTokenIn].ticker || '?'}</span>
                  </button>

                </div>
                <div className="sendinputcontainer">
                  <input
                    inputMode="decimal"
                    className={`send-input ${connected && sendAmountIn > tokenBalances[sendTokenIn] ? 'exceed-balance' : ''}`}
                    onCompositionStart={() => {
                      setIsComposing(true);
                    }}
                    onCompositionEnd={(
                      e: React.CompositionEvent<HTMLInputElement>,
                    ) => {
                      setIsComposing(false);
                      if (/^\$?\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                        if (displayMode == 'usd') {
                          if (e.currentTarget.value == '$') {
                            setSendUsdValue('');
                            setSendInputAmount('');
                            setSendAmountIn(BigInt(0));
                          } else {
                            setSendUsdValue(`$${e.currentTarget.value.replace(/^\$/, '')}`);
                            const calculatedAmount = calculateTokenAmount(
                              e.currentTarget.value.replace(/^\$/, ''),
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            );
                            setSendAmountIn(calculatedAmount);
                            setSendInputAmount(
                              customRound(
                                Number(calculatedAmount) / 10 ** Number(tokendict[sendTokenIn].decimals),
                                3,
                              ).toString()
                            );
                          }
                        } else {
                          const inputValue = BigInt(
                            Math.round((parseFloat(e.currentTarget.value || '0') || 0) * 10 ** Number(tokendict[sendTokenIn].decimals))
                          );
                          setSendAmountIn(inputValue);
                          setSendInputAmount(e.currentTarget.value);
                          setSendUsdValue(
                            `$${calculateUSDValue(
                              inputValue,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            ).toFixed(2)}`
                          );
                        }
                      }
                    }}
                    onChange={(e) => {
                      if (isComposing) {
                        setSendInputAmount(e.target.value);
                        return;
                      }
                      if (/^\$?\d*\.?\d{0,18}$/.test(e.target.value)) {
                        if (displayMode == 'usd') {
                          if (e.target.value == '$') {
                            setSendUsdValue('');
                            setSendInputAmount('');
                            setSendAmountIn(BigInt(0));
                          } else {
                            setSendUsdValue(`$${e.target.value.replace(/^\$/, '')}`);
                            const calculatedAmount = calculateTokenAmount(
                              e.target.value.replace(/^\$/, ''),
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            );
                            setSendAmountIn(calculatedAmount);
                            setSendInputAmount(
                              customRound(
                                Number(calculatedAmount) / 10 ** Number(tokendict[sendTokenIn].decimals),
                                3,
                              ).toString()
                            );
                          }
                        } else {
                          const inputValue = BigInt(
                            Math.round((parseFloat(e.target.value || '0') || 0) * 10 ** Number(tokendict[sendTokenIn].decimals))
                          );
                          setSendAmountIn(inputValue);
                          setSendInputAmount(e.target.value);
                          setSendUsdValue(
                            `$${calculateUSDValue(
                              inputValue,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            ).toFixed(2)}`
                          );
                        }
                      }
                    }}
                    placeholder={displayMode == 'usd' ? '$0.00' : '0.00'}
                    value={displayMode == 'usd' ? sendUsdValue : sendInputAmount}
                    autoFocus={!(windowWidth <= 1020)}
                  />
                </div>
                <div className="send-balance-wrapper">
                  <div className="send-balance-max-container">
                    <div className="send-balance1">
                      <img src={walleticon} className="send-balance-wallet-icon" />{' '}
                      {formatDisplayValue(tokenBalances[sendTokenIn], Number(tokendict[sendTokenIn].decimals))}
                    </div>
                    <div
                      className="send-max-button"
                      onClick={() => {
                        if (tokenBalances[sendTokenIn] != BigInt(0)) {
                          let amount =
                            (sendTokenIn == eth && !client)
                              ? tokenBalances[sendTokenIn] - settings.chainConfig[activechain].gasamount > BigInt(0)
                                ? tokenBalances[sendTokenIn] - settings.chainConfig[activechain].gasamount
                                : BigInt(0)
                              : tokenBalances[sendTokenIn];
                          setSendAmountIn(amount);
                          setSendInputAmount(
                            customRound(Number(amount) / 10 ** Number(tokendict[sendTokenIn].decimals), 3).toString()
                          );
                          setSendUsdValue(
                            `$${calculateUSDValue(
                              amount,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            ).toFixed(2)}`
                          );
                        }
                      }}
                    >
                      {t('max')}
                    </div>
                  </div>
                  <div
                    className="send-usd-switch-wrapper"
                    onClick={() => {
                      if (displayMode === 'usd') {
                        setDisplayMode('token');
                        if (parseFloat(sendUsdValue.replace(/^\$|,/g, '')) == 0) {
                          setSendInputAmount('');
                        }
                      } else {
                        setDisplayMode('usd');
                        if (parseFloat(sendInputAmount) == 0) {
                          setSendUsdValue('');
                        }
                      }
                    }}
                  >
                    <div className="send-usd-value">
                      {displayMode === 'usd'
                        ? `${customRound(Number(sendAmountIn) / 10 ** Number(tokendict[sendTokenIn].decimals), 3)} ${tokendict[sendTokenIn].ticker}`
                        : sendAmountIn === BigInt(0)
                          ? '$0.00'
                          : formatUSDDisplay(
                            calculateUSDValue(
                              sendAmountIn,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            )
                          )}
                    </div>
                    <img src={sendSwitch} className="send-arrow" />
                  </div>
                </div>
              </div>
              <div className="sendaddressbg">
                <div className="send-To">{t('to')}</div>
                <div className="send-address-input-container">
                  <input
                    className="send-output"
                    onChange={(e) => {
                      if (e.target.value === '' || /^(0x[0-9a-fA-F]{0,40}|0)$/.test(e.target.value)) {
                        setrecipient(e.target.value);
                      }
                    }}
                    value={recipient}
                    placeholder={t('enterWalletAddress')}
                  />
                  <button
                    className="address-paste-button"
                    onClick={async () => {
                      try {
                        const text = await navigator.clipboard.readText();
                        if (/^(0x[0-9a-fA-F]{40})$/.test(text)) {
                          setrecipient(text);
                        }
                      } catch (err) {
                      }
                    }}
                  >
                    <svg
                      width="16"
                      height="16"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    >
                      <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                      <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                    </svg>
                  </button>
                </div>
              </div>
              <button
                className={`send-swap-button ${isSigning ? 'signing' : ''}`}
                onClick={async () => {
                  if (
                    connected &&
                    userchain === activechain
                  ) {
                    let hash: any;
                    setIsSigning(true)
                    if (client) {
                      txPending.current = true
                    }
                    try {
                      if (sendTokenIn == eth) {
                        hash = await sendUserOperationAsync({
                          uo: sendeth(
                            recipient as `0x${string}`,
                            sendAmountIn,
                          )
                        });
                        if (!client) {
                          txPending.current = true
                        }
                        newTxPopup(
                          (hash),
                          'send',
                          eth,
                          '',
                          customRound(
                            Number(sendAmountIn) / 10 ** Number(tokendict[eth].decimals),
                            3,
                          ),
                          0,
                          '',
                          recipient,
                        );
                      } else {
                        hash = await sendUserOperationAsync({
                          uo: sendtokens(
                            sendTokenIn as `0x${string}`,
                            recipient as `0x${string}`,
                            sendAmountIn,
                          )
                        });
                        if (!client) {
                          txPending.current = true
                        }
                        newTxPopup(
                          (hash),
                          'send',
                          sendTokenIn,
                          '',
                          customRound(
                            Number(sendAmountIn) /
                            10 ** Number(tokendict[sendTokenIn].decimals),
                            3,
                          ),
                          0,
                          '',
                          recipient,
                        );
                      }
                      setSendUsdValue('')
                      setSendInputAmount('');
                      setSendAmountIn(BigInt(0));
                      setSendPopupButton(0);
                      setSendPopupButtonDisabled(true);
                      setIsSigning(false)
                      await refetch()
                      txPending.current = false
                    } catch (error) {
                      if (!(error instanceof TransactionExecutionError)) {
                        newTxPopup(
                          hash,
                          "sendFailed",
                          sendTokenIn === eth ? eth : sendTokenIn,
                          "",
                          customRound(
                            Number(sendAmountIn) / 10 ** Number(tokendict[sendTokenIn === eth ? eth : sendTokenIn].decimals),
                            3,
                          ),
                          0,
                          "",
                          recipient,
                        );
                      }
                    } finally {
                      txPending.current = false
                      setIsSigning(false)
                    }
                  } else {
                    !connected
                      ? setpopup(4)
                      : handleSetChain()
                  }
                }}
                disabled={sendPopupButtonDisabled || isSigning}
              >
                {isSigning ? (
                  <div className="button-content">
                    <div className="loading-spinner" />
                    {validOneCT ? t('') : t('signTransaction')}
                  </div>
                ) : !connected ? (
                  t('connectWallet')
                ) : sendPopupButton == 0 ? (
                  t('enterAmount')
                ) : sendPopupButton == 1 ? (
                  t('enterWalletAddress')
                ) : sendPopupButton == 2 ? (
                  t('send')
                ) : sendPopupButton == 3 ? (
                  t('insufficient') +
                  (tokendict[sendTokenIn].ticker || '?') +
                  ' ' +
                  t('bal')
                ) : sendPopupButton == 4 ? (
                  `${t('switchto')} ${t(settings.chainConfig[activechain].name)}`
                ) : (
                  t('connectWallet')
                )}
              </button>
            </div>
          </div>
        ) : null}
        {popup === 4 ? (
          !connected ? (
            <div ref={popupref} className="connect-wallet-background unconnected">
              <div className="connect-wallet-content-container">
                <AuthCard {...alchemyconfig.ui.auth} />
              </div>
            </div>
          ) : (
            <div ref={popupref} className="connect-wallet-background connected">
              <div className="wallet-header">
                <div className="wallet-info"
                  onMouseEnter={() =>
                    !copyTooltipVisible && setShowHoverTooltip(true)
                  }
                  onMouseLeave={() => setShowHoverTooltip(false)}
                  onClick={(e) => {
                    e.stopPropagation();
                    navigator.clipboard.writeText(
                      address || '',
                    );
                    setShowHoverTooltip(false);
                    setCopyTooltipVisible(true);
                    setTimeout(() => {
                      setCopyTooltipVisible(false);
                    }, 2000);
                  }}>
                  {connected &&
                    address && (
                      <>
                        <div
                          className="wallet-popup-address-container"
                        >
                          <span
                            className={`wallet-popup-address`}
                          >
                            <img
                              src={getWalletIcon()}
                              className="port-popup-wallet-icon"
                            />
                            {`${address.slice(0, 6)}...${address.slice(-4)}`}
                          </span>

                          {copyTooltipVisible && (
                            <div className="wallet-popup-copy-tooltip">
                              {t('copied')}!
                            </div>
                          )}
                          {!copyTooltipVisible && showHoverTooltip && (
                            <div className="wallet-popup-hover-tooltip">
                              {t('clickCopyAddress')}
                            </div>
                          )}
                        </div>
                      </>
                    )}
                </div>
                <button
                  className={`eye-button ${!isBlurred ? '' : 'h'}`}
                  onClick={() => setIsBlurred(!isBlurred)}
                >
                  <div className="eye-icon-container">
                    <svg
                      className="eye-icon"
                      viewBox="0 0 24 24"
                      fill="none"
                    >
                      <path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" />
                      <circle cx="12" cy="12" r="3" />
                    </svg>
                    <div className="eye-slash" />
                  </div>
                </button>
                <button
                  className="popup-deposit-button"
                  onClick={() => {
                    setpopup(12)
                  }}
                >
                  <svg
                    className="deposit-icon"
                    viewBox="0 0 24 24"
                    width="24"
                    height="24"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  >
                    <polyline points="7 11 12 16 17 11"></polyline>
                    <line x1="12" y1="1" x2="12" y2="14"></line>
                    <path d="M22 14V19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V14" />

                  </svg>
                </button>
                <button
                  className="popup-disconnect-button"
                  onClick={() => {
                    setOneCTSigner('')
                    logout()
                  }}
                >
                  <svg
                    className="disconnect-icon"
                    viewBox="0 0 24 24"
                    width="24"
                    height="24"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  >
                    <path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path>
                    <polyline points="16 17 21 12 16 7"></polyline>
                    <line x1="21" y1="12" x2="9" y2="12"></line>
                  </svg>
                </button>
                <div className="header-actions">
                  <button
                    className="connect-wallet-close-button"
                    onClick={() => {
                      setpopup(0);
                      settokenString('');
                    }}
                  >
                    <img src={closebutton} className="close-button-icon" />
                  </button>
                </div>
              </div>
              {portChartLoading ? (
                <div
                  className="portfolio-popup-graph"
                  style={{ marginTop: 15, marginBottom: 10, height: 215 }}
                >
                  <LoadingOverlay
                    isVisible={true}
                    bgcolor={'#00000000'}
                    height={30}
                  />
                </div>
              ) : (
                <>
                  <div className="total-account-summary-value">
                    <div
                      className={`total-value ${isBlurred ? 'blurred' : ''}`}
                    >
                      ${typeof totalAccountValue === 'number' ? formatCommas(totalAccountValue.toFixed(2)) : '0.00'}
                    </div>
                    <div
                      className={`percentage-change ${isBlurred ? 'blurred' : ''} ${percentage >= 0 ? 'positive' : 'negative'}`}
                    >
                      {percentage >= 0 ? '+' : ''}
                      {percentage.toFixed(2)}%
                    </div>
                  </div>
                  <div className="portfolio-popup-graph">
                    <PortfolioPopupGraph
                      address={address ?? ''}
                      onPercentageChange={setPercentage}
                      colorValue={portfolioColorValue}
                      setColorValue={setPortfolioColorValue}
                      isPopup={true}
                      chartData={typeof totalAccountValue === 'number' ? [
                        ...portGraph.slice(0, -1),
                        {
                          ...portGraph[portGraph.length - 1],
                          value: totalAccountValue,
                        },
                      ] : portGraph}
                      portChartLoading={portChartLoading}
                      chartDays={chartDays}
                      setChartDays={setChartDays}
                      isBlurred={isBlurred}
                    />
                  </div>
                </>
              )}
              <div className="graph-assets-divider" />
              <div className="portfolio-content-popup">
                <PortfolioContent
                  tokenList={Object.values(tokendict)}
                  onMarketSelect={onMarketSelect}
                  setSendTokenIn={setSendTokenIn}
                  setpopup={setpopup}
                  sortConfig={memoizedSortConfig}
                  tokenBalances={tokenBalances}
                  marketsData={marketsData}
                  isBlurred={isBlurred}
                />
              </div>
            </div>
          )
        ) : null}
        {popup === 5 ? ( // settings
          <div
            className="layout-settings-background"
            ref={popupref}
          >
            <div className="layout-settings-header">
              <button
                className="layout-settings-close-button"
                onClick={() => setpopup(0)}
              >
                <img src={closebutton} className="close-button-icon" />
              </button>
              <div className="layout-settings-title">{t('settings')}</div>
            </div>

            <div className="settings-main-container">
              <div className="settings-sidebar">
                <div className="settings-section-buttons">
                  <button
                    className={`settings-section-button ${activeSettingsSection === 'general' ? 'active' : ''}`}
                    onClick={() => updateActiveSettingsSection('general')}
                  >
                    <span>{t('general')}</span>
                  </button>
                  {windowWidth >= 1020 && (
                    <button
                      className={`settings-section-button ${activeSettingsSection === 'layout' ? 'active' : ''}`}
                      onClick={() => updateActiveSettingsSection('layout')}
                    >
                      <span>{t('tradingLayout')}</span>
                    </button>
                  )}
                  <button
                    className={`settings-section-button ${activeSettingsSection === 'display' ? 'active' : ''}`}
                    onClick={() => updateActiveSettingsSection('display')}
                  >
                    <span>{t('tradingSettings')}</span>
                  </button>
                  <button
                    className={`settings-section-button ${activeSettingsSection === 'audio' ? 'active' : ''}`}
                    onClick={() => updateActiveSettingsSection('audio')}
                  >
                    <span>{t('notifications')}</span>
                  </button>
                  <button
                    className={`settings-section-button ${activeSettingsSection === 'keybinds' ? 'active' : ''}`}
                    onClick={() => updateActiveSettingsSection('keybinds')}
                  >
                    <span>{t('keybinds')}</span>
                  </button>
                </div>

                <button
                  className="revert-settings-button sidebar-revert-button"
                  onClick={() => {
                    setLanguage('EN');
                    localStorage.setItem('crystal_language', 'EN');

                    setHideNotificationPopups(false);
                    localStorage.setItem('crystal_hide_notification_popups', 'false');

                    setNotificationPosition('bottom-right');
                    localStorage.setItem('crystal_notification_position', 'bottom-right');

                    setHiddenPopupTypes({});
                    localStorage.setItem('crystal_hidden_popup_types', JSON.stringify({}));

                    setSpotLayoutSettings('default');
                    localStorage.setItem('crystal_layout', 'default');

                    setSpotOrderbookPosition('right');
                    localStorage.setItem('crystal_orderbook', 'right');

                    setIsMarksVisible(true);
                    localStorage.setItem('crystal_marks_visible', 'true');

                    setIsOrdersVisible(true);
                    localStorage.setItem('crystal_orders_visible', 'true');

                    setHideNotificationPopups(false);
                    localStorage.setItem('crystal_hide_notification_popups', 'false');

                    setIsOrderbookVisible(true);
                    localStorage.setItem('crystal_orderbook_visible', 'true');

                    setIsOrderCenterVisible(true);
                    localStorage.setItem(
                      'crystal_ordercenter_visible',
                      'true',
                    );

                    setShowChartOutliers(false);
                    localStorage.setItem('crystal_show_chart_outliers', 'false');

                    setIsAudioEnabled(false);
                    localStorage.setItem('crystal_audio_notifications', 'false');

                    setOrderbookWidth(300);
                    localStorage.setItem('orderbookWidth', '300');

                    setAddLiquidityOnly(false);
                    localStorage.setItem(
                      'crystal_add_liquidity_only',
                      'false',
                    );

                    setorderType(1);
                    localStorage.setItem('crystal_order_type', '1');

                    setSlippageString('1');
                    setSlippage(BigInt(9900));
                    localStorage.setItem('crystal_slippage_string', '1');
                    localStorage.setItem('crystal_slippage', '9900');

                    setActiveSection('orders');
                    localStorage.setItem('crystal_oc_tab', 'orders');

                    setFilter('all');
                    localStorage.setItem('crystal_oc_filter', 'all');

                    setOnlyThisMarket(false);
                    localStorage.setItem('crystal_only_this_market', 'false');

                    setOBInterval(baseInterval);
                    localStorage.setItem(
                      `${activeMarket.baseAsset}_ob_interval`,
                      JSON.stringify(baseInterval),
                    );

                    const currentKey = `${activeMarket.baseAsset}_ob_interval`;
                    for (let i = localStorage.length - 1; i >= 0; i--) {
                      const key = localStorage.key(i);
                      if (
                        key &&
                        key.endsWith('_ob_interval') &&
                        key !== currentKey
                      ) {
                        localStorage.removeItem(key);
                      }
                    }

                    setViewMode('both');
                    localStorage.setItem('ob_viewmode', 'both');

                    setOBTab('orderbook');
                    localStorage.setItem('ob_active_tab', 'orderbook');

                    setMobileView('chart');

                    setAmountsQuote('Quote');
                    localStorage.setItem('ob_amounts_quote', 'Quote');

                    localStorage.setItem('crystal_chart_timeframe', '5')

                    let defaultHeight: number;

                    if (window.innerHeight > 1080) defaultHeight = 367.58;
                    else if (window.innerHeight > 960) defaultHeight = 324.38;
                    else if (window.innerHeight > 840) defaultHeight = 282.18;
                    else if (window.innerHeight > 720) defaultHeight = 239.98;
                    else defaultHeight = 198.78;

                    setOrderCenterHeight(defaultHeight);
                    localStorage.setItem(
                      'orderCenterHeight',
                      defaultHeight.toString(),
                    );
                  }}
                >
                  {t('revertToDefault')}
                </button>
              </div>

              <div className="right-side-settings-panel">
                <div className="settings-content-panel">
                  {activeSettingsSection === 'general' && (
                    <div className="settings-section-content">
                      <div className="layout-language-row">
                        <span className="layout-language-label">{t('language')}</span>
                        <div className="settings-section-subtitle">
                          {t('selectPreferredLanguage')}
                        </div>
                        <div className="language-selector-app-container">
                          <div className="language-grid">
                            {languageOptions.map((lang) => (
                              <button
                                key={lang.code}
                                className={`language-grid-item ${language === lang.code ? 'active' : ''}`}
                                onClick={() => {
                                  setLanguage(lang.code);
                                  localStorage.setItem('crystal_language', lang.code);
                                }}
                              >
                                {lang.name}
                              </button>
                            ))}
                          </div>
                        </div>
                      </div>
                      <div className="slider-settings-section">
                        <div className="settings-subsection">
                          <div className="layout-section-title">{t('balanceSliderMode')}</div>
                          <div className="settings-section-subtitle">
                            {t('chooseBalancePercentages')}
                          </div>

                          <div className="slider-mode-options">
                            <button
                              className={`control-layout-option ${('spot' === 'spot' ? spotSliderMode : trenchesSliderMode) === 'slider' ? 'active' : ''}`}
                              onClick={() => {
                                if ('spot' === 'spot') {
                                  setSpotSliderMode('slider');
                                  localStorage.setItem('crystal_spot_slider_mode', 'slider');
                                } else {
                                  setTrenchesSliderMode('slider');
                                  localStorage.setItem('crystal_trenches_slider_mode', 'slider');
                                }
                              }}
                            >
                              <div className="layout-label">
                                <span className="control-layout-name">{t('slider')}</span>
                              </div>
                            </button>

                            <button
                              className={`control-layout-option ${('spot' === 'spot' ? spotSliderMode : trenchesSliderMode) === 'presets' ? 'active' : ''}`}
                              onClick={() => {
                                if ('spot' === 'spot') {
                                  setSpotSliderMode('presets');
                                  localStorage.setItem('crystal_spot_slider_mode', 'presets');
                                } else {
                                  setTrenchesSliderMode('presets');
                                  localStorage.setItem('crystal_trenches_slider_mode', 'presets');
                                }
                              }}
                            >
                              <div className="layout-label">
                                <span className="control-layout-name">{t('presets')}</span>
                              </div>
                            </button>

                            <button
                              className={`control-layout-option ${('spot' === 'spot' ? spotSliderMode : trenchesSliderMode) === 'increment' ? 'active' : ''}`}
                              onClick={() => {
                                if ('spot' === 'spot') {
                                  setSpotSliderMode('increment');
                                  localStorage.setItem('crystal_spot_slider_mode', 'increment');
                                } else {
                                  setTrenchesSliderMode('increment');
                                  localStorage.setItem('crystal_trenches_slider_mode', 'increment');
                                }
                              }}
                            >
                              <div className="layout-label">
                                <span className="control-layout-name">{t('increment')}</span>
                              </div>
                            </button>
                          </div>
                        </div>

                        {('spot' === 'spot' ? spotSliderMode : trenchesSliderMode) === 'presets' && (
                          <div className="settings-subsection">
                            <div className="layout-section-title">{t('presetPercentages')}</div>
                            <div className="settings-section-subtitle">
                              {t('setThreeFavoritePercentages')}
                            </div>
                            <div className="preset-inputs">
                              {('spot' === 'spot' ? spotSliderPresets : trenchesSliderPresets).map((preset: number, index: number) => (
                                <div key={index} className="preset-input-group">
                                  <label className="preset-label">{t('preset')} {index + 1}</label>
                                  <div className="preset-input-container">
                                    <input
                                      type="text"
                                      value={preset === 0 ? '' : preset.toString()}
                                      onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                                        const inputValue = e.target.value;
                                        const currentPresets = 'spot' === 'spot' ? spotSliderPresets : trenchesSliderPresets;
                                        const setCurrentPresets = 'spot' === 'spot' ? setSpotSliderPresets : setTrenchesSliderPresets;
                                        const storageKey = 'spot' === 'spot' ? 'crystal_spot_slider_presets' : 'crystal_trenches_slider_presets';

                                        if (inputValue === '') {
                                          const newPresets = [...currentPresets];
                                          newPresets[index] = 0;
                                          setCurrentPresets(newPresets);
                                          localStorage.setItem(storageKey, JSON.stringify(newPresets));
                                        } else if (/^\d*\.?\d*$/.test(inputValue)) {
                                          const numValue = parseFloat(inputValue);
                                          if (!isNaN(numValue) && numValue >= 0 && numValue <= 100) {
                                            const newPresets = [...currentPresets];
                                            newPresets[index] = numValue;
                                            setCurrentPresets(newPresets);
                                            localStorage.setItem(storageKey, JSON.stringify(newPresets));
                                          }
                                        }
                                      }}
                                      placeholder="0"
                                      className="preset-input"
                                    />
                                    <span className="preset-unit">%</span>
                                  </div>
                                </div>
                              ))}
                            </div>
                          </div>
                        )}

                        {('spot' === 'spot' ? spotSliderMode : trenchesSliderMode) === 'increment' && (
                          <div className="settings-subsection">
                            <div className="layout-section-title">{t('incrementAmount')}</div>
                            <div className="settings-section-subtitle">
                              {t('setIncrementAmount')}
                            </div>
                            <div className="increment-input-group">
                              <div className="increment-input-container">
                                <div className="percentage-input-wrapper">
                                  <input
                                    type="text"
                                    value={('spot' === 'spot' ? spotSliderIncrement : trenchesSliderIncrement) === 0 ? '' : ('spot' === 'spot' ? spotSliderIncrement : trenchesSliderIncrement).toString()}
                                    onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                                      const inputValue = e.target.value;
                                      const setCurrentIncrement = 'spot' === 'spot' ? setSpotSliderIncrement : setTrenchesSliderIncrement;
                                      const storageKey = 'spot' === 'spot' ? 'crystal_spot_slider_increment' : 'crystal_trenches_slider_increment';

                                      if (inputValue === '') {
                                        setCurrentIncrement(0);
                                        localStorage.setItem(storageKey, '0');
                                      } else if (/^\d*\.?\d{0,2}$/.test(inputValue)) {
                                        const numValue = parseFloat(inputValue || '0') || 0;
                                        if (numValue <= 50) {
                                          setCurrentIncrement(numValue);
                                          localStorage.setItem(storageKey, numValue.toString());
                                        }
                                      }
                                    }}
                                    placeholder="10"
                                    className="percentage-input"
                                  />
                                  <span className="percentage-input-suffix">%</span>
                                </div>
                              </div>
                            </div>
                          </div>
                        )}
                        <div className="settings-subsection">
                          <div className="layout-section-title">
                            {t('customRPCGraphAPI')}
                          </div>
                          <div className="settings-section-subtitle">
                            {t('specifyCustomEndpoints')}
                          </div>

                          <div className="custom-rpc-settings">
                            <div className="input-group">
                              <label className="input-label">{t('rpcURL')}</label>
                              <input
                                type="text"
                                className="input-field"
                                value={rpcUrl}
                                placeholder="https://testnet-rpc.monad.xyz"
                                onChange={e => {
                                  setRpcUrl(e.target.value)
                                  localStorage.setItem('crystal_rpc_url', e.target.value)
                                }}
                              />
                            </div>

                            <div className="input-group">
                              <label className="input-label">{t('graphAPIURL')}</label>
                              <input
                                type="text"
                                className="input-field"
                                value={graphUrl}
                                placeholder="https://gateway.thegraph.com/api/YOUR_API_KEY/subgraphs/id/..."
                                onChange={e => {
                                  setGraphUrl(e.target.value)
                                  localStorage.setItem('crystal_graph_url', e.target.value)
                                }}
                              />
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  )}
                  {activeSettingsSection === 'layout' && (
                    <div className="settings-section-content">
                      {/* Trading Mode Selector */}
                      <div className="layout-options">
                        <div>
                          <div className="layout-section-title">
                            {t('tradingModeSettings')}
                          </div>
                          <div className="settings-section-subtitle">
                            {t('configureEachModeIndependently')}
                          </div>
                          <div className="layout-section" style={{ display: 'flex', gap: '12px' }}>
                            <button
                              className={`control-layout-option ${activeTradingMode === 'spot' ? 'active' : ''}`}
                              onClick={() => {
                                setActiveTradingMode('spot');
                                localStorage.setItem('crystal_trading_mode', 'spot');
                              }}
                              style={{ flex: 1 }}
                            >
                              <div className="layout-label">
                                <span className="control-layout-name">{t('spot')}</span>
                              </div>
                            </button>

                            <button
                              className={`control-layout-option ${activeTradingMode === 'perps' ? 'active' : ''}`}
                              onClick={() => {
                                setActiveTradingMode('perps');
                                localStorage.setItem('crystal_trading_mode', 'perps');
                              }}
                              style={{ flex: 1 }}
                            >
                              <div className="layout-label">
                                <span className="control-layout-name">{t('perps')}</span>
                              </div>
                            </button>

                            <button
                              className={`control-layout-option ${activeTradingMode === 'spectra' ? 'active' : ''}`}
                              onClick={() => {
                                setActiveTradingMode('spectra');
                                localStorage.setItem('crystal_trading_mode', 'spectra');
                              }}
                              style={{ flex: 1 }}
                            >
                              <div className="layout-label">
                                <span className="control-layout-name">{t('spectra')}</span>
                              </div>
                            </button>
                          </div>
                        </div>
                      </div>

                      {/* Trade Panel Position - only show for spot/perps, not spectra */}
                      {!simpleView && activeTradingMode !== 'spectra' && (
                        <div className="layout-options">
                          <div>
                            <div className="layout-section-title">
                              {t('tradePanelPosition')} ({activeTradingMode === 'spot' ? t('spot') : t('perps')})
                            </div>
                            <div className="settings-section-subtitle">
                              {t('chooseTradingPanelPosition')}
                            </div>
                            <div className="layout-section">
                              <button
                                className={`layout-option ${getActiveLayoutSettings() === 'alternative' ? 'active' : ''}`}
                                onClick={() => {
                                  if (activeTradingMode === 'perps') {
                                    setPerpsLayoutSettings('alternative');
                                    localStorage.setItem('crystal_perps_layout', 'alternative');
                                  } else {
                                    setSpotLayoutSettings('alternative');
                                    localStorage.setItem('crystal_spot_layout', 'alternative');
                                  }
                                }}
                              >
                                <div className="layout-preview-container">
                                  <div className="preview-trade"></div>
                                  <div className="layout-preview-wrapper">
                                    <div className="layout-preview alternative-layout">
                                      <div className="preview-chart"></div>
                                      <div className="preview-orderbook"></div>
                                    </div>
                                    <div className="layout-preview-bottom">
                                      <div className="preview-ordercenter"></div>
                                    </div>
                                  </div>
                                </div>
                                <div className="layout-label">
                                  <span className="layout-name">
                                    {t('left')} {t('panel')}
                                  </span>
                                </div>
                              </button>

                              <button
                                className={`layout-option ${getActiveLayoutSettings() === 'default' ? 'active' : ''}`}
                                onClick={() => {
                                  if (activeTradingMode === 'perps') {
                                    setPerpsLayoutSettings('default');
                                    localStorage.setItem('crystal_perps_layout', 'default');
                                  } else {
                                    setSpotLayoutSettings('default');
                                    localStorage.setItem('crystal_spot_layout', 'default');
                                  }
                                }}
                              >
                                <div className="layout-preview-container">
                                  <div className="layout-preview-wrapper">
                                    <div className="layout-preview alternative-layout">
                                      <div className="preview-chart" />
                                      <div className="preview-orderbook" />
                                    </div>
                                    <div className="layout-preview-bottom">
                                      <div className="preview-ordercenter" />
                                    </div>
                                  </div>
                                  <div className="preview-trade" />
                                </div>

                                <div className="layout-label">
                                  <span className="layout-name">
                                    {t('right')} {t('panel')}
                                  </span>
                                </div>
                              </button>
                            </div>
                          </div>

                          {/* Orderbook Position */}
                          <div>
                            <div className="layout-section-title">
                              {t('orderbookPosition')} ({activeTradingMode === 'spot' ? t('spot') : t('perps')})
                            </div>
                            <div className="settings-section-subtitle">
                              {t('positionOrderbookSide')}
                            </div>
                            <div className="layout-section">
                              <button
                                className={`layout-option ${getActiveOrderbookPosition() === 'left' ? 'active' : ''}`}
                                onClick={() => {
                                  if (activeTradingMode === 'perps') {
                                    setPerpsOrderbookPosition('left');
                                    localStorage.setItem('crystal_perps_orderbook', 'left');
                                  } else {
                                    setSpotOrderbookPosition('left');
                                    localStorage.setItem('crystal_spot_orderbook', 'left');
                                  }
                                }}
                              >
                                <div className="ob-layout-preview-container">
                                  <div className="ob-layout-preview alternative-layout">
                                    <div className="ob-preview-orderbook">
                                      <div className="ob-preview-sell"></div>
                                      <div className="ob-preview-buy"></div>
                                    </div>
                                    <div className="ob-preview-chart"></div>
                                  </div>
                                </div>
                                <div className="layout-label">
                                  <span className="layout-name">
                                    {t('left')} {t('side')}
                                  </span>
                                </div>
                              </button>

                              <button
                                className={`layout-option ${getActiveOrderbookPosition() === 'right' ? 'active' : ''}`}
                                onClick={() => {
                                  if (activeTradingMode === 'perps') {
                                    setPerpsOrderbookPosition('right');
                                    localStorage.setItem('crystal_perps_orderbook', 'right');
                                  } else {
                                    setSpotOrderbookPosition('right');
                                    localStorage.setItem('crystal_spot_orderbook', 'right');
                                  }
                                }}
                              >
                                <div className="ob-layout-preview-container">
                                  <div className="ob-layout-preview alternative-layout">
                                    <div className="ob-preview-chart"></div>
                                    <div className="ob-preview-orderbook">
                                      <div className="ob-preview-sell"></div>
                                      <div className="ob-preview-buy"></div>
                                    </div>
                                  </div>
                                </div>
                                <div className="layout-label">
                                  <span className="layout-name">
                                    {t('right')} {t('side')}
                                  </span>
                                </div>
                              </button>
                            </div>
                          </div>
                        </div>
                      )}

                      {/* For Spectra, show message that it uses fixed layout */}
                      {activeTradingMode === 'spectra' && (
                        <div className="layout-options">
                          <div className="settings-section-subtitle" style={{ textAlign: 'center', padding: '40px 20px', opacity: 0.7 }}>
                            {t('spectraUsesFixedLayout')}
                          </div>
                        </div>
                      )}

                      {/* Notification Position - show for all modes */}
                      <div>
                        <div className="layout-section-title">
                          {t('notificationPosition')}
                        </div>
                        <div className="settings-section-subtitle">
                          {t('chooseNotificationPopupPosition')}
                        </div>
                        <div className="notification-position-grid">
                          <button
                            className={`notification-position-option ${notificationPosition === 'top-left' ? 'active' : ''}`}
                            onClick={() => updateNotificationPosition('top-left')}
                          >
                            <div className="position-preview-container">
                              <div className="preview-popup top-left"></div>
                            </div>
                          </button>

                          <button
                            className={`notification-position-option ${notificationPosition === 'top-right' ? 'active' : ''}`}
                            onClick={() => updateNotificationPosition('top-right')}
                          >
                            <div className="position-preview-container">
                              <div className="preview-popup top-right"></div>
                            </div>
                          </button>

                          <button
                            className={`notification-position-option ${notificationPosition === 'bottom-left' ? 'active' : ''}`}
                            onClick={() => updateNotificationPosition('bottom-left')}
                          >
                            <div className="position-preview-container">
                              <div className="preview-popup bottom-left"></div>
                            </div>
                          </button>

                          <button
                            className={`notification-position-option ${notificationPosition === 'bottom-right' ? 'active' : ''}`}
                            onClick={() => updateNotificationPosition('bottom-right')}
                          >
                            <div className="position-preview-container">
                              <div className="preview-popup bottom-right"></div>
                            </div>
                          </button>
                        </div>
                      </div>
                    </div>
                  )}

                  {activeSettingsSection === 'display' && (
                    <div className="settings-section-content">
                      <div className="trade-markers-toggle-row">
                        <div className="settings-option-info">
                          <span className="trade-markers-toggle-label">
                            {t('showChartOrders')}
                          </span>
                          <span className="settings-option-subtitle">
                            {t('showActiveOrdersOnChart')}
                          </span>
                        </div>
                        <ToggleSwitch
                          checked={isOrdersVisible}
                          onChange={() => {
                            setIsOrdersVisible(!isOrdersVisible);
                            localStorage.setItem(
                              'crystal_orders_visible',
                              JSON.stringify(!isOrdersVisible),
                            );
                          }}
                        />
                      </div>
                      <div className="orderbook-toggle-row">
                        <div className="settings-option-info">
                          <span className="orderbook-toggle-label">
                            {t('showOB')}
                          </span>
                          <span className="settings-option-subtitle">
                            {t('displayOrderbookPanel')}
                          </span>
                        </div>
                        <ToggleSwitch
                          checked={isOrderbookVisible}
                          onChange={() => {
                            setIsOrderbookVisible(!isOrderbookVisible);
                            localStorage.setItem(
                              'crystal_orderbook_visible',
                              JSON.stringify(!isOrderbookVisible),
                            );
                          }}
                        />
                      </div>

                      <div className="ordercenter-toggle-row">
                        <div className="settings-option-info">
                          <span className="ordercenter-toggle-label">
                            {t('showOC')}
                          </span>
                          <span className="settings-option-subtitle">
                            {t('showOrderCenterAtBottom')}
                          </span>
                        </div>
                        <ToggleSwitch
                          checked={isOrderCenterVisible}
                          onChange={() => {
                            setIsOrderCenterVisible(!isOrderCenterVisible);
                            localStorage.setItem(
                              'crystal_ordercenter_visible',
                              JSON.stringify(!isOrderCenterVisible),
                            );
                          }}
                        />
                      </div>
                    </div>
                  )}

                  {activeSettingsSection === 'audio' && (
                    <div className="settings-section-content">
                      <div className="audio-toggle-row">
                        <div className="settings-option-info">
                          <span className="audio-toggle-label">{t('audioNotifications')}</span>
                          <span className="settings-option-subtitle">
                            {t('playSoundsForTrades')}
                          </span>
                        </div>
                        <ToggleSwitch
                          checked={isAudioEnabled}
                          onChange={() => {
                            setIsAudioEnabled(!isAudioEnabled);
                            localStorage.setItem('crystal_audio_notifications', JSON.stringify(!isAudioEnabled));
                          }}
                        />
                      </div>
                      {isAudioEnabled && (
                        <div className="popup-type-settings">
                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('playSwapSounds')}</span>
                              <span className="settings-option-subtitle">
                                {t('playSoundsForSwaps')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={audioGroups.swap}
                              onChange={() => toggleAudioGroup('swap')}
                            />
                          </div>

                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('playOrderSounds')}</span>
                              <span className="settings-option-subtitle">
                                {t('playSoundsForOrders')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={audioGroups.order}
                              onChange={() => toggleAudioGroup('order')}
                            />
                          </div>

                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('playTransferSounds')}</span>
                              <span className="settings-option-subtitle">
                                {t('playSoundsForTransfers')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={audioGroups.transfer}
                              onChange={() => toggleAudioGroup('transfer')}
                            />
                          </div>

                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('playApprovalSounds')}</span>
                              <span className="settings-option-subtitle">
                                {t('playSoundsForApprovals')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={audioGroups.approve}
                              onChange={() => toggleAudioGroup('approve')}
                            />
                          </div>
                        </div>
                      )}

                      <div className="audio-toggle-row">
                        <div className="settings-option-info">
                          <span className="audio-toggle-label">{t('notificationControls')}</span>
                          <span className="settings-option-subtitle">
                            {t('showAdvancedNotificationOptions')}
                          </span>
                        </div>
                        <ToggleSwitch
                          checked={hideNotificationPopups}
                          onChange={() => {
                            const newValue = !hideNotificationPopups;
                            setHideNotificationPopups(newValue);
                            localStorage.setItem('crystal_hide_notification_popups', JSON.stringify(newValue));
                          }}
                        />
                      </div>

                      {hideNotificationPopups && (
                        <div className="popup-type-settings">
                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('hideSwapNotifications')}</span>
                              <span className="settings-option-subtitle">
                                {t('hideSwapNotificationsDesc')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={hiddenPopupTypes.swap === true && hiddenPopupTypes.swapFailed === true}
                              onChange={() => {
                                const shouldHide = !(hiddenPopupTypes.swap === true && hiddenPopupTypes.swapFailed === true);
                                updateMultipleHiddenPopupTypes(['swap', 'swapFailed'], shouldHide);
                              }}
                            />
                          </div>

                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('hideOrderNotifications')}</span>
                              <span className="settings-option-subtitle">
                                {t('hideOrderNotificationsDesc')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={hiddenPopupTypes.limit === true && hiddenPopupTypes.fill === true && hiddenPopupTypes.cancel === true && hiddenPopupTypes.limitFailed === true}
                              onChange={() => {
                                const shouldHide = !(hiddenPopupTypes.limit === true && hiddenPopupTypes.fill === true && hiddenPopupTypes.cancel === true && hiddenPopupTypes.limitFailed === true);
                                updateMultipleHiddenPopupTypes(['limit', 'fill', 'cancel', 'limitFailed'], shouldHide);
                              }}
                            />
                          </div>

                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('hideTransferNotifications')}</span>
                              <span className="settings-option-subtitle">
                                {t('hideTransferNotificationsDesc')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={hiddenPopupTypes.send === true && hiddenPopupTypes.sendFailed === true && hiddenPopupTypes.wrap === true && hiddenPopupTypes.unwrap === true && hiddenPopupTypes.stake === true}
                              onChange={() => {
                                const shouldHide = !(hiddenPopupTypes.send === true && hiddenPopupTypes.sendFailed === true && hiddenPopupTypes.wrap === true && hiddenPopupTypes.unwrap === true && hiddenPopupTypes.stake === true);
                                updateMultipleHiddenPopupTypes(['send', 'sendFailed', 'wrap', 'unwrap', 'stake'], shouldHide);
                              }}
                            />
                          </div>

                          <div className="popup-type-toggle-row">
                            <div className="settings-option-info">
                              <span className="popup-type-label">{t('hideApprovalNotifications')}</span>
                              <span className="settings-option-subtitle">
                                {t('hideApprovalNotificationsDesc')}
                              </span>
                            </div>
                            <ToggleSwitch
                              checked={hiddenPopupTypes.approve === true}
                              onChange={() => {
                                updateHiddenPopupType('approve', !hiddenPopupTypes.approve);
                              }}
                            />
                          </div>
                        </div>
                      )}
                    </div>
                  )}

                  {activeSettingsSection === 'keybinds' && (
                    <div className="settings-section-content">
                      <div className="keybinds-section">
                        <div className="settings-subsection">
                          <div className="layout-section-title">{t('tradingShortcuts')}</div>
                          <div className="settings-section-subtitle">
                            {t('keyboardShortcutsForTrading')}
                          </div>
                          {renderKeybindButton('submitTransaction', t('submitTransaction'), t('executeTradesPlaceOrders'))}
                          {renderKeybindButton('switchTokens', t('switchTokens'), t('swapInputOutputTokens'))}
                          {renderKeybindButton('maxAmount', t('maxAmount'), t('setInputToMaxBalance'))}
                          {renderKeybindButton('focusInput', t('focusInput'), t('focusMainAmountInput'))}
                        </div>
                        <div className="settings-subsection">
                          <div className="layout-section-title">{t('tokenSelection')}</div>
                          <div className="settings-section-subtitle">
                            {t('quickAccessTokenSelection')}
                          </div>
                          {renderKeybindButton('openTokenInSelect', t('selectInputToken'), t('openTokenSelectionForInput'))}
                          {renderKeybindButton('openTokenOutSelect', t('selectOutputToken'), t('openTokenSelectionForOutput'))}
                        </div>
                        <div className="settings-subsection">
                          <div className="layout-section-title">{t('orderManagement')}</div>
                          <div className="settings-section-subtitle">
                            {t('manageActiveOrdersQuickly')}
                          </div>
                          {renderKeybindButton('cancelAllOrders', t('cancelAllOrders'), t('cancelAllActiveOrders'))}
                          {renderKeybindButton('cancelTopOrder', t('cancelTopOrder'), t('cancelMostRecentOrder'))}
                        </div>
                        <div className="settings-subsection">
                          <div className="layout-section-title">{t('interfaceShortcuts')}</div>
                          <div className="settings-section-subtitle">
                            {t('navigateInterfaceQuickly')}
                          </div>
                          {renderKeybindButton('openSettings', t('openSettings'), t('openSettingsPanel'))}
                          {renderKeybindButton('openWallet', t('openWallet'), t('openWalletConnectionPortfolio'))}
                          {renderKeybindButton('toggleSimpleView', t('toggleSimpleView'), t('switchBetweenSimpleAdvanced'))}
                          {renderKeybindButton('refreshQuote', t('refreshQuote'), t('refreshCurrentPriceQuote'))}
                        </div>
                        <div className="settings-subsection">
                          <div className="layout-section-title">{t('marketShortcuts')}</div>
                          <div className="settings-section-subtitle">
                            {t('interactWithMarketDataQuickly')}
                          </div>
                          {renderKeybindButton('toggleFavorite', t('toggleFavorite'), t('addRemoveCurrentMarketFavorites'))}
                        </div>
                      </div>
                    </div>
                  )}
                </div>

                <button
                  className="reset-tab-button"
                  onClick={() => {
                    switch (activeSettingsSection) {
                      case 'general':
                        setLanguage('EN');
                        localStorage.setItem('crystal_language', 'EN');
                        setSpotSliderMode('slider');
                        localStorage.setItem('crystal_spot_slider_mode', 'slider');
                        setSpotSliderPresets([25, 50, 75]);
                        localStorage.setItem('crystal_spot_slider_presets', JSON.stringify([25, 50, 75]));
                        setSpotSliderIncrement(10);
                        localStorage.setItem('crystal_spot_slider_increment', '10');
                        setRpcUrl('');
                        localStorage.setItem('crystal_rpc_url', '');
                        setGraphUrl('');
                        localStorage.setItem('crystal_graph_url', '');
                        break;

                      case 'layout':
                        setSpotLayoutSettings('default');
                        localStorage.setItem('crystal_layout', 'default');
                        setSpotOrderbookPosition('right');
                        localStorage.setItem('crystal_orderbook', 'right');
                        setNotificationPosition('bottom-right');
                        localStorage.setItem('crystal_notification_position', 'bottom-right');
                        break;

                      case 'display':
                        setIsMarksVisible(true);
                        localStorage.setItem('crystal_marks_visible', 'true');
                        setIsOrdersVisible(true);
                        localStorage.setItem('crystal_orders_visible', 'true');
                        setIsOrderbookVisible(true);
                        localStorage.setItem('crystal_orderbook_visible', 'true');
                        setIsOrderCenterVisible(true);
                        localStorage.setItem('crystal_ordercenter_visible', 'true');
                        setShowChartOutliers(false);
                        localStorage.setItem('crystal_show_chart_outliers', 'false');
                        break;

                      case 'audio':
                        setIsAudioEnabled(false);
                        localStorage.setItem('crystal_audio_notifications', 'false');
                        setAudioGroups({ swap: true, order: true, transfer: true, approve: true });
                        localStorage.setItem('crystal_audio_groups', JSON.stringify({ swap: true, order: true, transfer: true, approve: true }));
                        setHideNotificationPopups(false);
                        localStorage.setItem('crystal_hide_notification_popups', 'false');
                        setHiddenPopupTypes({});
                        localStorage.setItem('crystal_hidden_popup_types', JSON.stringify({}));
                        break;

                      case 'keybinds':
                        const defaultKeybinds = {
                          submitTransaction: 'Enter',
                          switchTokens: 'KeyZ',
                          maxAmount: 'KeyA',
                          focusInput: 'KeyF',
                          openSettings: 'KeyP',
                          openWallet: 'KeyW',
                          openTokenInSelect: 'KeyQ',
                          openTokenOutSelect: 'KeyE',
                          cancelAllOrders: 'KeyC',
                          cancelTopOrder: 'KeyX',
                          toggleFavorite: 'KeyM',
                          toggleSimpleView: 'KeyV',
                          refreshQuote: 'KeyR',
                        };
                        setKeybinds(defaultKeybinds);
                        localStorage.setItem('crystal_keybinds', JSON.stringify(defaultKeybinds));
                        setEditingKeybind(null);
                        setIsListeningForKey(false);
                        break;
                    }
                  }}
                >
                  {t('resetTab')}
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 6 && selectedConnector ? (
          <div ref={popupref} className="connecting-popup">
            <div className="connecting-content">
              <div className="connecting-header">
                <button
                  className="connecting-back-button"
                  onClick={() => {
                    setpopup(4);
                    setSelectedConnector(null);
                  }}
                >
                  <svg
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                  >
                    <path d="M19 12H5M12 19l-7-7 7-7" />
                  </svg>
                </button>
                <button
                  className="disconnected-wallet-close-button"
                  onClick={() => {
                    setpopup(0);
                    setSelectedConnector(null);
                  }}
                >
                  <img src={closebutton} className="close-button-icon" />
                </button>
              </div>

              <div className="logo-container">
                <div className="logo-spinner" />
                <img
                  src={
                    selectedConnector.name === 'MetaMask'
                      ? walletmetamask
                      : selectedConnector.name === 'Coinbase Wallet'
                        ? walletcoinbase
                        : selectedConnector.name === 'WalletConnect'
                          ? walletconnect
                          : selectedConnector.name === 'Safe'
                            ? walletsafe
                            : selectedConnector.name === 'Rabby Wallet'
                              ? walletrabby
                              : selectedConnector.name === 'Backpack'
                                ? walletbackpack
                                : selectedConnector.name === 'Phantom'
                                  ? walletphantom
                                  : selectedConnector.name === 'Tomo' ? wallettomo : selectedConnector.name === 'HaHa Wallet' ? wallethaha : walletinjected
                  }
                  className="wallet-logo"
                />
              </div>

              <h2 className="connecting-title">{selectedConnector.name}</h2>
              <p className="connecting-text">{t('requestingConnection')}</p>
              <p className="connecting-subtext">
                {t('confirmConnection1')} {selectedConnector.name}{' '}
                {t('confirmConnection2')}.
              </p>
            </div>
          </div>
        ) : null}
        {popup === 7 ? (
          <TokenInfoPopupContent
            symbol={activeMarket.baseAsset}
            setpopup={setpopup}
            ref={popupref}
          />
        ) : null}
        {popup === 8 ? (
          <div className="search-markets-dropdown-popup" ref={popupref}>
            <div className="search-markets-dropdown-header">
              <div className="search-container">
                <div className="search-wrapper">
                  <SearchIcon className="search-icon" size={12} />
                  <input
                    ref={searchInputRef}
                    type="text"
                    placeholder={t('searchMarkets')}
                    className="search-input"
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    onKeyDown={handleSearchKeyDown}
                    autoFocus={!(windowWidth <= 1020)}
                  />
                  {searchQuery && (
                    <button
                      type="button"
                      className="cancel-search"
                      onClick={() => setSearchQuery('')}
                    >
                      {t('clear')}
                    </button>
                  )}
                </div>
              </div>
            </div>

            <div className="search-markets-list-header">
              <div className="favorites-header">
                <button
                  onClick={() => handleSort('favorites')}
                  className="favorite-sort-button"
                >
                  <svg
                    width="16"
                    height="16"
                    viewBox="0 0 24 24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="1.5"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    className="favorites-sort-icon"
                  >
                    <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z" />
                  </svg>
                </button>
              </div>
              <div
                className="search-header-item"
                onClick={() => handleSort('volume')}
              >
                {t('market')} / {t('volume')}
                <SortArrow
                  sortDirection={
                    sortField === 'volume' ? sortDirection : undefined
                  }
                  onClick={(e) => {
                    e.stopPropagation();
                    handleSort('volume');
                  }}
                />
              </div>
              <div
                className="search-header-item"
                onClick={() => handleSort('change')}
              >
                {t('last') + ' ' + t('day')}
                <SortArrow
                  sortDirection={
                    sortField === 'change' ? sortDirection : undefined
                  }
                  onClick={(e) => {
                    e.stopPropagation();
                    handleSort('change');
                  }}
                />
              </div>
              <div
                className="search-header-item"
                onClick={() => handleSort('price')}
              >
                {t('price')}
                <SortArrow
                  sortDirection={
                    sortField === 'price' ? sortDirection : undefined
                  }
                  onClick={(e) => {
                    e.stopPropagation();
                    handleSort('price');
                  }}
                />
              </div>
            </div>
            <div
              className="search-markets-list"
              id="search-markets-list-container"
            >
              {sortedMarkets.filter((market) => {
                const matchesSearch = market?.pair
                  .toLowerCase()
                  .includes(searchQuery.toLowerCase());
                const notWeth =
                  market?.baseAddress !== settings.chainConfig[activechain].weth;
                return matchesSearch && notWeth;
              }).length > 0 ? (
                sortedMarkets.filter((market) => {
                  const matchesSearch = market?.pair
                    .toLowerCase()
                    .includes(searchQuery.toLowerCase());
                  const notWeth =
                    market?.baseAddress !== settings.chainConfig[activechain].weth;
                  return matchesSearch && notWeth;
                }).map((market, index) => (
                  <div
                    key={market.pair}
                    className={`search-market-item ${index === selectedIndex ? 'selected' : ''}`}
                    onClick={() => {
                      setSearchQuery('');
                      setpopup(0);
                      onMarketSelect(market)
                    }}
                    onMouseEnter={() => setSelectedIndex(index)}
                    role="button"
                    tabIndex={-1}
                    id={`search-market-item-${index}`}
                  >
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        e.preventDefault();
                        toggleFavorite(market.baseAddress?.toLowerCase() ?? '');
                        refocusSearchInput();
                      }}
                      onMouseDown={(e) => e.preventDefault()}
                      tabIndex={-1}
                      className={`dropdown-market-favorite-button 
                            ${favorites.includes(market.baseAddress?.toLowerCase() ?? '') ? 'active' : ''}`}
                    >
                      <svg
                        width="16"
                        height="16"
                        viewBox="0 0 24 24"
                        fill={
                          favorites.includes(
                            market.baseAddress?.toLowerCase() ?? '',
                          )
                            ? 'currentColor'
                            : 'none'
                        }
                        stroke="currentColor"
                        strokeWidth="2"
                        strokeLinecap="round"
                        strokeLinejoin="round"
                      >
                        <path d="M12 2L15.09 8.26L22 9.27L17 14.14L18.18 21.02L12 17.77L5.82 21.02L7 14.14L2 9.27L8.91 8.26L12 2Z" />
                      </svg>
                    </button>

                    <div className="search-market-pair-section">
                      <img src={market.image} className="market-icon" />
                      <div className="market-info">
                        <span className="market-pair">{market.pair}</span>
                        <span className="market-volume">
                          ${formatCommas(market.volume)}
                        </span>
                      </div>
                    </div>
                    <div className="search-market-chart-section">
                      <MiniChart
                        market={market}
                        series={market.series}
                        priceChange={market.priceChange}
                        isVisible={true}
                      />
                    </div>
                    <div className="search-market-price-section">
                      <div className="search-market-price">
                        {formatSubscript(market.currentPrice)}
                      </div>
                      <div
                        className={`search-market-change ${market.priceChange.startsWith('-') ? 'negative' : 'positive'}`}
                      >
                        {market.priceChange}
                      </div>
                    </div>
                  </div>
                ))
              ) : (
                <div className="no-markets-message">{t('noMarkets')}</div>
              )}
            </div>

            <div className="keyboard-shortcuts-container">
              <div className="keyboard-shortcut">
                <span className="arrow-key"></span>
                <span className="arrow-key"></span>
                <span>{t('toNavigate')}</span>
              </div>
              <div className="keyboard-shortcut">
                <span className="key">Enter</span>
                <span>{t('toSelect')}</span>
              </div>
              <div className="keyboard-shortcut">
                <span className="key">Esc</span>
                <span>{t('toClose')}</span>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 9 ? (
          <div ref={popupref} className="connect-wallet-background unconnected">
            <div className="social-content-container">
              <div className="social-content">
                <h1 className="social-heading">Join our growing community!</h1>
                <p className="social-description">
                  Crystal Exchange is being released in phases. Be the first to know when new features arrive by joining our vibrant community!
                </p>

                <div className="social-buttons">
                  <button
                    className="wallet-option"
                    onClick={() =>
                      window.open('https://discord.gg/CrystalExch', '_blank')
                    }
                  >
                    <img
                      className="connect-wallet-icon"
                      src="https://assets-global.website-files.com/6257adef93867e50d84d30e2/636e0a69f118df70ad7828d4_icon_clyde_blurple_RGB.svg"
                    />
                    <span className="wallet-name">Join Crystal's Discord</span>
                  </button>

                  <button
                    className="wallet-option"
                    onClick={() =>
                      window.open('https://x.com/CrystalExch', '_blank')
                    }
                  >
                    <img
                      className="connect-wallet-icon"
                      src={Xicon}
                    />
                    <span className="wallet-name">Follow us on X (Twitter)</span>
                  </button>
                </div>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 10 ? ( // send token search popup
          <div ref={popupref} className="sendselectbg">
            <div className="send-top-row">
              <input
                className="sendselect"
                onChange={(e) => {
                  settokenString(e.target.value);
                }}
                placeholder={t('searchToken')}
                autoFocus={!(windowWidth <= 1020)}
              />
              {tokenString && (
                <button
                  className="sendselect-clear visible"
                  onClick={() => {
                    settokenString('');
                    const input = document.querySelector('.sendselect') as HTMLInputElement;
                    if (input) {
                      input.value = '';
                      input.focus();
                    }
                  }}
                >
                  {t('clear')}
                </button>
              )}
              <button
                className="sendselect-back"
                onClick={() => {
                  setpopup(3);
                }}
              >
                <img src={closebutton} className="send-close-button-icon" />
              </button>
            </div>

            <ul className="sendtokenlist">
              {Object.values(tokendict)
                .filter(
                  (token) =>
                    token.ticker.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                    token.name.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                    token.address.toLowerCase().includes(tokenString.trim().toLowerCase())
                ).length === 0 ? (
                <div className="empty-token-list">
                  <div className="empty-token-list-content">
                    <svg
                      width="24"
                      height="24"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      className="empty-token-list-icon"
                    >
                      <circle cx="11" cy="11" r="8" />
                      <path d="M21 21l-4.35-4.35" />
                    </svg>
                    <div className="empty-token-list-text">{t('noTokens')}</div>
                  </div>
                </div>
              ) : (
                Object.values(tokendict)
                  .filter(
                    (token) =>
                      token.ticker.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                      token.name.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                      token.address.toLowerCase().includes(tokenString.trim().toLowerCase())
                  )
                  .map((token) => (
                    <button
                      className="sendtokenbutton"
                      key={token.address}
                      onClick={() => {
                        setSendTokenIn(token.address);
                        setSendUsdValue('');
                        setSendInputAmount('');
                        setSendAmountIn(BigInt(0));
                        settokenString('');
                        setpopup(3);
                      }}
                    >
                      <img className="tokenlistimage" src={token.image} />
                      <div className="tokenlisttext">
                        <div className="tokenlistname">{token.ticker}</div>
                        <div className="tokenlistticker">{token.name}</div>
                      </div>
                      <div className="token-right-content">
                        <div className="tokenlistbalance">
                          {formatDisplayValue(tokenBalances[token.address], Number(token.decimals))}
                        </div>
                        <div className="token-address-container">
                          <span className="token-address">
                            {`${token.address.slice(0, 6)}...${token.address.slice(-4)}`}
                          </span>
                          <div
                            className="copy-address-button"
                            onClick={(e) => {
                              e.stopPropagation();
                              navigator.clipboard.writeText(token.address);
                              const copyIcon =
                                e.currentTarget.querySelector('.copy-icon');
                              const checkIcon =
                                e.currentTarget.querySelector('.check-icon');
                              if (copyIcon && checkIcon) {
                                copyIcon.classList.add('hidden');
                                checkIcon.classList.add('visible');
                                setTimeout(() => {
                                  copyIcon.classList.remove('hidden');
                                  checkIcon.classList.remove('visible');
                                }, 2000);
                              }
                            }}
                          >
                            <svg
                              className="copy-icon"
                              viewBox="0 0 24 24"
                              fill="none"
                              stroke="currentColor"
                              strokeWidth="2"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                            >
                              <rect
                                x="9"
                                y="9"
                                width="13"
                                height="13"
                                rx="2"
                                ry="2"
                              ></rect>
                              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                            <svg
                              className="check-icon"
                              viewBox="0 0 24 24"
                              fill="none"
                              stroke="currentColor"
                              strokeWidth="2"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                            >
                              <circle cx="12" cy="12" r="10" />
                              <path d="M8 12l3 3 6-6" />
                            </svg>
                          </div>
                        </div>
                      </div>
                    </button>
                  ))
              )}
            </ul>
          </div>
        ) : null}
        {popup === 11 ? (
          <div ref={popupref} className="generating-address-popup">
            <span className="loader"></span>
            <h2 className="generating-address-title">Fetching Your Smart Wallet</h2>
            <p className="generating-address-text">
              Please wait while your smart wallet address is being loaded...
            </p>
          </div>
        ) : null}
        {popup === 12 ? (
          <div ref={popupref} className="deposit-page-container" onClick={(e) => e.stopPropagation()}>
            <div className="deposit-page-header">
              <h2>{t("deposit")}</h2>
              <div className="deposit-right-header">
                {!client && validOneCT && (<button
                    className={`deposit-right-header-btn`}
                    onClick={() => {
                      setOneCTDepositAddress(address);
                      setpopup(25)
                    }}
                  >
                    Deposit from EOA
                </button>)}
                <button className="deposit-close-button" onClick={() => { setpopup(0) }}>
                  <img src={closebutton} className="deposit-close-icon" />
                </button>
              </div>
            </div>
            <div className={`token-dropdown-container ${dropdownOpen ? 'open' : ''}`}>
              <div
                className="selected-token-display"
                onClick={() => setDropdownOpen(!dropdownOpen)}
              >
                <div className="selected-token-info">
                  <img className="deposit-token-icon" src={tokendict[selectedDepositToken].image} />
                  <span className="deposit-token-name">{tokendict[selectedDepositToken].name}</span>
                  <span className="deposit-token-ticker">({tokendict[selectedDepositToken].ticker})</span>
                  <CopyButton textToCopy={selectedDepositToken} />
                </div>
                <div className="selected-token-balance">
                  {formatDisplayValue(
                    tokenBalances[selectedDepositToken] || 0,
                    Number(tokendict[selectedDepositToken].decimals || 18)
                  )}

                  <svg
                    className="deposit-button-arrow"
                    xmlns="http://www.w3.org/2000/svg"
                    viewBox="0 0 24 24"
                    width="24"
                    height="24"
                    fill="none"
                    stroke="currentColor"
                    strokeWidth="2"
                    strokeLinecap="round"
                    strokeLinejoin="round"
                  >
                    <polyline points="6 9 12 15 18 9"></polyline>
                  </svg>
                </div>

              </div>
              {dropdownOpen && (
                <div className="token-dropdown-list">
                  {Object.entries(tokendict).slice(0, 3).concat(Object.entries(tokendict).slice(9, 15)).map(([address, token]) => (
                    <div
                      key={address}
                      className={`token-dropdown-item ${selectedDepositToken === address ? 'selected' : ''}`}
                      onClick={() => {
                        setSelectedDepositToken(address);
                        setDropdownOpen(false);
                      }}
                    >
                      <div className="dropdown-token-info">
                        <img className="deposit-token-icon" src={token.image} />
                        <span className="deposit-token-name">{token.name}</span>
                        <span className="deposit-token-ticker">({token.ticker})</span>
                        <CopyButton textToCopy={address} />
                      </div>
                      <span className="deposit-token-balance">
                        {formatDisplayValue(
                          tokenBalances[address] || 0,
                          Number(token.decimals || 18)
                        )}
                      </span>
                    </div>
                  ))}
                </div>
              )}
            </div>
            <span className="deposit-subtitle">{t('sendTo')}</span>
            <div className="deposit-address-container">
              <div className="deposit-address-box">
                <span className="deposit-address">{address}</span>
                <button
                  className={`deposit-copy-button ${copyTooltipVisible ? 'success' : ''}`}
                  onClick={(e) => {
                    e.stopPropagation()
                    navigator.clipboard.writeText(address || '');
                    setCopyTooltipVisible(true);
                    setTimeout(() => setCopyTooltipVisible(false), 2000);
                  }}
                >
                  {copyTooltipVisible ?
                    <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" strokeWidth="2" fill="none">
                      <polyline points="20 6 9 17 4 12"></polyline>
                    </svg> :
                    <svg viewBox="0 0 24 24" width="24" height="24" stroke="currentColor" strokeWidth="2" fill="none">
                      <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                      <path d="M5 15H4a2 2 0 01-2-2V4a2 2 0 012-2h9a2 2 0 012 2v1"></path>
                    </svg>
                  }
                </button>
              </div>
            </div>

            <div className="deposit-warning">
              {t("depositWarning")}
            </div>
            <div className="deposit-qr-container">
              <QRCodeSVG
                value={address || ''}
                size={170}
                level="H"
                includeMargin={true}
                bgColor="#000000"
                fgColor="#ffffff"
              />
            </div>

            <button
              className="deposit-done-button"
              onClick={() => { setpopup(4) }}
            >
              {t('done')}
            </button>
          </div>
        ) : null}
        {popup === 13 ? (
          <div ref={popupref} className="high-impact-confirmation-popup">
            <div className="high-impact-confirmation-header">
              <button
                className="high-impact-close-button"
                onClick={() => {
                  setpopup(0);
                  window.dispatchEvent(new Event('high-impact-cancel'));
                }}
              >
                <img src={closebutton} className="close-button-icon" />
              </button>
            </div>
            <div className="high-impact-content">
              <img className="warning-image" src={warningicon} />

              <p className="high-impact-message">
                {t('Warning')}
              </p>

              <div className="high-impact-details">
                <div className="high-impact-detail-row">
                  <span className="high-impact-value-title">{t('priceImpact')}</span>
                  <span className="high-impact-value">{priceImpact}</span>
                </div>

                <div className="high-impact-detail-row">
                  <span className="high-impact-value-title">{t('pay')}</span>
                  <span className="high-impact-value">
                    {formatDisplayValue(
                      amountIn,
                      Number(tokendict[tokenIn].decimals)
                    )} {tokendict[tokenIn].ticker}
                  </span>
                </div>

                <div className="high-impact-detail-row">
                  <span className="high-impact-value-title">{t('receive')}</span>
                  <span className="high-impact-value">
                    {formatDisplayValue(
                      amountOutSwap,
                      Number(tokendict[tokenOut].decimals)
                    )} {tokendict[tokenOut].ticker}
                  </span>
                </div>
              </div>
            </div>

            <div className="high-impact-actions">
              <button
                className="high-impact-cancel-button"
                onClick={() => {
                  setpopup(0);
                  window.dispatchEvent(new Event('high-impact-cancel'));
                }}
              >
                {t('cancel')}
              </button>

              <button
                className="high-impact-confirm-button"
                onClick={async () => {
                  setpopup(0);
                  window.dispatchEvent(new Event('high-impact-confirm'));
                }}
              >
                {t('confirmSwap')}
              </button>
            </div>
          </div>
        ) : null}
        {(popup === 14 || popup === 15 || popup === 17 || popup === 18 || isTransitioning) ? (
          <div ref={popupref} className={`onboarding-container ${exitingChallenge ? 'exiting' : ''}`}>
            <div
              className={`onboarding-background-blur ${exitingChallenge ? 'exiting' : ''} ${(isTransitioning && transitionDirection === 'forward') || (popup === 15 && connected)
                ? 'active'
                : ''
                }`}
            />
            <div className="onboarding-crystal-logo">
              <img className="onboarding-crystal-logo-image" src={crystal} />
              <span className="onboarding-crystal-text">CRYSTAL</span>
            </div>

            {user && !connected && (
              <div className="generating-address-popup">
                <span className="loader"></span>
                <h2 className="generating-address-title">Fetching Your Smart Wallet</h2>
                <p className="generating-address-text">
                  Please wait while your smart wallet address is being loaded...
                </p>
              </div>
            )}
            {connected ? (
              <>
                <div className="step-indicators">
                  {[1, 2, 3, 4, 5, 6].map((index) => (
                    <div
                      key={index}
                      className={`step-indicator ${popup === 14
                        ? index === 1 ? 'active' : ''
                        : popup === 17
                          ? index === 2 ? 'active' : ''
                          : popup === 18
                            ? index === 3 ? 'active' : ''
                            : (currentStep + 4) === index ? 'active' : ''
                        } ${popup === 14
                          ? index < 1 ? 'completed' : ''
                          : popup === 17
                            ? index < 2 ? 'completed' : ''
                            : popup === 18
                              ? index < 3 ? 'completed' : ''
                              : (currentStep + 4) > index ? 'completed' : ''
                        } ${isTransitioning ? 'transitioning' : ''}`}
                    />
                  ))}
                </div>

                <div
                  className={`onboarding-wrapper ${isTransitioning ? `transitioning ${transitionDirection}` : ''
                    }`}
                >
                  {popup == 18 && (
                    <div className="onboarding-section active">
                      <div className="onboarding-split-container">
                        <div className="onboarding-left-side">
                          <div className="onboarding-content">
                            <div className="onboarding-header">
                              <h2 className="onboarding-title">Join our growing community!</h2>
                              <p className="onboarding-subtitle">
                                Crystal is being released in phases. Join our community to be the first to know when new features arrive.
                              </p>
                            </div>

                            <div className="social-buttons">
                              <button
                                className="wallet-option"
                                onClick={() =>
                                  window.open('https://discord.gg/CrystalExch', '_blank')
                                }
                              >
                                <img
                                  className="connect-wallet-icon"
                                  src="https://assets-global.website-files.com/6257adef93867e50d84d30e2/636e0a69f118df70ad7828d4_icon_clyde_blurple_RGB.svg"
                                />
                                <span className="wallet-name">Join Crystal's Discord</span>
                              </button>

                              <button
                                className="wallet-option"
                                onClick={() =>
                                  window.open('https://x.com/CrystalExch', '_blank')
                                }
                              >
                                <img
                                  className="connect-wallet-icon"
                                  src={Xicon}
                                />
                                <span className="wallet-name">Follow us on X (Twitter)</span>
                              </button>
                            </div>

                            <div className="onboarding-actions">
                              <button
                                className="skip-button"
                                onClick={() => {
                                  audio.currentTime = 0;
                                  audio.play();
                                  setpopup(15);
                                }}
                              >
                                Continue
                              </button>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  )}

                  {popup == 17 && (
                    <div className="onboarding-section active">
                      <div className="onboarding-split-container">
                        <div className="onboarding-left-side">
                          <div className="onboarding-content">
                            <div className="onboarding-header">
                              <h2 className="use-ref-title">Add a referral code (optional)</h2>
                              <div className="form-group">
                                {error && <span className="error-message">{error}</span>}

                                <input
                                  className="username-input"
                                  placeholder="Enter a code"
                                  value={typedRefCode}
                                  onChange={e => {
                                    const value = e.target.value.trim();
                                    if (isValidInput(value) || value === "") {
                                      setTypedRefCode(value);
                                      setError('')
                                    }
                                  }}
                                />
                              </div>

                              <div className="onboarding-actions">
                                <button
                                  className={`create-username-button ${isRefSigning ? 'signing' : !typedRefCode ? 'disabled' : ''}`}
                                  disabled={!typedRefCode || isRefSigning}
                                  onClick={async () => {
                                    const ok = await handleSetRef(typedRefCode);
                                    if (ok) {
                                      audio.currentTime = 0;
                                      audio.play();
                                      setpopup(18);
                                    }
                                  }}
                                >
                                  {isRefSigning ? (
                                    <div className="button-content">
                                      <div className="loading-spinner" />
                                      {t('signTransaction')}
                                    </div>
                                  ) : t('setReferral')}
                                </button>

                                <button
                                  className="skip-button"
                                  onClick={() => {
                                    audio.currentTime = 0;
                                    audio.play();
                                    setpopup(18);
                                  }}
                                >
                                  Skip
                                </button>
                              </div>
                            </div>
                          </div>
                        </div>
                      </div>
                    </div>
                  )}

                  <div
                    className={`onboarding-section username-section ${(popup === 14 || (isTransitioning)) && ((!username && usernameResolved) || transitionDirection == 'backward')
                      ? 'active'
                      : ''
                      }`}
                  >
                    <div className="onboarding-split-container">
                      <div className="onboarding-left-side">
                        <div className="onboarding-content">
                          <div className="onboarding-header">
                            <h2 className="onboarding-title">
                              {username ? 'Edit Name' : 'Enter a Name'}
                            </h2>
                            <p className="onboarding-subtitle">
                              {username
                                ? 'Update the name that appears on the leaderboard.'
                                : 'This username will be visible on the leaderboard to all.'}
                            </p>
                          </div>

                          <div className="onboarding-form">
                            <div className="form-group">
                              <label className="form-label">Your Wallet Address</label>
                              <div className="wallet-address">{address || '0x1234...5678'}</div>
                            </div>

                            <div className="form-group">
                              <label htmlFor="username" className="form-label">Username</label>
                              <input
                                type="text"
                                id="username"
                                className="username-input"
                                placeholder={usernameInput ? usernameInput : 'Enter a username'}
                                value={usernameInput || ''}
                                onChange={e => {
                                  const value = e.target.value.trim();
                                  if (isValidInput(value) || value === "") {
                                    setUsernameInput(value);
                                  }
                                }}
                              />
                              {usernameError && <p className="username-error">{usernameError}</p>}
                            </div>
                          </div>

                          <button
                            className={`create-username-button ${isUsernameSigning ? 'signing' : ''
                              } ${!usernameInput.trim() ? 'disabled' : ''}`}
                            onClick={async () => {
                              if (!usernameInput.trim() || isUsernameSigning || usernameInput === username) return;
                              await handleEditUsername(usernameInput)
                            }}
                            disabled={!usernameInput.trim() || isUsernameSigning || usernameInput === username}
                          >
                            {isUsernameSigning ? (
                              <div className="button-content">
                                <div className="loading-spinner" />
                                {t('signTransaction')}
                              </div>
                            ) : username ? t('editUsername') : 'Create Username'}
                          </button>
                        </div>

                        {(!usernameInput || username !== '') && (
                          <>
                            <div className="onboarding-actions">
                              <button
                                className="skip-button"
                                type="button"
                                onClick={() => {
                                  audio.currentTime = 0;
                                  audio.play();
                                  setpopup(17);
                                }}
                              >
                                {!usernameInput ? "Continue Without Username" : "Continue"}
                              </button>
                            </div>
                          </>
                        )}
                      </div>
                    </div>
                  </div>

                  <div
                    className={`onboarding-section challenge-section ${popup === 15 ||
                      (isTransitioning && transitionDirection === 'forward')
                      ? 'active'
                      : ''
                      } ${exitingChallenge ? 'exiting' : ''}`}
                    data-step={currentStep}
                  >
                    <div className="challenge-intro-split-container">
                      <div className="floating-elements-container">
                        <img src={circleleft} className="circle-bottom-crystal" />
                        <img src={topright} className="top-right-crystal" />
                        <img src={topleft} className="top-left-crystal" />
                        <img src={circleleft} className="circle-left-crystal" />
                        <img src={veryleft} className="very-left-crystal" />
                        <img src={circleleft} className="circle-right-crystal" />
                        <img src={veryright} className="very-right-crystal" />
                        <img src={topmiddle} className="top-middle-crystal" />
                        <img src={topleft} className="bottom-middle-crystal" />
                        <img src={circleleft} className="bottom-right-crystal" />

                        <div className="account-setup-header">
                          <div className="account-setup-title-wrapper">
                            <h2 className="account-setup-title">
                              {t('challengeOverview')}
                            </h2>
                            <p className="account-setup-subtitle">
                              {t('learnHowToCompete')}
                            </p>
                          </div>
                        </div>

                        <div className="challenge-intro-content-wrapper">
                          <div className="challenge-intro-content-side">
                            <div className="challenge-intro-content-inner">
                              <div className="intro-text">
                                <h3 className="intro-title">
                                  {currentStep === 0
                                    ? t('precisionMatters')
                                    : currentStep === 1
                                      ? t('earnCrystals')
                                      : t('claimRewards')}
                                </h3>
                                <p className="intro-description">
                                  {currentStep === 0
                                    ? t('placeYourBids')
                                    : currentStep === 1
                                      ? t('midsGiveYou')
                                      : t('competeOnLeaderboards')}
                                </p>
                              </div>
                            </div>
                          </div>

                          <div
                            className={`challenge-intro-visual-side${animating ? ' is-animating' : ''
                              }`}
                          >
                            {currentStep === 0 && (
                              <div className="intro-image-container">
                                <div
                                  className={`zoom-container${animationStarted ? ' zoom-active' : ''
                                    }`}
                                >
                                  <img
                                    src={part1image}
                                    className="intro-image"
                                    alt="Tutorial illustration"
                                  />
                                </div>
                              </div>
                            )}

                            {currentStep === 1 && (
                              <div className="xp-animation-container">
                                <div className="user-profile">
                                  <div className="self-pfp">
                                    <img
                                      src={defaultPfp}
                                      className="profile-pic-second"
                                      alt="User profile"
                                    />
                                    <div className="username-display">
                                      @{usernameInput || 'player123'}
                                    </div>
                                    <div className="xp-counter">
                                      <img
                                        src={crystalxp}
                                        className="xp-icon"
                                        alt="Crystal XP"
                                        style={{
                                          width: '23px',
                                          height: '23px',
                                          verticalAlign: 'middle',
                                        }}
                                      />
                                      <span className="self-pfp-xp">8732.23</span>
                                    </div>
                                  </div>

                                  <div className="challenge-mini-leaderboard">
                                    <div className="mini-leaderboard-header">
                                      <span className="mini-leaderboard-title">
                                        Season 0 Leaderboard
                                      </span>
                                      <span className="mini-leaderboard-time">
                                        7d 22h 50m 54s
                                      </span>
                                    </div>

                                    <div className="mini-progress-bar">
                                      <div className="mini-progress-fill"></div>
                                    </div>

                                    <div className="mini-leaderboard-user">
                                      <div className="mini-leaderboard-user-left">
                                        <span className="mini-user-rank">#62</span>
                                        <span className="mini-user-address">
                                          0xB080...c423
                                          <svg
                                            className="mini-user-copy-icon"
                                            viewBox="0 0 24 24"
                                            fill="none"
                                            stroke="#b8b7b7"
                                            strokeWidth="2"
                                            strokeLinecap="round"
                                            strokeLinejoin="round"
                                          >
                                            <rect
                                              x="9"
                                              y="9"
                                              width="13"
                                              height="13"
                                              rx="2"
                                              ry="2"
                                            />
                                            <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1" />
                                          </svg>
                                        </span>
                                      </div>
                                      <div className="mini-user-points">
                                        14.448
                                        <img
                                          src={crystalxp}
                                          width="14"
                                          height="14"
                                          alt="XP"
                                        />
                                      </div>
                                    </div>

                                    <div className="mini-top-users">
                                      <div className="mini-top-user mini-top-user-1">
                                        <span className="mini-top-rank mini-top-rank-1">
                                          1
                                        </span>
                                        <img
                                          className="mini-user-pfp"
                                          src={firstPlacePfp}
                                        />
                                        <div className="mini-points-container">
                                          <img
                                            src={crystalxp}
                                            className="mini-token-icon"
                                            alt="Token"
                                          />
                                          <span className="mini-top-points">
                                            234,236
                                          </span>
                                        </div>
                                      </div>

                                      <div className="mini-top-user mini-top-user-2">
                                        <span className="mini-top-rank mini-top-rank-2">
                                          2
                                        </span>
                                        <img
                                          className="mini-user-pfp"
                                          src={secondPlacePfp}
                                        />
                                        <div className="mini-points-container">
                                          <img
                                            src={crystalxp}
                                            className="mini-token-icon"
                                            alt="Token"
                                          />
                                          <span className="mini-top-points">91,585</span>
                                        </div>
                                      </div>

                                      <div className="mini-top-user mini-top-user-3">
                                        <span className="mini-top-rank mini-top-rank-3">
                                          3
                                        </span>
                                        <img
                                          className="mini-user-pfp"
                                          src={thirdPlacePfp}
                                        />
                                        <div className="mini-points-container">
                                          <img
                                            src={crystalxp}
                                            className="mini-token-icon"
                                            alt="Token"
                                          />
                                          <span className="mini-top-points">52,181</span>
                                        </div>
                                      </div>
                                    </div>
                                  </div>
                                </div>
                              </div>
                            )}

                            {currentStep === 2 && (
                              <div className="rewards-container">
                                <div className="rewards-stage">
                                  <img className="lbstand" src={lbstand} />
                                </div>
                              </div>
                            )}
                          </div>
                        </div>
                      </div>
                    </div>

                    <div className="account-setup-footer">
                      {currentStep > 0 ? (
                        <button className="back-button" onClick={handleBackClick}>
                          {t('back')}
                        </button>
                      ) : (
                        <button
                          className="back-to-username-button"
                          onClick={handleBackToUsernameWithAudio}
                        >
                          {t('back')}
                        </button>
                      )}

                      <button className="next-button" onClick={handleNextClick}>
                        {currentStep < 2 ? t('next') : t('getStarted')}
                      </button>

                      <audio ref={backAudioRef} src={backaudio} preload="auto" />
                    </div>
                  </div>
                </div>
              </>
            ) : (
              !user && (
                <div
                  className="connect-wallet-username-onboarding-bg"
                >
                  {showWelcomeScreen || isTransitioning ? (
                    <div className={`crystal-welcome-screen ${isWelcomeExiting ? 'welcome-screen-exit' : ''}`}>
                      <div className="welcome-screen-content">
                        <div className="welcome-text-container">
                          <p className="welcome-text"></p>
                        </div>
                        {animationStarted ? (
                          <button
                            className="welcome-enter-button"
                            onClick={handleWelcomeTransition}
                          >
                            EXPLORE NOW
                          </button>
                        ) : (
                          <button
                            className="welcome-enter-button noshow"
                            onClick={handleWelcomeTransition}
                          >
                            EXPLORE NOW
                          </button>
                        )}
                      </div>
                    </div>
                  ) : (
                    <div className={`connect-wallet-username-wrapper ${!showWelcomeScreen || isConnectEntering ? 'connect-wallet-enter' : 'connect-wallet-hidden'}`}>
                      <div className="onboarding-connect-wallet">
                        <div className="smart-wallet-reminder">
                          <img className="onboarding-info-icon" src={infoicon} />
                          Use a Smart Wallet to receive a multiplier on all Crystals
                        </div>
                        <div className="connect-wallet-content-container">
                          <AuthCard {...alchemyconfig.ui.auth} />
                        </div>
                      </div>
                    </div>
                  )}
                </div>
              )
            )}
          </div>
        ) : null}
        {popup === 16 ? (
          <div className="edit-username-bg">
            <div ref={popupref} className="edit-username-container">
              <div className="onboarding-split-container">
                <div className="onboarding-content">
                  <div className="onboarding-header">
                    <h2 className="onboarding-title">{t("editUsername")}</h2>
                    <p className="onboarding-subtitle">{t("editUsernameSubtitle")}</p>
                  </div>

                  <div className="onboarding-form">
                    <div className="form-group">
                      <label className="form-label">{t("yourWalletAddress")}</label>
                      <div className="wallet-address">{address || "0x1234...5678"}</div>
                    </div>

                    <div className="form-group">
                      <label htmlFor="username" className="form-label">{t('username')}</label>
                      <input
                        type="text"
                        id="username"
                        className="username-input"
                        placeholder="Enter a username"
                        value={usernameInput || ""}
                        onChange={e => {
                          const value = e.target.value.trim();
                          if (isValidInput(value) || value === "") {
                            setUsernameInput(value);
                          }
                        }}
                      />
                      {usernameError && (
                        <p className="username-error">{usernameError}</p>
                      )}
                    </div>
                  </div>
                  <button
                    className={`create-username-button ${isUsernameSigning ? 'signing' : ''} ${!usernameInput.trim() ? 'disabled' : ''}`}
                    onClick={async () => {
                      if (!usernameInput.trim() || isUsernameSigning) return;
                      await handleEditUsername(usernameInput);
                    }}
                    disabled={!usernameInput.trim() || isUsernameSigning}
                  >
                    {isUsernameSigning ? (
                      <div className="button-content">
                        <div className="loading-spinner" />
                        {t('signTransaction')}
                      </div>
                    ) : (
                      t("editUsername")
                    )}
                  </button>
                </div>

              </div>
            </div>
          </div>
        ) : null}
        {popup === 19 ? (
          <div className="edit-limit-price-popup-bg" ref={popupref}>
            <div className="edit-limit-price-header">
              <span className="edit-limit-price-title">Edit Limit Price</span>
              <span className="edit-limit-price-subtitle">Adjust the price at which your limit order will trigger</span>
            </div>
            <div className="edit-limit-price-content">
              <input
                className="edit-limit-price-input"
                type="text"
                inputMode="decimal"
                value={currentLimitPriceString}
                placeholder="0.00"
                onChange={e => {
                  const val = e.target.value;
                  if (
                    new RegExp(
                      `^\\d*\\.?\\d{0,${Math.floor(Math.log10(Number(activeMarket.priceFactor)))}}$`
                    ).test(val) && (activeMarket?.marketType != 0 ? val.replace(/^0+|\.|e.*$/gi, '').replace(/^0+/, '').replace(/0+$/, match => '').length <= 5 : true)
                  ) {
                    setCurrentLimitPriceString(val);
                    setHasEditedPrice(true);

                    const num = parseFloat(val);
                    if (!isNaN(num)) setCurrentLimitPrice(num);
                  }
                }}
              />

              {(() => {
                const isBuyOrder = editingOrder[3] === 1;
                const market = markets[editingOrder[4]];
                let midPriceRaw = 0;
                if (mids?.[editingOrder[4]]?.[0]) {
                  const m = mids[editingOrder[4]];
                  midPriceRaw = isBuyOrder
                    ? (m[0] === m[1] ? m[2] : m[0])
                    : (m[0] === m[2] ? m[1] : m[0]);
                }
                const midPrice = market.priceFactor
                  ? Number(midPriceRaw) / Number(market.priceFactor)
                  : 0;
                const showWarning =
                  midPrice > 0 &&
                  ((isBuyOrder && currentLimitPrice > midPrice) ||
                    (!isBuyOrder && currentLimitPrice < midPrice));

                return showWarning ? (
                  <div className="edit-limit-price-warning">
                    <span>
                      {isBuyOrder
                        ? t('priceOutOfRangeWarningBuy')
                        : t('priceOutOfRangeWarningSell')}
                    </span>
                  </div>
                ) : null;
              })()}

              <div className="edit-limit-price-button-container">
                {[0.995, 0.99, 0.975, 0.95].map(factor => {
                  const label = `${((factor - 1) * 100).toFixed(2)}%`;
                  return (
                    <button
                      key={factor}
                      className="edit-limit-price-level-button"
                      onClick={() => {
                        const isBuyOrder = editingOrder[3] === 1;
                        const raw =
                          currentLimitPrice *
                          (isBuyOrder ? factor : 1 / factor);
                        const decimals = Math.floor(
                          Math.log10(Number(markets[editingOrder[4]].priceFactor))
                        );
                        const newPrice = parseFloat(raw.toFixed(decimals));
                        setCurrentLimitPrice(newPrice);
                        setCurrentLimitPriceString(newPrice.toFixed(decimals));
                        setHasEditedPrice(true);
                      }}
                    >
                      {editingOrder[3] === 1 ? label : `+${label.slice(1)}`}
                    </button>
                  );
                })}
              </div>

              <div className="edit-limit-price-actions">
                <div className="edit-limit-price-actions">
                  <button
                    className="edit-limit-price-confirm-button"
                    onClick={handleEditLimitPriceConfirm}
                    disabled={isEditingSigning || !hasEditedPrice}
                    style={{
                      opacity: isEditingSigning || !hasEditedPrice ? 0.5 : 1,
                      cursor: isEditingSigning || !hasEditedPrice
                        ? 'not-allowed'
                        : 'pointer',
                    }}
                  >
                    {isEditingSigning ? (
                      <div className="signing-indicator">
                        <div className="loading-spinner" />
                        {validOneCT ? null : <span>{t('signTransaction')}</span>}
                      </div>
                    ) : (
                      'Confirm'
                    )}
                  </button>
                </div>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 20 ? (
          <div className="edit-order-size-popup-bg" ref={popupref}>
            <div className="edit-order-size-header">
              <span className="edit-order-size-title">Edit Order Size</span>
              <span className="edit-order-size-subtitle">Adjust the size of your limit order</span>
            </div>
            <div className="edit-order-size-content">
              {(() => {
                if (!editingOrderSize) return null;

                const tokenAddress = editingOrderSize[3] === 1 ? markets[editingOrderSize[4]].quoteAddress : markets[editingOrderSize[4]].baseAddress;
                const tokenBalance = tokenBalances[tokenAddress] || BigInt(0);
                const tokenDecimals = Number(tokendict[tokenAddress]?.decimals || 18);
                const availableBalance = Number(tokenBalance) / (10 ** tokenDecimals);

                return (
                  <div className="edit-order-size-balance-display">
                    <img src={walleticon} className="balance-wallet-icon" />{' '}
                    <span className="balance-value">{availableBalance.toFixed(2)}</span>
                  </div>
                );
              })()}

              <div className="edit-order-size-input-container">
                <input
                  className="edit-order-size-input"
                  type="text"
                  inputMode="decimal"
                  value={displayValue}
                  placeholder="0.00"
                  onChange={e => {
                    const val = e.target.value;
                    if (!/^\d*(?:\.\d{0,8})?$/.test(val)) return;
                    setOrderSizeString(val);
                    setHasEditedSize(true);

                    if (val === '' || val === '.') {
                      setCurrentOrderSize(0);
                      setOrderSizePercent(0);
                    } else {
                      const num = parseFloat(val);
                      setCurrentOrderSize(num);
                      const pct = originalOrderSize > 0
                        ? Math.round((num / originalOrderSize) * 100)
                        : 100;
                      setOrderSizePercent(Math.min(200, Math.max(0, pct)));
                    }
                  }}
                />
                <span className="edit-order-size-token-label">
                  {editingOrderSize
                    ? tokendict[
                      editingOrderSize[3] === 1
                        ? markets[editingOrderSize[4]].quoteAddress
                        : markets[editingOrderSize[4]].baseAddress
                    ]?.ticker
                    : ''}
                </span>
              </div>

              <div className="order-size-balance-slider-wrapper">
                <div className="order-size-slider-container">
                  <input
                    type="range"
                    className="order-size-balance-amount-slider"
                    min="0"
                    max="200"
                    step="1"
                    value={orderSizePercent}
                    onChange={e => {
                      const pct = parseInt(e.target.value, 10)
                      const newSize = (originalOrderSize * pct) / 100

                      setOrderSizePercent(pct)
                      setCurrentOrderSize(newSize)
                      setOrderSizeString(newSize === 0 ? '' : newSize.toFixed(2))
                      setHasEditedSize(true)

                      const rect = e.target.getBoundingClientRect()
                      const thumb = (pct / 200) * (rect.width - 15) + 15 / 2
                      const popup = document.querySelector('.order-size-slider-percentage-popup')
                      if (popup) (popup as HTMLElement).style.left = `${thumb}px`
                    }}
                    onMouseDown={() => {
                      const popup = document.querySelector('.order-size-slider-percentage-popup')
                      if (popup) popup.classList.add('visible')
                    }}
                    onMouseUp={() => {
                      const popup = document.querySelector('.order-size-slider-percentage-popup')
                      if (popup) popup.classList.remove('visible')
                    }}
                    style={{
                      background: `linear-gradient(to right, rgb(171, 176, 224) ${(orderSizePercent / 200) * 100}%, rgb(21 21 27) ${(orderSizePercent / 200) * 100}%)`,
                    }}
                  />
                  <div className="order-size-slider-percentage-popup">{orderSizePercent}%</div>
                  <div className="order-size-balance-slider-marks">
                    {[0, 50, 100, 150, 200].map((markPercent) => (
                      <span
                        key={markPercent}
                        className="order-size-balance-slider-mark"
                        data-active={orderSizePercent >= markPercent}
                        data-percentage={markPercent}
                        onClick={() => {
                          const newSize = (originalOrderSize * markPercent) / 100;
                          setOrderSizePercent(markPercent);
                          setCurrentOrderSize(parseFloat(newSize.toFixed(8)));
                          setHasEditedSize(true);

                          const slider = document.querySelector('.order-size-balance-amount-slider');
                          const popup = document.querySelector('.order-size-slider-percentage-popup');
                          if (slider && popup) {
                            const rect = slider.getBoundingClientRect();
                            (popup as HTMLElement).style.left = `${(rect.width - 15) * (markPercent / 200) + 15 / 2}px`;
                          }
                        }}
                      >
                        {markPercent}%
                      </span>
                    ))}
                  </div>
                </div>
              </div>

              <div className="edit-order-size-actions">
                <button
                  className="edit-order-size-confirm-button"
                  onClick={handleEditOrderSizeConfirm}
                  disabled={(() => {
                    if (!editingOrderSize) return true;

                    const tokenAddress = editingOrderSize[3] === 1 ? markets[editingOrderSize[4]].quoteAddress : markets[editingOrderSize[4]].baseAddress;
                    const tokenBalance = tokenBalances[tokenAddress] || BigInt(0);
                    const tokenDecimals = Number(tokendict[tokenAddress]?.decimals || 18);
                    const availableBalance = Number(tokenBalance) / (10 ** tokenDecimals);
                    const market = markets[editingOrderSize[4]];
                    const baseDecimals = Number(market.baseDecimals);
                    const currentUnfilledAmount = (editingOrderSize[2] - editingOrderSize[7]) / (10 ** baseDecimals);
                    const additionalAmountNeeded = Math.max(0, currentOrderSize - currentUnfilledAmount);
                    const hasInsufficientBalance = additionalAmountNeeded > availableBalance;
                    const isUsdcBacked = market.quoteAsset === 'USDC';
                    const minSize = isUsdcBacked ? 1 : 0.1;
                    const isBelowMinSize = currentOrderSize > 0 && (editingOrderSize[3] === 1 ? currentOrderSize : currentOrderSize * editingOrderSize[0] / Number(market.priceFactor)) < minSize;

                    return isEditingSizeSigning || !hasEditedSize || currentOrderSize <= 0 || hasInsufficientBalance || isBelowMinSize;
                  })()}
                  style={{
                    opacity: (() => {
                      if (!editingOrderSize) return 0.5;

                      const tokenAddress = editingOrderSize[3] === 1 ? markets[editingOrderSize[4]].quoteAddress : markets[editingOrderSize[4]].baseAddress;
                      const tokenBalance = tokenBalances[tokenAddress] || BigInt(0);
                      const tokenDecimals = Number(tokendict[tokenAddress]?.decimals || 18);
                      const availableBalance = Number(tokenBalance) / (10 ** tokenDecimals);

                      const market = markets[editingOrderSize[4]];
                      const baseDecimals = Number(market.baseDecimals);
                      const currentUnfilledAmount = (editingOrderSize[2] - editingOrderSize[7]) / (10 ** baseDecimals);
                      const additionalAmountNeeded = Math.max(0, currentOrderSize - currentUnfilledAmount);
                      const hasInsufficientBalance = additionalAmountNeeded > availableBalance;
                      const isUsdcBacked = market.quoteAsset === 'USDC';
                      const minSize = isUsdcBacked ? 1 : 0.1;
                      const isBelowMinSize = currentOrderSize > 0 && (editingOrderSize[3] === 1 ? currentOrderSize : currentOrderSize * editingOrderSize[0] / Number(market.priceFactor)) < minSize;

                      return (isEditingSizeSigning || !hasEditedSize || currentOrderSize <= 0 || hasInsufficientBalance || isBelowMinSize) ? 0.5 : 1;
                    })(),
                    cursor: (() => {
                      if (!editingOrderSize) return 'not-allowed';

                      const tokenAddress = editingOrderSize[3] === 1 ? markets[editingOrderSize[4]].quoteAddress : markets[editingOrderSize[4]].baseAddress;
                      const tokenBalance = tokenBalances[tokenAddress] || BigInt(0);
                      const tokenDecimals = Number(tokendict[tokenAddress]?.decimals || 18);
                      const availableBalance = Number(tokenBalance) / (10 ** tokenDecimals);

                      const market = markets[editingOrderSize[4]];
                      const baseDecimals = Number(market.baseDecimals);
                      const currentUnfilledAmount = (editingOrderSize[2] - editingOrderSize[7]) / (10 ** baseDecimals);
                      const additionalAmountNeeded = Math.max(0, currentOrderSize - currentUnfilledAmount);
                      const hasInsufficientBalance = additionalAmountNeeded > availableBalance;

                      const isUsdcBacked = market.quoteAsset === 'USDC';
                      const minSize = isUsdcBacked ? 1 : 0.1;
                      const isBelowMinSize = currentOrderSize > 0 && (editingOrderSize[3] === 1 ? currentOrderSize : currentOrderSize * editingOrderSize[0] / Number(market.priceFactor)) < minSize;

                      return (isEditingSizeSigning || !hasEditedSize || currentOrderSize <= 0 || hasInsufficientBalance || isBelowMinSize) ? 'not-allowed' : 'pointer';
                    })()
                  }}
                >
                  {(() => {
                    if (!editingOrderSize) return null;
                    const isBuy = editingOrderSize[3] === 1;
                    const market = markets[editingOrderSize[4]];

                    let quotePrice = 1;
                    if (market.quoteAsset !== 'USDC') {
                      const cfg = settings.chainConfig[activechain];
                      const key = `${market.quoteAsset === cfg.wethticker
                        ? cfg.ethticker
                        : market.quoteAsset}USDC`;

                      const tradesMap = trades as any as Record<string, any[]>;
                      const marketsMap = markets as any as Record<string, any>;

                      const lastTrade = tradesMap[key]?.[0]?.[3] ?? 0;
                      const priceFactor = Number(marketsMap[key]?.priceFactor ?? 1);
                      quotePrice = lastTrade / priceFactor;
                    }
                    const baseFilled =
                      editingOrderSize[7] / 10 ** Number(market.baseDecimals);

                    const unfilledInput = isBuy
                      ? originalOrderSize - baseFilled * quotePrice
                      : (editingOrderSize[2] - editingOrderSize[7]) /
                      10 ** Number(market.baseDecimals);

                    const needed = Math.max(0, currentOrderSize - unfilledInput);

                    const inputAddr = isBuy ? market.quoteAddress : market.baseAddress;
                    const available =
                      Number((tokenBalances as any)[inputAddr] ?? BigInt(0)) /
                      10 ** Number((tokendict as any)[inputAddr]?.decimals ?? 18);
                    const isUsdcBacked = market.quoteAsset === 'USDC';
                    const minSize = isUsdcBacked ? 1 : 0.1;
                    const minSizeToken = isUsdcBacked ? 'USDC' : 'MON';
                    const isBelowMinSize = currentOrderSize > 0 && (isBuy ? currentOrderSize : currentOrderSize * editingOrderSize[0] / Number(market.priceFactor)) < minSize;

                    if (needed > available) {
                      return (
                        `Insufficient ${(tokendict as any)[inputAddr]?.ticker} Balance`
                      );
                    }
                    else if (isBelowMinSize) {
                      return (
                        `Minimum order size is ${minSize} ${minSizeToken}`
                      );
                    }

                    return null;
                  })() ?? (isEditingSizeSigning ? (
                    <div className="signing-indicator">
                      <div className="loading-spinner"></div>
                      <span>{t('signTransaction')}</span>
                    </div>
                  ) : (
                    'Confirm'
                  ))}
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 21 ? (<></>) : null}
        {popup === 22 ? (
          <div className="modal-overlay">
            <div className="modal-content vault-action-modal" ref={popupref}>
              <div className="modal-header">
                <h2>Deposit to {selectedVault?.name}</h2>
                <button
                  className="modal-close"
                  onClick={() => {
                    setpopup(0);
                    setselectedVault(null);
                    setVaultDepositAmounts({ shares: 0n, quote: 0n, base: 0n });
                    setVaultInputStrings({ quote: '', base: '' });
                    setVaultQuoteExceedsBalance(false);
                    setVaultBaseExceedsBalance(false);
                    setDepositVaultStep('idle');
                    setDepositVaultError('');
                  }}
                >
                  <img src={closebutton} className="close-button-icon" />
                </button>
              </div>

              <div className="modal-body">
                {depositVaultStep === 'idle' && (
                  <div className="vault-deposit-form">
                    <div className="deposit-amounts-section">
                      <div className={`deposit-input-group ${vaultQuoteExceedsBalance ? 'lp-input-container-balance-error' : ''}`}>
                        <div className="deposit-input-wrapper">
                          <input
                            type="text"
                            placeholder="0.0"
                            className={`deposit-amount-input ${vaultQuoteExceedsBalance ? 'lp-input-balance-error' : ''}`}
                            value={vaultInputStrings.quote}
                            onChange={(e) => handleVaultDepositAmountChange('quote', e.target.value)}
                          />
                          <div className="deposit-token-badge">
                            <img
                              src={tokendict[selectedVault?.quoteAsset]?.image}
                              className="deposit-token-icon"
                            />
                            <span>{tokendict[selectedVault?.quoteAsset]?.ticker}</span>
                          </div>
                        </div>

                        <div className="lp-deposit-balance-wrapper">
                          <div className={`lp-deposit-usd-value ${vaultQuoteExceedsBalance ? 'lp-usd-value-balance-error' : ''}`}>
                            {vaultDepositAmounts.quote == 0n
                              ? '$0.00'
                              : formatUSDDisplay(
                                calculateUSDValue(
                                  vaultDepositAmounts.quote,
                                  tradesByMarket[
                                  (({ baseAsset, quoteAsset }) =>
                                    (baseAsset === wethticker ? ethticker : baseAsset) +
                                    (quoteAsset === wethticker ? ethticker : quoteAsset)
                                  )(getMarket(selectedVault?.quoteAsset, selectedVault?.baseAsset))
                                  ],
                                  selectedVault?.quoteAsset,
                                  getMarket(
                                    selectedVault?.quoteAsset,
                                    selectedVault?.baseAsset,
                                  ),
                                ),
                              )}
                          </div>
                          <div className="deposit-balance">
                            <div className="deposit-balance-value">
                              <img src={walleticon} className="balance-wallet-icon" />
                              {selectedVault?.quoteAsset ? formatDisplayValue(
                                tokenBalances[selectedVault?.quoteAsset],
                                Number(tokendict[selectedVault?.quoteAsset]?.decimals || 18)
                              ) : '0.00'}
                            </div>
                            <button
                              className="vault-max-button"
                              onClick={() => {
                                if (selectedVault?.quoteAsset) {
                                  const maxAmount = formatDisplayValue(
                                    tokenBalances[selectedVault?.quoteAsset],
                                    Number(tokendict[selectedVault?.quoteAsset]?.decimals || 18)
                                  ).replace(/,/g, '');
                                  handleVaultDepositAmountChange('quote', maxAmount);
                                }
                              }}
                            >
                              Max
                            </button>
                          </div>
                        </div>
                      </div>
                      <div className={`deposit-input-group ${vaultBaseExceedsBalance ? 'lp-input-container-balance-error' : ''}`}>
                        <div className="deposit-input-wrapper">
                          <input
                            type="text"
                            placeholder="0.0"
                            className={`deposit-amount-input ${vaultBaseExceedsBalance ? 'lp-input-balance-error' : ''}`}
                            value={vaultInputStrings.base}
                            onChange={(e) => handleVaultDepositAmountChange('base', e.target.value)}
                          />
                          <div className="deposit-token-badge">
                            <img
                              src={tokendict[selectedVault?.baseAsset]?.image}
                              className="deposit-token-icon"
                            />
                            <span>{tokendict[selectedVault?.baseAsset]?.ticker}</span>
                          </div>
                        </div>

                        <div className="lp-deposit-balance-wrapper">
                          <div className={`lp-deposit-usd-value ${vaultBaseExceedsBalance ? 'lp-usd-value-balance-error' : ''}`}>
                            {vaultDepositAmounts.base == 0n
                              ? '$0.00'
                              : formatUSDDisplay(
                                calculateUSDValue(
                                  vaultDepositAmounts.base,
                                  tradesByMarket[
                                  (({ baseAsset, quoteAsset }) =>
                                    (baseAsset === wethticker ? ethticker : baseAsset) +
                                    (quoteAsset === wethticker ? ethticker : quoteAsset)
                                  )(getMarket(selectedVault?.quoteAsset, selectedVault?.baseAsset))
                                  ],
                                  selectedVault?.baseAsset,
                                  getMarket(
                                    selectedVault?.quoteAsset,
                                    selectedVault?.baseAsset,
                                  ),
                                ),
                              )}
                          </div>
                          <div className="deposit-balance">
                            <div className="deposit-balance-value">
                              <img src={walleticon} className="balance-wallet-icon" />
                              {selectedVault?.baseAsset ? formatDisplayValue(
                                tokenBalances[selectedVault?.baseAsset],
                                Number(tokendict[selectedVault?.baseAsset]?.decimals || 18)
                              ) : '0.00'}
                            </div>
                            <button
                              className="vault-max-button"
                              onClick={() => {
                                if (selectedVault?.baseAsset) {
                                  const maxAmount = formatDisplayValue(
                                    tokenBalances[selectedVault?.baseAsset],
                                    Number(tokendict[selectedVault?.baseAsset]?.decimals || 18)
                                  ).replace(/,/g, '');
                                  handleVaultDepositAmountChange('base', maxAmount);
                                }
                              }}
                            >
                              Max
                            </button>
                          </div>
                        </div>
                      </div>
                    </div>

                    {vaultDepositAmounts && (
                      <div className="withdraw-preview">
                        <div className="preview-title">Your position:</div>
                        <div className="withdraw-token-preview">
                          <div className="withdraw-token-item">
                            <div className="deposit-token-info">
                              <img
                                src={tokendict[selectedVault?.quoteAsset]?.image}
                                className="withdraw-token-icon"
                              />
                              <span className="token-symbol">
                                {tokendict[selectedVault?.quoteAsset]?.ticker}
                              </span>
                            </div>
                            <span className="token-amount">
                              <span className="deposit-token-amount-before">
                                {formatDisplayValue(BigInt(selectedVault?.quoteBalance * selectedVault?.userShares / selectedVault?.totalShares), Number(tokendict[selectedVault?.quoteAsset]?.decimals || 18))}
                              </span>
                              {vaultDepositAmounts.quote > 0n && (
                                <>
                                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-arrow-right-icon lucide-arrow-right" style={{ margin: '0 4px', opacity: 0.7 }}>
                                    <path d="M5 12h14" />
                                    <path d="m12 5 7 7-7 7" />
                                  </svg>
                                  {formatDisplayValue(BigInt(selectedVault?.quoteBalance * selectedVault?.userShares / selectedVault?.totalShares) + vaultDepositAmounts.quote, Number(tokendict[selectedVault?.quoteAsset]?.decimals || 18))}
                                </>
                              )}
                            </span>
                          </div>
                          <div className="withdraw-token-item">
                            <div className="deposit-token-info">
                              <img
                                src={tokendict[selectedVault?.baseAsset]?.image}
                                className="withdraw-token-icon"
                              />
                              <span className="token-symbol">
                                {tokendict[selectedVault?.baseAsset]?.ticker}
                              </span>
                            </div>
                            <span className="token-amount">
                              <span className="deposit-token-amount-before">
                                {formatDisplayValue(BigInt(selectedVault?.baseBalance * selectedVault?.userShares / selectedVault?.totalShares), Number(tokendict[selectedVault?.baseAsset]?.decimals || 18))}
                              </span>
                              {vaultDepositAmounts.base > 0n && (
                                <>
                                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-arrow-right-icon lucide-arrow-right" style={{ margin: '0 4px', opacity: 0.7 }}>
                                    <path d="M5 12h14" />
                                    <path d="m12 5 7 7-7 7" />
                                  </svg>
                                  {formatDisplayValue(BigInt(selectedVault?.baseBalance * selectedVault?.userShares / selectedVault?.totalShares) + vaultDepositAmounts.base, Number(tokendict[selectedVault?.baseAsset]?.decimals || 18))}
                                </>
                              )}
                            </span>
                          </div>
                        </div>
                      </div>
                    )}

                    <div className="deposit-summary">
                      <div className="deposit-summary-row">
                        <span className="preview-title">Share of vault:</span>
                        <span className="token-amount">
                          <span className="deposit-token-amount-before">
                            {formatDisplayValue(Number(selectedVault?.userShares) / Number(selectedVault?.totalShares), -2)}%
                          </span>
                          {vaultDepositAmounts.shares > 0n && (
                            <>
                              <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-arrow-right-icon lucide-arrow-right" style={{ margin: '0 4px', opacity: 0.7 }}>
                                <path d="M5 12h14" />
                                <path d="m12 5 7 7-7 7" />
                              </svg>
                              {formatDisplayValue((Number(selectedVault?.userShares) + Number(vaultDepositAmounts?.shares)) / (Number(selectedVault?.totalShares) + Number(vaultDepositAmounts?.shares)), -2)}%
                            </>
                          )}
                        </span>
                      </div>
                    </div>
                  </div>
                )}

                {depositVaultStep !== 'idle' && (
                  <div className="create-vault-progress-container">
                    <div className="create-vault-progress-steps">
                      {/* Step 1: Validating */}
                      <div className={`create-vault-progress-step ${depositVaultStep === 'validating' ? 'active' :
                        ['approve-quote', 'approve-base', 'depositing', 'success'].includes(depositVaultStep) ? 'completed' : ''
                        }`}>
                        <div className="step-progress-indicator">
                          {['approve-quote', 'approve-base', 'depositing', 'success'].includes(depositVaultStep) ? (
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                              <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                            </svg>
                          ) : (
                            <span>1</span>
                          )}
                        </div>
                        <div className="step-progress-content">
                          <div className="step-progress-title">Validating</div>
                          <div className="step-progress-description">Checking balances and amounts</div>
                        </div>
                      </div>

                      {selectedVault?.quoteAsset && selectedVault.quoteAsset.toLowerCase() !== eth.toLowerCase() && vaultDepositAmounts.quote > 0n && (
                        <div className={`create-vault-progress-step ${depositVaultStep === 'approve-quote' ? 'active' :
                          ['approve-base', 'depositing', 'success'].includes(depositVaultStep) ? 'completed' : ''
                          }`}>
                          <div className="step-progress-indicator">
                            {['approve-base', 'depositing', 'success'].includes(depositVaultStep) ? (
                              <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                              </svg>
                            ) : (
                              <span>2</span>
                            )}
                          </div>
                          <div className="step-progress-content">
                            <div className="step-progress-title">
                              Approve {tokendict[selectedVault.quoteAsset]?.ticker || 'Quote Token'}
                            </div>
                            <div className="step-progress-description">Grant vault contract permission</div>
                          </div>
                        </div>
                      )}

                      {selectedVault?.baseAsset && selectedVault.baseAsset.toLowerCase() !== eth.toLowerCase() && vaultDepositAmounts.base > 0n && (
                        <div className={`create-vault-progress-step ${depositVaultStep === 'approve-base' ? 'active' :
                          ['depositing', 'success'].includes(depositVaultStep) ? 'completed' : ''
                          }`}>
                          <div className="step-progress-indicator">
                            {['depositing', 'success'].includes(depositVaultStep) ? (
                              <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                              </svg>
                            ) : (
                              <span>
                                {selectedVault.quoteAsset.toLowerCase() !== eth.toLowerCase() && vaultDepositAmounts.quote > 0n ? '3' : '2'}
                              </span>
                            )}
                          </div>
                          <div className="step-progress-content">
                            <div className="step-progress-title">
                              Approve {tokendict[selectedVault.baseAsset]?.ticker || 'Base Token'}
                            </div>
                            <div className="step-progress-description">Grant vault contract permission</div>
                          </div>
                        </div>
                      )}

                      <div className={`create-vault-progress-step ${depositVaultStep === 'depositing' ? 'active' :
                        depositVaultStep === 'success' ? 'completed' : ''
                        }`}>
                        <div className="step-progress-indicator">
                          {depositVaultStep === 'success' ? (
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                              <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                            </svg>
                          ) : (
                            <span>
                              {(() => {
                                let stepNum = 2;
                                if (selectedVault?.quoteAsset?.toLowerCase() !== eth.toLowerCase() && vaultDepositAmounts.quote > 0n) stepNum++;
                                if (selectedVault?.baseAsset?.toLowerCase() !== eth.toLowerCase() && vaultDepositAmounts.base > 0n) stepNum++;
                                return stepNum;
                              })()}
                            </span>
                          )}
                        </div>
                        <div className="step-progress-content">
                          <div className="step-progress-title">Depositing</div>
                          <div className="step-progress-description">Sending tokens to vault</div>
                        </div>
                      </div>
                    </div>

                  </div>
                )}
              </div>

              <div className="modal-footer">
                <button
                  className={`vault-confirm-button ${(depositVaultStep === 'idle' && (!isVaultDepositEnabled() || isVaultDepositSigning)) ? 'disabled' : ''
                    } ${depositVaultStep === 'success' ? 'success' : ''}`}
                  disabled={(!isVaultDepositEnabled() || isVaultDepositSigning || depositVaultStep === 'success')}
                  onClick={async () => {
                    if (!isVaultDepositEnabled()) return;

                    try {
                      setIsVaultDepositSigning(true);
                      setDepositVaultError('');

                      // Step 1: Validating
                      setDepositVaultStep('validating');
                      await new Promise(resolve => setTimeout(resolve, 500));

                      await handleSetChain();

                      const crystalVaultsAddress = settings.chainConfig[activechain]?.crystalVaults;
                      const quoteTokenAddress = selectedVault.quoteAsset;
                      const baseTokenAddress = selectedVault.baseAsset;

                      const amountQuoteDesired = vaultDepositAmounts.quote;
                      const amountBaseDesired = vaultDepositAmounts.base;

                      const amountQuoteMin = (amountQuoteDesired * 50n) / 100n;
                      const amountBaseMin = (amountBaseDesired * 50n) / 100n;

                      // Step 2: Approve Quote Token if needed
                      if (quoteTokenAddress !== '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' && vaultDepositAmounts.quote > 0n) {
                        setDepositVaultStep('approve-quote');
                        const approveQuoteUo = {
                          target: quoteTokenAddress as `0x${string}`,
                          data: encodeFunctionData({
                            abi: [{
                              inputs: [
                                { name: "spender", type: "address" },
                                { name: "amount", type: "uint256" }
                              ],
                              name: "approve",
                              outputs: [{ name: "", type: "bool" }],
                              stateMutability: "nonpayable",
                              type: "function",
                            }],
                            functionName: "approve",
                            args: [crystalVaultsAddress as `0x${string}`, maxUint256],
                          }),
                          value: 0n,
                        };
                        await sendUserOperationAsync({ uo: approveQuoteUo });
                      }

                      // Step 3: Approve Base Token if needed
                      if (baseTokenAddress !== '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' && vaultDepositAmounts.base > 0n) {
                        setDepositVaultStep('approve-base');
                        const approveBaseUo = {
                          target: baseTokenAddress as `0x${string}`,
                          data: encodeFunctionData({
                            abi: [{
                              inputs: [
                                { name: "spender", type: "address" },
                                { name: "amount", type: "uint256" }
                              ],
                              name: "approve",
                              outputs: [{ name: "", type: "bool" }],
                              stateMutability: "nonpayable",
                              type: "function",
                            }],
                            functionName: "approve",
                            args: [crystalVaultsAddress as `0x${string}`, maxUint256],
                          }),
                          value: 0n,
                        };
                        await sendUserOperationAsync({ uo: approveBaseUo });
                      }

                      // Step 4: Deposit
                      setDepositVaultStep('depositing');

                      const ethValue =
                        quoteTokenAddress === '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' ? amountQuoteDesired :
                          baseTokenAddress === '0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE' ? amountBaseDesired : 0n;

                      const depositUo = {
                        target: crystalVaultsAddress as `0x${string}`,
                        data: encodeFunctionData({
                          abi: CrystalVaultsAbi,
                          functionName: "deposit",
                          args: [
                            selectedVault.address as `0x${string}`,
                            quoteTokenAddress as `0x${string}`,
                            baseTokenAddress as `0x${string}`,
                            amountQuoteDesired,
                            amountBaseDesired,
                            amountQuoteMin,
                            amountBaseMin,
                          ],
                        }),
                        value: ethValue,
                      };

                      await sendUserOperationAsync({ uo: depositUo });

                      // Step 5: Success
                      setDepositVaultStep('success');

                      setTimeout(() => {
                        setpopup(0);
                        setselectedVault(null);
                        setVaultDepositAmounts({ shares: 0n, quote: 0n, base: 0n });
                        setVaultInputStrings({ quote: '', base: '' });
                        setVaultQuoteExceedsBalance(false);
                        setVaultBaseExceedsBalance(false);
                        setDepositVaultStep('idle');
                        setDepositVaultError('');
                        refetch?.();
                      }, 2000);

                    } catch (e: any) {
                      console.error('Vault deposit error:', e);
                      setDepositVaultError(e?.message || 'An error occurred while depositing. Please try again.');
                      setDepositVaultStep('idle');
                    } finally {
                      setIsVaultDepositSigning(false);
                    }
                  }}
                >
                  {depositVaultStep === 'success' ? (
                    <div className="button-content">
                      <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                      </svg>
                      Deposit Complete!
                    </div>
                  ) : depositVaultStep !== 'idle' ? (
                    <div className="button-content">
                      <div className="loading-spinner" />

                    </div>
                  ) : (
                    getVaultDepositButtonText()
                  )}
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 23 ? (
          <div className="modal-overlay">
            <div className="modal-content vault-action-modal" ref={popupref}>
              <div className="modal-header">
                <h2>Withdraw from {selectedVault?.name}</h2>
                <button
                  className="modal-close"
                  onClick={() => {
                    setpopup(0);
                    setselectedVault(null);
                    setWithdrawPercentage('');
                    setWithdrawExceedsBalance(false);
                    setWithdrawPreview(null);
                    setWithdrawVaultStep('idle');
                    setWithdrawVaultError('');
                  }}
                >
                  <img src={closebutton} className="close-button-icon" />
                </button>
              </div>

              <div className="modal-body">
                {withdrawVaultStep === 'idle' && (
                  <div className="vault-withdraw-form">
                    <div className="withdraw-section">
                      <div className="withdraw-amount-section">
                        <div className="withdraw-percentage-input-container">
                          <div className="withdraw-percentage-display">
                            <input
                              type="text"
                              inputMode="numeric"
                              placeholder="0"
                              value={withdrawPercentage}
                              onChange={(e) => handleWithdrawPercentageChange(e.target.value.replace(/[^\d]/g, ''))}
                              size={Math.max((withdrawPercentage || '0').length, 1)}
                              style={{ width: `${Math.max((withdrawPercentage || '0').length, 1)}ch` }}
                              className="withdraw-percentage-input"
                            />
                            <span style={{ color: `${withdrawPercentage ? '#FFF' : '#ededf571'}` }} className="withdraw-percentage-symbol">%</span>
                          </div>
                        </div>
                        <div className="percentage-buttons">
                          <button
                            className={`percentage-btn ${withdrawPercentage === '25' ? 'active' : ''}`}
                            onClick={() => handleWithdrawPercentageChange('25')}
                          >
                            25%
                          </button>
                          <button
                            className={`percentage-btn ${withdrawPercentage === '50' ? 'active' : ''}`}
                            onClick={() => handleWithdrawPercentageChange('50')}
                          >
                            50%
                          </button>
                          <button
                            className={`percentage-btn ${withdrawPercentage === '75' ? 'active' : ''}`}
                            onClick={() => handleWithdrawPercentageChange('75')}
                          >
                            75%
                          </button>
                          <button
                            className={`percentage-btn ${withdrawPercentage === '100' ? 'active' : ''}`}
                            onClick={() => handleWithdrawPercentageChange('100')}
                          >
                            Max
                          </button>
                        </div>
                      </div>
                      <div className="withdraw-preview">
                        <div className="preview-title">Your position:</div>
                        <div className="withdraw-token-preview">
                          <div className="withdraw-token-item">
                            <div className="deposit-token-info">
                              <img
                                src={tokendict[selectedVault?.quoteAsset]?.image}
                                className="withdraw-token-icon"
                              />
                              <span className="token-symbol">
                                {tokendict[selectedVault?.quoteAsset]?.ticker}
                              </span>
                            </div>
                            <span className="token-amount">
                              <span className="deposit-token-amount-before">
                                {formatDisplayValue(BigInt(selectedVault?.quoteBalance * selectedVault?.userShares / selectedVault?.totalShares), Number(tokendict[selectedVault?.quoteAsset]?.decimals || 18))}
                              </span>
                              {withdrawPreview?.amountQuote != undefined && (
                                <>
                                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-arrow-right-icon lucide-arrow-right" style={{ margin: '0 4px', opacity: 0.7 }}>
                                    <path d="M5 12h14" />
                                    <path d="m12 5 7 7-7 7" />
                                  </svg>
                                  {formatDisplayValue(BigInt(selectedVault?.quoteBalance * selectedVault?.userShares / selectedVault?.totalShares) - withdrawPreview?.amountQuote, Number(tokendict[selectedVault?.quoteAsset]?.decimals || 18))}
                                </>
                              )}
                            </span>
                          </div>
                          <div className="withdraw-token-item">
                            <div className="deposit-token-info">
                              <img
                                src={tokendict[selectedVault?.baseAsset]?.image}
                                className="withdraw-token-icon"
                              />
                              <span className="token-symbol">
                                {tokendict[selectedVault?.baseAsset]?.ticker}
                              </span>
                            </div>
                            <span className="token-amount">
                              <span className="deposit-token-amount-before">
                                {formatDisplayValue(BigInt(selectedVault?.baseBalance * selectedVault?.userShares / selectedVault?.totalShares), Number(tokendict[selectedVault?.baseAsset]?.decimals || 18))}
                              </span>
                              {withdrawPreview?.amountBase != undefined && (
                                <>
                                  <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-arrow-right-icon lucide-arrow-right" style={{ margin: '0 4px', opacity: 0.7 }}>
                                    <path d="M5 12h14" />
                                    <path d="m12 5 7 7-7 7" />
                                  </svg>
                                  {formatDisplayValue(BigInt(selectedVault?.baseBalance * selectedVault?.userShares / selectedVault?.totalShares) - withdrawPreview?.amountBase, Number(tokendict[selectedVault?.baseAsset]?.decimals || 18))}
                                </>
                              )}
                            </span>
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                )}

                {withdrawVaultStep !== 'idle' && (
                  <div className="create-vault-progress-container">
                    <div className="create-vault-progress-steps">
                      {/* Step 1: Validating */}
                      <div className={`create-vault-progress-step ${withdrawVaultStep === 'validating' ? 'active' :
                        ['withdrawing', 'success'].includes(withdrawVaultStep) ? 'completed' : ''
                        }`}>
                        <div className="step-progress-indicator">
                          {['withdrawing', 'success'].includes(withdrawVaultStep) ? (
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                              <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                            </svg>
                          ) : (
                            <span>1</span>
                          )}
                        </div>
                        <div className="step-progress-content">
                          <div className="step-progress-title">Validating</div>
                          <div className="step-progress-description">Checking withdrawal amount</div>
                        </div>
                      </div>

                      <div className={`create-vault-progress-step ${withdrawVaultStep === 'withdrawing' ? 'active' :
                        withdrawVaultStep === 'success' ? 'completed' : ''
                        }`}>
                        <div className="step-progress-indicator">
                          {withdrawVaultStep === 'success' ? (
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                              <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                            </svg>
                          ) : (
                            <span>2</span>
                          )}
                        </div>
                        <div className="step-progress-content">
                          <div className="step-progress-title">Withdrawing</div>
                          <div className="step-progress-description">Processing withdrawal from vault</div>
                        </div>
                      </div>
                    </div>
                  </div>
                )}
              </div>

              <div className="modal-footer">
                <button
                  className={`vault-confirm-button withdraw ${(withdrawVaultStep === 'idle' && (withdrawShares == '' || parseFloat(withdrawShares) == 0 ||
                    withdrawExceedsBalance || !withdrawPreview || isVaultWithdrawSigning)) ? 'disabled' : ''
                    } ${withdrawVaultStep === 'success' ? 'success' : ''}`}
                  disabled={withdrawVaultStep == 'success' || (withdrawShares == '' || parseFloat(withdrawShares) == 0 ||
                    withdrawExceedsBalance || !withdrawPreview || isVaultWithdrawSigning)}
                  onClick={async () => {
                    if (withdrawShares == '' || parseFloat(withdrawShares) == 0 ||
                      withdrawExceedsBalance || !withdrawPreview) return;

                    try {
                      setIsVaultWithdrawSigning(true);
                      setWithdrawVaultError('');

                      setWithdrawVaultStep('validating');
                      await new Promise(resolve => setTimeout(resolve, 500));

                      await handleSetChain();

                      const crystalVaultsAddress = settings.chainConfig[activechain]?.crystalVaults;

                      const amountQuoteMin = (withdrawPreview.amountQuote * 50n) / 100n;
                      const amountBaseMin = (withdrawPreview.amountBase * 50n) / 100n;

                      // Step 2: Withdrawing
                      setWithdrawVaultStep('withdrawing');

                      const withdrawUo = {
                        target: crystalVaultsAddress as `0x${string}`,
                        data: encodeFunctionData({
                          abi: CrystalVaultsAbi,
                          functionName: "withdraw",
                          args: [
                            selectedVault.address as `0x${string}`,
                            selectedVault.quoteAsset as `0x${string}`,
                            selectedVault.baseAsset as `0x${string}`,
                            BigInt(withdrawShares),
                            amountQuoteMin,
                            amountBaseMin,
                          ],
                        }),
                        value: 0n,
                      };

                      await sendUserOperationAsync({ uo: withdrawUo });

                      // Step 3: Success
                      setWithdrawVaultStep('success');

                      setTimeout(() => {
                        setpopup(0);
                        setselectedVault(null);
                        setWithdrawPercentage('');
                        setWithdrawExceedsBalance(false);
                        setWithdrawPreview(null);
                        setWithdrawVaultStep('idle');
                        setWithdrawVaultError('');
                        refetch?.();
                      }, 2000);

                    } catch (e: any) {
                      console.error('Vault withdrawal error:', e);
                      setWithdrawVaultError(e?.message || 'An error occurred while withdrawing. Please try again.');
                      setWithdrawVaultStep('idle');
                    } finally {
                      setIsVaultWithdrawSigning(false);
                    }
                  }}
                >
                  {withdrawVaultStep === 'success' ? (
                    <div className="button-content">
                      <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                      </svg>
                      Withdrawal Complete!
                    </div>
                  ) : withdrawVaultStep !== 'idle' ? (
                    <div className="button-content">
                      <div className="loading-spinner" />
                    </div>
                  ) : (
                    getWithdrawButtonText()
                  )}
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 24 ? (
          <div className="explorer-filters-popup" ref={popupref}>
            <div className="explorer-filters-header">
              <h2 className="filters-title">Filters</h2>
              <button className="filters-close-button" onClick={() => setpopup(0)}>
                <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                  <line x1="18" y1="6" x2="6" y2="18"></line>
                  <line x1="6" y1="6" x2="18" y2="18"></line>
                </svg>
              </button>
            </div>
            <div className="status-tabs">
              <button
                className={`status-tab ${explorerFiltersActiveTab === 'new' ? 'active' : ''}`}
                onClick={() => handleExplorerTabSwitch('new')}
              >
                New Pairs
              </button>
              <button
                className={`status-tab ${explorerFiltersActiveTab === 'graduating' ? 'active' : ''}`}
                onClick={() => handleExplorerTabSwitch('graduating')}
              >
                Graduating
              </button>
              <button
                className={`status-tab ${explorerFiltersActiveTab === 'graduated' ? 'active' : ''}`}
                onClick={() => handleExplorerTabSwitch('graduated')}
              >
                Graduated
              </button>
              <button className="explorer-revert-button" onClick={handleExplorerFiltersReset}>
                <img className="filters-reset-icon" src={reset} />
              </button>
            </div>
            <div className="protocols-section">
              <span className="keyword-label">Protocols</span>
              <div className="protocols-content">
                <div className="protocol-crystal-container">
                  <img className="protocol-crystal" src={crystal} />
                  <span className="protocol-crystal">crystal.fun</span>
                </div>
                <div className="protocol-nadfun-container">
                  <svg width="15" height="15" viewBox="0 0 32 32" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <defs>
                      <linearGradient id="nadfun" x1="0%" y1="0%" x2="100%" y2="0%">
                        <stop offset="0%" stopColor="#7C55FF" stopOpacity="1" />
                        <stop offset="100%" stopColor="#AD5FFB" stopOpacity="1" />
                      </linearGradient>
                    </defs>
                    <path fill="url(#nadfun)" d="m29.202 10.664-4.655-3.206-3.206-4.653A6.48 6.48 0 0 0 16.004 0a6.48 6.48 0 0 0-5.337 2.805L7.46 7.458l-4.654 3.206a6.474 6.474 0 0 0 0 10.672l4.654 3.206 3.207 4.653A6.48 6.48 0 0 0 16.004 32a6.5 6.5 0 0 0 5.337-2.805l3.177-4.616 4.684-3.236A6.49 6.49 0 0 0 32 16.007a6.47 6.47 0 0 0-2.806-5.335zm-6.377 5.47c-.467 1.009-1.655.838-2.605 1.06-2.264.528-2.502 6.813-3.05 8.35-.424 1.484-1.916 1.269-2.272 0-.631-1.53-.794-6.961-2.212-7.993-.743-.542-2.502-.267-3.177-.95-.668-.675-.698-1.729-.023-2.412l5.3-5.298a1.734 1.734 0 0 1 2.45 0l5.3 5.298c.505.505.586 1.306.297 1.937z" />
                  </svg>
                  <span className="protocol-nadfun">nad.fun</span>
                </div>
              </div>
            </div>
            <div className="keywords-section">
              <div className="keyword-group">
                <div className="keyword-label">Search Keywords</div>
                <input
                  type="text"
                  placeholder="keyword1, keyword2..."
                  value={explorerFilters[explorerFiltersActiveTab]?.searchKeywords || ''}
                  onChange={(e) => handleExplorerFilterInputChange('searchKeywords', e.target.value)}
                  className="keyword-input"
                />
              </div>
              <div className="keyword-group">
                <div className="keyword-label">Exclude Keywords</div>
                <input
                  type="text"
                  placeholder="keyword1, keyword2..."
                  value={explorerFilters[explorerFiltersActiveTab]?.excludeKeywords || ''}
                  onChange={(e) => handleExplorerFilterInputChange('excludeKeywords', e.target.value)}
                  className="keyword-input"
                />
              </div>
            </div>

            <div className="section-tabs">
              <button
                className={`section-tab ${explorerFiltersActiveSection === 'audit' ? 'active' : ''}`}
                onClick={() => setExplorerFiltersActiveSection('audit')}
              >
                Audit
              </button>
              <button
                className={`section-tab ${explorerFiltersActiveSection === 'metrics' ? 'active' : ''}`}
                onClick={() => setExplorerFiltersActiveSection('metrics')}
              >
                Metrics
              </button>
              <button
                className={`section-tab ${explorerFiltersActiveSection === 'socials' ? 'active' : ''}`}
                onClick={() => setExplorerFiltersActiveSection('socials')}
              >
                Socials
              </button>
            </div>

            <div className="filters-content">
              {explorerFiltersActiveSection === 'audit' && (
                <div className="audit-filters">
                  <div className="filter-row">
                    <span className="filter-label">Age (hours)</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.ageMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('ageMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.ageMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('ageMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Holders</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.holdersMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('holdersMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.holdersMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('holdersMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Pro Traders</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.proTradersMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('proTradersMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.proTradersMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('proTradersMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>


                  <div className="filter-row">
                    <span className="filter-label">Top 10 Holders %</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.top10HoldingMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('top10HoldingMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.top10HoldingMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('top10HoldingMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Dev Holding %</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.devHoldingMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('devHoldingMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.devHoldingMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('devHoldingMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Snipers %</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.sniperHoldingMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('sniperHoldingMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.sniperHoldingMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('sniperHoldingMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>



                  <div className="filter-row">
                    <span className="filter-label">Insider Holding %</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.insiderHoldingMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('insiderHoldingMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.insiderHoldingMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('insiderHoldingMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>
                </div>
              )}

              {explorerFiltersActiveSection === 'metrics' && (
                <div className="metrics-filters">
                  <div className="filter-row">
                    <span className="filter-label">Market Cap</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.marketCapMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('marketCapMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.marketCapMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('marketCapMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Volume 24h</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.volume24hMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('volume24hMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.volume24hMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('volume24hMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Global Fees Paid</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.globalFeesMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('globalFeesMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.globalFeesMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('globalFeesMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Buy Transactions</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.buyTransactionsMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('buyTransactionsMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.buyTransactionsMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('buyTransactionsMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Sell Transactions</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.sellTransactionsMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('sellTransactionsMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.sellTransactionsMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('sellTransactionsMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>

                  <div className="filter-row">
                    <span className="filter-label">Price</span>
                    <div className="filter-inputs">
                      <input
                        type="text"
                        placeholder="Min"
                        value={explorerFilters[explorerFiltersActiveTab]?.priceMin || ''}
                        onChange={(e) => handleExplorerFilterInputChange('priceMin', e.target.value)}
                        className="filter-input"
                      />
                      <input
                        type="text"
                        placeholder="Max"
                        value={explorerFilters[explorerFiltersActiveTab]?.priceMax || ''}
                        onChange={(e) => handleExplorerFilterInputChange('priceMax', e.target.value)}
                        className="filter-input"
                      />
                    </div>
                  </div>
                </div>
              )}

              {explorerFiltersActiveSection === 'socials' && (
                <div className="socials-filters">
                  <div className="social-checkboxes">
                    <div className="checkbox-row">
                      <input
                        type="checkbox"
                        id="hasWebsite"
                        checked={explorerFilters[explorerFiltersActiveTab]?.hasWebsite || false}
                        onChange={(e) => handleExplorerFilterInputChange('hasWebsite', e.target.checked)}
                        className="filter-checkbox"
                      />
                      <label htmlFor="hasWebsite" className="checkbox-label">Has Website</label>
                    </div>

                    <div className="checkbox-row">
                      <input
                        type="checkbox"
                        id="hasTwitter"
                        checked={explorerFilters[explorerFiltersActiveTab]?.hasTwitter || false}
                        onChange={(e) => handleExplorerFilterInputChange('hasTwitter', e.target.checked)}
                        className="filter-checkbox"
                      />
                      <label htmlFor="hasTwitter" className="checkbox-label">Has Twitter</label>
                    </div>

                    <div className="checkbox-row">
                      <input
                        type="checkbox"
                        id="hasTelegram"
                        checked={explorerFilters[explorerFiltersActiveTab]?.hasTelegram || false}
                        onChange={(e) => handleExplorerFilterInputChange('hasTelegram', e.target.checked)}
                        className="filter-checkbox"
                      />
                      <label htmlFor="hasTelegram" className="checkbox-label">Has Telegram</label>
                    </div>
                  </div>
                </div>
              )}
            </div>

            <div className="filters-actions">
              <div className="action-buttons-left">
                <button className="import-button" onClick={handleExplorerFiltersImport}>
                  Import
                </button>
                <button className="export-button" onClick={handleExplorerFiltersExport}>
                  Export
                </button>
              </div>
              <div className="action-buttons-right">
                <button className="apply-button" onClick={handleExplorerFiltersApply}>
                  Apply All
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 25 ? ( // deposit popup
          <div ref={popupref} className="send-popup-container">
            <div className="send-popup-background">
              <div className={`sendbg ${connected && sendAmountIn > mainWalletBalances[sendTokenIn] && !txPending.current ? 'exceed-balance' : ''}`}>

                <div className="sendbutton1container">
                  <div className="send-Send">{t('deposit')}</div>
                  <button
                    className="send-button1"
                    onClick={() => {
                      setpopup(26);
                    }}
                  >
                    <img className="send-button1pic" src={tokendict[sendTokenIn].image} />
                    <span>{tokendict[sendTokenIn].ticker || '?'}</span>
                  </button>

                </div>
                <div className="sendinputcontainer">
                  <input
                    inputMode="decimal"
                    className={`send-input ${connected && sendAmountIn > mainWalletBalances[sendTokenIn] && !txPending.current ? 'exceed-balance' : ''}`}
                    onCompositionStart={() => {
                      setIsComposing(true);
                    }}
                    onCompositionEnd={(
                      e: React.CompositionEvent<HTMLInputElement>,
                    ) => {
                      setIsComposing(false);
                      if (/^\$?\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                        if (displayMode == 'usd') {
                          if (e.currentTarget.value == '$') {
                            setSendUsdValue('');
                            setSendInputAmount('');
                            setSendAmountIn(BigInt(0));
                          } else {
                            setSendUsdValue(`$${e.currentTarget.value.replace(/^\$/, '')}`);
                            const calculatedAmount = calculateTokenAmount(
                              e.currentTarget.value.replace(/^\$/, ''),
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            );
                            setSendAmountIn(calculatedAmount);
                            setSendInputAmount(
                              customRound(
                                Number(calculatedAmount) / 10 ** Number(tokendict[sendTokenIn].decimals),
                                3,
                              ).toString()
                            );
                          }
                        } else {
                          const inputValue = BigInt(
                            Math.round((parseFloat(e.currentTarget.value || '0') || 0) * 10 ** Number(tokendict[sendTokenIn].decimals))
                          );
                          setSendAmountIn(inputValue);
                          setSendInputAmount(e.currentTarget.value);
                          setSendUsdValue(
                            `$${calculateUSDValue(
                              inputValue,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            ).toFixed(2)}`
                          );
                        }
                      }
                    }}
                    onChange={(e) => {
                      if (isComposing) {
                        setSendInputAmount(e.target.value);
                        return;
                      }
                      if (/^\$?\d*\.?\d{0,18}$/.test(e.target.value)) {
                        if (displayMode == 'usd') {
                          if (e.target.value == '$') {
                            setSendUsdValue('');
                            setSendInputAmount('');
                            setSendAmountIn(BigInt(0));
                          } else {
                            setSendUsdValue(`$${e.target.value.replace(/^\$/, '')}`);
                            const calculatedAmount = calculateTokenAmount(
                              e.target.value.replace(/^\$/, ''),
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            );
                            setSendAmountIn(calculatedAmount);
                            setSendInputAmount(
                              customRound(
                                Number(calculatedAmount) / 10 ** Number(tokendict[sendTokenIn].decimals),
                                3,
                              ).toString()
                            );
                          }
                        } else {
                          const inputValue = BigInt(
                            Math.round((parseFloat(e.target.value || '0') || 0) * 10 ** Number(tokendict[sendTokenIn].decimals))
                          );
                          setSendAmountIn(inputValue);
                          setSendInputAmount(e.target.value);
                          setSendUsdValue(
                            `$${calculateUSDValue(
                              inputValue,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            ).toFixed(2)}`
                          );
                        }
                      }
                    }}
                    placeholder={displayMode == 'usd' ? '$0.00' : '0.00'}
                    value={displayMode == 'usd' ? sendUsdValue : sendInputAmount}
                    autoFocus={!(windowWidth <= 1020)}
                  />
                </div>
                <div className="send-balance-wrapper">
                  <div className="send-balance-max-container">
                    <div className="send-balance1">
                      <img src={walleticon} className="send-balance-wallet-icon" />{' '}
                      {formatDisplayValue(mainWalletBalances[sendTokenIn] || 0, Number(tokendict[sendTokenIn].decimals))}
                    </div>
                    <div
                      className="send-max-button"
                      onClick={() => {
                        if (mainWalletBalances[sendTokenIn] != BigInt(0)) {
                          let amount =
                            (sendTokenIn == eth && !client)
                              ? mainWalletBalances[sendTokenIn] - settings.chainConfig[activechain].gasamount > BigInt(0)
                                ? mainWalletBalances[sendTokenIn] - settings.chainConfig[activechain].gasamount
                                : BigInt(0)
                              : mainWalletBalances[sendTokenIn];
                          setSendAmountIn(amount);
                          setSendInputAmount(
                            customRound(Number(amount) / 10 ** Number(tokendict[sendTokenIn].decimals), 3).toString()
                          );
                          setSendUsdValue(
                            `$${calculateUSDValue(
                              amount,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            ).toFixed(2)}`
                          );
                        }
                      }}
                    >
                      {t('max')}
                    </div>
                  </div>
                  <div
                    className="send-usd-switch-wrapper"
                    onClick={() => {
                      if (displayMode === 'usd') {
                        setDisplayMode('token');
                        if (parseFloat(sendUsdValue.replace(/^\$|,/g, '')) == 0) {
                          setSendInputAmount('');
                        }
                      } else {
                        setDisplayMode('usd');
                        if (parseFloat(sendInputAmount) == 0) {
                          setSendUsdValue('');
                        }
                      }
                    }}
                  >
                    <div className="send-usd-value">
                      {displayMode === 'usd'
                        ? `${customRound(Number(sendAmountIn) / 10 ** Number(tokendict[sendTokenIn].decimals), 3)} ${tokendict[sendTokenIn].ticker}`
                        : sendAmountIn === BigInt(0)
                          ? '$0.00'
                          : formatUSDDisplay(
                            calculateUSDValue(
                              sendAmountIn,
                              tradesByMarket[
                              (({ baseAsset, quoteAsset }) =>
                                (baseAsset === wethticker ? ethticker : baseAsset) +
                                (quoteAsset === wethticker ? ethticker : quoteAsset)
                              )(getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc))
                              ],
                              sendTokenIn,
                              getMarket(sendTokenIn, sendTokenIn == usdc ? eth : usdc),
                            )
                          )}
                    </div>
                    <img src={sendSwitch} className="send-arrow" />
                  </div>
                </div>
              </div>
              <div className="sendaddressbg">
                <div className="send-To">{t('to')}</div>
                <div className="send-address-input-container">
                  <input
                    className="send-output"
                    onChange={(e) => {
                      if (e.target.value === '' || /^(0x[0-9a-fA-F]{0,40}|0)$/.test(e.target.value)) {
                        setrecipient(e.target.value);
                      }
                    }}
                    value={OneCTDepositAddress}
                    placeholder={t('enterWalletAddress')}
                    disabled
                  />
                  <button
                    className="address-paste-button"
                    onClick={async () => {
                      try {
                        const text = await navigator.clipboard.readText();
                        if (/^(0x[0-9a-fA-F]{40})$/.test(text)) {
                          setrecipient(text);
                        }
                      } catch (err) {
                      }
                    }}
                  >
                    <svg
                      width="16"
                      height="16"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                    >
                      <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                      <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
                    </svg>
                  </button>
                </div>
              </div>
              <button
                className={`send-swap-button ${isSigning ? 'signing' : ''}`}
                onClick={async () => {
                  if (
                    connected &&
                    userchain === activechain
                  ) {
                    let hash: any;
                    setIsSigning(true)
                    if (client) {
                      txPending.current = true
                    }
                    try {
                      if (sendTokenIn == eth) {
                        hash = await sendUserOperationAsync({
                          uo: sendeth(
                            OneCTDepositAddress as `0x${string}`,
                            sendAmountIn,
                          )
                        }, 0n, 0n, true, '', 0);
                        if (!client) {
                          txPending.current = true
                        }
                        newTxPopup(
                          (hash),
                          'send',
                          eth,
                          '',
                          customRound(
                            Number(sendAmountIn) / 10 ** Number(tokendict[eth].decimals),
                            3,
                          ),
                          0,
                          '',
                          OneCTDepositAddress,
                        );
                      } else {
                        hash = await sendUserOperationAsync({
                          uo: sendtokens(
                            sendTokenIn as `0x${string}`,
                            OneCTDepositAddress as `0x${string}`,
                            sendAmountIn,
                          )
                        }, 0n, 0n, true, '', 0);
                        if (!client) {
                          txPending.current = true
                        }
                        newTxPopup(
                          (hash),
                          'send',
                          sendTokenIn,
                          '',
                          customRound(
                            Number(sendAmountIn) /
                            10 ** Number(tokendict[sendTokenIn].decimals),
                            3,
                          ),
                          0,
                          '',
                          OneCTDepositAddress,
                        );
                      }
                      setpopup(4)
                      setSendUsdValue('')
                      setSendInputAmount('');
                      setSendAmountIn(BigInt(0));
                      setSendPopupButton(0);
                      setSendPopupButtonDisabled(true);
                      setIsSigning(false)
                      await refetch()
                      txPending.current = false
                    } catch (error) {
                      if (!(error instanceof TransactionExecutionError)) {
                        newTxPopup(
                          hash,
                          "sendFailed",
                          sendTokenIn === eth ? eth : sendTokenIn,
                          "",
                          customRound(
                            Number(sendAmountIn) / 10 ** Number(tokendict[sendTokenIn === eth ? eth : sendTokenIn].decimals),
                            3,
                          ),
                          0,
                          "",
                          OneCTDepositAddress,
                        );
                      }
                    } finally {
                      txPending.current = false
                      setIsSigning(false)
                    }
                  } else {
                    !connected
                      ? setpopup(4)
                      : handleSetChain()
                  }
                }}
                disabled={(sendAmountIn === BigInt(0) ||
                  sendAmountIn > mainWalletBalances[sendTokenIn] ||
                  !/^(0x[0-9a-fA-F]{40})$/.test(OneCTDepositAddress)) &&
                  connected &&
                  userchain == activechain || isSigning}
              >
                {isSigning ? (
                  <div className="button-content">
                    <div className="loading-spinner" />
                    {validOneCT ? t('') : t('signTransaction')}
                  </div>
                ) : sendAmountIn === BigInt(0) ? (
                  t('enterAmount')
                ) : sendAmountIn > mainWalletBalances[sendTokenIn] ? (
                  t('insufficient') +
                  (tokendict[sendTokenIn].ticker || '?') +
                  ' ' +
                  t('bal')
                ) : connected && userchain == activechain ? (
                  t('deposit')
                ) : connected ? (
                  `${t('switchto')} ${t(settings.chainConfig[activechain].name)}`
                ) : (
                  t('connectWallet')
                )}
              </button>
            </div>
          </div>
        ) : null}
        {popup === 26 ? (
          <div ref={popupref} className="sendselectbg">
            <div className="send-top-row">
              <input
                className="sendselect"
                onChange={(e) => {
                  settokenString(e.target.value);
                }}
                placeholder={t('searchToken')}
                autoFocus={!(windowWidth <= 1020)}
              />
              {tokenString && (
                <button
                  className="sendselect-clear visible"
                  onClick={() => {
                    settokenString('');
                    const input = document.querySelector('.sendselect') as HTMLInputElement;
                    if (input) {
                      input.value = '';
                      input.focus();
                    }
                  }}
                >
                  {t('clear')}
                </button>
              )}
              <button
                className="sendselect-back"
                onClick={() => {
                  setpopup(25);
                }}
              >
                <img src={closebutton} className="send-close-button-icon" />
              </button>
            </div>

            <ul className="sendtokenlist">
              {Object.values(tokendict)
                .filter(
                  (token) =>
                    token.ticker.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                    token.name.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                    token.address.toLowerCase().includes(tokenString.trim().toLowerCase())
                ).length === 0 ? (
                <div className="empty-token-list">
                  <div className="empty-token-list-content">
                    <svg
                      width="24"
                      height="24"
                      viewBox="0 0 24 24"
                      fill="none"
                      stroke="currentColor"
                      strokeWidth="2"
                      strokeLinecap="round"
                      strokeLinejoin="round"
                      className="empty-token-list-icon"
                    >
                      <circle cx="11" cy="11" r="8" />
                      <path d="M21 21l-4.35-4.35" />
                    </svg>
                    <div className="empty-token-list-text">{t('noTokens')}</div>
                  </div>
                </div>
              ) : (
                Object.values(tokendict)
                  .filter(
                    (token) =>
                      token.ticker.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                      token.name.toLowerCase().includes(tokenString.trim().toLowerCase()) ||
                      token.address.toLowerCase().includes(tokenString.trim().toLowerCase())
                  )
                  .map((token) => (
                    <button
                      className="sendtokenbutton"
                      key={token.address}
                      onClick={() => {
                        setSendTokenIn(token.address);
                        setSendUsdValue('');
                        setSendInputAmount('');
                        setSendAmountIn(BigInt(0));
                        settokenString('');
                        setpopup(25);
                      }}
                    >
                      <img className="tokenlistimage" src={token.image} />
                      <div className="tokenlisttext">
                        <div className="tokenlistname">{token.ticker}</div>
                        <div className="tokenlistticker">{token.name}</div>
                      </div>
                      <div className="token-right-content">
                        <div className="tokenlistbalance">
                          {formatDisplayValue(mainWalletBalances[token.address], Number(token.decimals))}
                        </div>
                        <div className="token-address-container">
                          <span className="token-address">
                            {`${token.address.slice(0, 6)}...${token.address.slice(-4)}`}
                          </span>
                          <div
                            className="copy-address-button"
                            onClick={(e) => {
                              e.stopPropagation();
                              navigator.clipboard.writeText(token.address);
                              const copyIcon =
                                e.currentTarget.querySelector('.copy-icon');
                              const checkIcon =
                                e.currentTarget.querySelector('.check-icon');
                              if (copyIcon && checkIcon) {
                                copyIcon.classList.add('hidden');
                                checkIcon.classList.add('visible');
                                setTimeout(() => {
                                  copyIcon.classList.remove('hidden');
                                  checkIcon.classList.remove('visible');
                                }, 2000);
                              }
                            }}
                          >
                            <svg
                              className="copy-icon"
                              viewBox="0 0 24 24"
                              fill="none"
                              stroke="currentColor"
                              strokeWidth="2"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                            >
                              <rect
                                x="9"
                                y="9"
                                width="13"
                                height="13"
                                rx="2"
                                ry="2"
                              ></rect>
                              <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
                            </svg>
                            <svg
                              className="check-icon"
                              viewBox="0 0 24 24"
                              fill="none"
                              stroke="currentColor"
                              strokeWidth="2"
                              strokeLinecap="round"
                              strokeLinejoin="round"
                            >
                              <circle cx="12" cy="12" r="10" />
                              <path d="M8 12l3 3 6-6" />
                            </svg>
                          </div>
                        </div>
                      </div>
                    </button>
                  ))
              )}
            </ul>
          </div>
        ) : null}
        {popup === 27 ? ( // PNL
          <div ref={popupref}>
            <PNLComponent
              windowWidth={window.innerWidth}
              tokenAddress={currentTokenData.address}
              userAddress={address}
              tokenSymbol={currentTokenData.symbol}
              tokenName={currentTokenData.name}
              monUsdPrice={monUsdPrice}
              externalUserStats={currentPNLData}
              currentPrice={currentTokenData.price}
            />
          </div>

        ) : null}
        {popup === 28 ? (
          <div className="onect-trading-selection-bg">
            <div ref={popupref} className="onect-trading-selection-container">
              <div className="onect-trading-header">
                <h2 className="onect-trading-title">Choose Trading Mode</h2>
                <button
                  className="onect-trading-close-button"
                  onClick={() => setpopup(0)}
                >
                  <img src={closebutton} className="close-button-icon" />
                </button>
              </div>

              <div className="onect-trading-content">
                <div className="trading-mode-options">
                  <div className="trading-mode-option selected">
                    <div className="trading-mode-icon">
                      <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                        <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path>
                        <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>
                        <ellipse cx="12" cy="5" rx="9" ry="3"></ellipse>
                      </svg>
                    </div>
                    <div className="trading-mode-info">
                      <h3>Classic Trading</h3>
                      <p>Trade and sign transactions with your self-custodial wallet</p>
                    </div>
                  </div>

                  <div className="trading-mode-option">
                    <div className="trading-mode-icon">
                      <svg xmlns="http://www.w3.org/2000/svg" width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" ><path d="M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z" /></svg>
                    </div>
                    <div className="trading-mode-info">
                      <h3>One-Click Trading</h3>
                      <p>Approve transactions instantly from an embedded wallet</p>
                    </div>
                    <div className="trading-mode-status">
                      <button
                        className="enable-onect-btn"
                        onClick={async () => {
                          try {
                            setIsUsernameSigning(true);
                            let isSuccess = await createSubWallet(true);
                            if (isSuccess) {
                              setOneCTDepositAddress(isSuccess);
                              setpopup(25);
                            }
                          } catch (error) {
                            console.error('Failed to enable 1CT:', error);
                          } finally {
                            setIsUsernameSigning(false);
                          }
                        }}
                        disabled={isUsernameSigning}
                      >
                        {isUsernameSigning ? (
                          <div className="button-content">
                            <div style={{ position: 'absolute' }} className="loading-spinner" />
                            <span style={{ opacity: 0 }}>Enable 1CT</span>
                          </div>
                        ) : (
                          'Enable 1CT'
                        )}
                      </button>
                    </div>
                  </div>
                </div>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 29 ? (
          <div ref={popupref} className="modal-overlay">
            <div className="modal-content">
              <div className="modal-header">
                <h2>Create New Vault</h2>
                <button
                  className="modal-close"
                  onClick={() => {
                    setCreateVaultForm({
                      name: '',
                      description: '',
                      selectedMarket: '',
                      quoteAsset: '',
                      baseAsset: '',
                      amountQuote: '',
                      amountBase: '',
                      social1: '',
                      social2: '',
                      showMarketDropdown: false,
                      marketSearchTerm: ''
                    });
                    setCreateVaultStep('idle');
                    setCreateVaultError('');
                    setpopup(0);
                  }}
                >
                  <img src={closebutton} className="close-button-icon" />
                </button>
              </div>

              <div
                className="modal-body"
                onClick={(e) => {
                  if (!(e.target as Element)?.closest?.('.market-selector-container')) {
                    setCreateVaultForm(prev => ({
                      ...prev,
                      showMarketDropdown: false
                    }));
                  }
                }}
              >
                {/* Show form only when not in progress */}
                {createVaultStep === 'idle' && (
                  <>
                    <div className="form-group">
                      <label>Vault Name</label>
                      <input
                        type="text"
                        value={createVaultForm.name}
                        onChange={(e) => setCreateVaultForm(prev => ({ ...prev, name: e.target.value }))}
                        className="form-input"
                        placeholder="Enter vault name"
                      />
                    </div>

                    <div className="form-group">
                      <label>Description</label>
                      <textarea
                        value={createVaultForm.description}
                        onChange={(e) => setCreateVaultForm(prev => ({ ...prev, description: e.target.value }))}
                        className="form-textarea"
                        rows={4}
                        placeholder="Describe your vault strategy"
                      />
                    </div>

                    <div className="form-group">
                      <label className="market-selector-label">Trading Market</label>
                      <div className="market-selector-container">
                        {(() => {
                          const selectedMarket = Object.values(markets).find((market) =>
                            `${market.baseAsset}${market.quoteAsset}` === createVaultForm.selectedMarket
                          );
                          return selectedMarket ? (
                            <div className="selected-token-indicator">
                              <img src={selectedMarket.image || tokendict[selectedMarket.baseAddress]?.image} alt={selectedMarket.baseAsset} className="token-icon-small" />
                              <span className="token-symbol">{selectedMarket.baseAsset}/{selectedMarket.quoteAsset}</span>
                            </div>
                          ) : null;
                        })()}
                        <div className="market-selector-input-wrapper">
                          <input
                            type="text"
                            value=""
                            onFocus={() => setCreateVaultForm(prev => ({ ...prev, showMarketDropdown: true }))}
                            className="form-input market-selector-input"
                            placeholder={createVaultForm.selectedMarket ? "" : "Select trading market..."}
                            readOnly
                          />
                          <button
                            type="button"
                            className="token-dropdown-button"
                            onClick={() => setCreateVaultForm(prev => ({ ...prev, showMarketDropdown: !prev.showMarketDropdown }))}
                          >
                            <ChevronDown size={16} />
                          </button>
                        </div>
                        {createVaultForm.showMarketDropdown && (
                          <div className="create-vault-token-dropdown">
                            <div className="create-vault-token-list">
                              {Object.values(markets).filter((market) => {
                                const searchTerm = createVaultForm.marketSearchTerm || '';
                                const marketPair = `${market.baseAsset}/${market.quoteAsset}`;
                                if (!searchTerm) return true;
                                return marketPair.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                  market.baseAsset.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                  market.quoteAsset.toLowerCase().includes(searchTerm.toLowerCase());
                              }).slice(0, 100).map((market) => {
                                const marketKey = `${market.baseAsset}${market.quoteAsset}`;
                                return (
                                  <div
                                    key={marketKey}
                                    className="create-vault-token-option"
                                    onClick={() => {
                                      setCreateVaultForm(prev => ({
                                        ...prev,
                                        selectedMarket: marketKey,
                                        quoteAsset: market.quoteAddress,
                                        baseAsset: market.baseAddress,
                                        showMarketDropdown: false,
                                        marketSearchTerm: ''
                                      }));
                                    }}
                                  >
                                    <img src={market.image || tokendict[market.baseAddress]?.image} alt={market.baseAsset} className="create-vault-token-icon" />
                                    <div className="create-vault-token-info">
                                      <div className="token-symbol">{market.baseAsset}/{market.quoteAsset}</div>
                                    </div>
                                  </div>
                                );
                              })}

                              {Object.values(markets).filter((market) => {
                                const searchTerm = createVaultForm.marketSearchTerm || '';
                                const marketPair = `${market.baseAsset}/${market.quoteAsset}`;
                                if (!searchTerm) return false;
                                return marketPair.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                  market.baseAsset.toLowerCase().includes(searchTerm.toLowerCase()) ||
                                  market.quoteAsset.toLowerCase().includes(searchTerm.toLowerCase());
                              }).length === 0 && createVaultForm.marketSearchTerm && (
                                  <div className="no-tokens-found">No markets found</div>
                                )}
                            </div>
                          </div>
                        )}
                      </div>
                    </div>

                    <div className="form-row">
                      <div className="form-group">
                        <label>Initial Quote Amount</label>
                        <input
                          type="number"
                          value={createVaultForm.amountQuote}
                          onChange={(e) => setCreateVaultForm(prev => ({ ...prev, amountQuote: e.target.value }))}
                          className="form-input"
                          placeholder="0.0"
                        />
                        {/* {createVaultForm.quoteAsset && tokendict[createVaultForm.quoteAsset] && (
                  <small className="token-label">
                    {tokendict[createVaultForm.quoteAsset].ticker} ({tokendict[createVaultForm.quoteAsset].name})
                  </small>
                )} */}
                      </div>
                      <div className="form-group">
                        <label>Initial Base Amount</label>
                        <input
                          type="number"
                          value={createVaultForm.amountBase}
                          onChange={(e) => setCreateVaultForm(prev => ({ ...prev, amountBase: e.target.value }))}
                          className="form-input"
                          placeholder="0.0"
                        />
                        {/* {createVaultForm.baseAsset && tokendict[createVaultForm.baseAsset] && (
                  <small className="token-label">
                    {tokendict[createVaultForm.baseAsset].ticker} ({tokendict[createVaultForm.baseAsset].name})
                  </small>
                )} */}
                      </div>
                    </div>

                    <div className="form-row">
                      <div className="form-group">
                        <label>Social Link 1 (Optional)</label>
                        <input
                          type="text"
                          value={createVaultForm.social1}
                          onChange={(e) => setCreateVaultForm(prev => ({ ...prev, social1: e.target.value }))}
                          className="form-input"
                          placeholder="https://twitter.com/..."
                        />
                      </div>
                      <div className="form-group">
                        <label>Social Link 2 (Optional)</label>
                        <input
                          type="text"
                          value={createVaultForm.social2}
                          onChange={(e) => setCreateVaultForm(prev => ({ ...prev, social2: e.target.value }))}
                          className="form-input"
                          placeholder="https://telegram.me/..."
                        />
                      </div>
                    </div>
                  </>
                )}

                {createVaultStep !== 'idle' && (
                  <div className="create-vault-progress-container">
                    <div className="create-vault-progress-steps">
                      <div className={`create-vault-progress-step ${createVaultStep === 'validating' ? 'active' :
                        ['approve-quote', 'approve-base', 'creating', 'success'].includes(createVaultStep) ? 'completed' : ''
                        }`}>
                        <div className="step-progress-indicator">
                          {['approve-quote', 'approve-base', 'creating', 'success'].includes(createVaultStep) ? (
                            <svg width="14" height="14" viewBox="0 0 16 16" fill="none">
                              <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                            </svg>
                          ) : (
                            <span>1</span>
                          )}
                        </div>
                        <div className="step-progress-content">
                          <div className="step-progress-title">Validating</div>
                          <div className="step-progress-description">Checking balances and permissions</div>
                        </div>

                      </div>

                      {createVaultForm.quoteAsset && createVaultForm.quoteAsset.toLowerCase() !== eth.toLowerCase() && (
                        <div className={`create-vault-progress-step ${createVaultStep === 'approve-quote' ? 'active' :
                          ['approve-base', 'creating', 'success'].includes(createVaultStep) ? 'completed' : ''
                          }`}>
                          <div className="step-progress-indicator">
                            {['approve-base', 'creating', 'success'].includes(createVaultStep) ? (
                              <svg width="14" height="14" viewBox="0 0 16 16" fill="none">
                                <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                              </svg>
                            ) : (
                              <span>2</span>
                            )}
                          </div>
                          <div className="step-progress-content">
                            <div className="step-progress-title">
                              Approve {tokendict[createVaultForm.quoteAsset]?.ticker || 'Quote Token'}
                            </div>
                            <div className="step-progress-description">Grant vault contract permission</div>
                          </div>
                        </div>
                      )}

                      {createVaultForm.baseAsset && createVaultForm.baseAsset.toLowerCase() !== eth.toLowerCase() && (
                        <div className={`create-vault-progress-step ${createVaultStep === 'approve-base' ? 'active' :
                          ['creating', 'success'].includes(createVaultStep) ? 'completed' : ''
                          }`}>
                          <div className="step-progress-indicator">
                            {['creating', 'success'].includes(createVaultStep) ? (
                              <svg width="14" height="14" viewBox="0 0 16 16" fill="none">
                                <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                              </svg>
                            ) : (
                              <span>
                                {createVaultForm.quoteAsset.toLowerCase() !== eth.toLowerCase() ? '3' : '2'}
                              </span>
                            )}
                          </div>
                          <div className="step-progress-content">
                            <div className="step-progress-title">
                              Approve {tokendict[createVaultForm.baseAsset]?.ticker || 'Base Token'}
                            </div>
                            <div className="step-progress-description">Grant vault contract permission</div>
                          </div>
                        </div>
                      )}

                      <div className={`create-vault-progress-step ${createVaultStep === 'creating' ? 'active' :
                        createVaultStep === 'success' ? 'completed' : ''
                        }`}>
                        <div className="step-progress-indicator">
                          {createVaultStep === 'success' ? (
                            <svg width="14" height="14" viewBox="0 0 16 16" fill="none">
                              <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                            </svg>
                          ) : (
                            <span>
                              {(() => {
                                let stepNum = 2;
                                if (createVaultForm.quoteAsset.toLowerCase() !== eth.toLowerCase()) stepNum++;
                                if (createVaultForm.baseAsset.toLowerCase() !== eth.toLowerCase()) stepNum++;
                                return stepNum;
                              })()}
                            </span>
                          )}
                        </div>
                        <div className="step-progress-content">
                          <div className="step-progress-title">Creating Vault</div>
                          <div className="step-progress-description">Deploying your vault contract</div>
                        </div>
                      </div>
                    </div>

                  </div>
                )}
              </div>

              <div className="modal-footer">
                <button
                  className={`save-button ${(!createVaultForm.name || !createVaultForm.selectedMarket || !createVaultForm.amountQuote || !createVaultForm.amountBase) && createVaultStep === 'idle' ? 'disabled' : ''
                    } ${createVaultStep === 'success' ? 'success' : ''}`}
                  disabled={
                    (createVaultStep === 'success' || (!createVaultForm.name || !createVaultForm.selectedMarket || !createVaultForm.amountQuote || !createVaultForm.amountBase)) ||
                    isVaultDepositSigning
                  }
                  onClick={async () => {
                    if (!connected || !createVaultForm.name || !createVaultForm.selectedMarket ||
                      !createVaultForm.amountQuote || !createVaultForm.amountBase) {
                      return;
                    }

                    await handleSetChain();

                    try {
                      setIsVaultDepositSigning(true);
                      setCreateVaultError('');

                      // Step 1: Validating
                      setCreateVaultStep('validating');
                      await new Promise(resolve => setTimeout(resolve, 500)); // Small delay for UX

                      if (!createVaultForm.quoteAsset.startsWith('0x') || !createVaultForm.baseAsset.startsWith('0x')) {
                        throw new Error('Invalid token addresses. Please provide valid contract addresses.');
                      }

                      const quoteAssetData = Object.values(tokendict).find((t) =>
                        t.address.toLowerCase() === createVaultForm.quoteAsset.toLowerCase()
                      );
                      const baseAssetData = Object.values(tokendict).find((t) =>
                        t.address.toLowerCase() === createVaultForm.baseAsset.toLowerCase()
                      );

                      if (!quoteAssetData || !baseAssetData) {
                        throw new Error('One or both tokens not found in token dictionary. Please ensure you\'re using valid token addresses.');
                      }

                      const quoteDecimals = Number(quoteAssetData.decimals || 18);
                      const baseDecimals = Number(baseAssetData.decimals || 18);

                      const amountQuote = BigInt(Math.round(parseFloat(createVaultForm.amountQuote) * 10 ** quoteDecimals));
                      const amountBase = BigInt(Math.round(parseFloat(createVaultForm.amountBase) * 10 ** baseDecimals));

                      const quoteBalance = tokenBalances[createVaultForm.quoteAsset] || 0n;
                      const baseBalance = tokenBalances[createVaultForm.baseAsset] || 0n;

                      if (quoteBalance < amountQuote) {
                        const formatBalance = (amount: bigint, decimals: number) => {
                          const num = Number(amount) / 10 ** decimals;
                          return num.toFixed(2);
                        };
                        throw new Error(`Insufficient ${quoteAssetData.ticker} balance. Required: ${createVaultForm.amountQuote}, Available: ${formatBalance(quoteBalance, quoteDecimals)}`);
                      }

                      if (baseBalance < amountBase) {
                        const formatBalance = (amount: bigint, decimals: number) => {
                          const num = Number(amount) / 10 ** decimals;
                          return num.toFixed(2);
                        };
                        throw new Error(`Insufficient ${baseAssetData.ticker} balance. Required: ${createVaultForm.amountBase}, Available: ${formatBalance(baseBalance, baseDecimals)}`);
                      }

                      // Step 2: Approve Quote Token
                      if (createVaultForm.quoteAsset.toLowerCase() !== eth.toLowerCase()) {
                        setCreateVaultStep('approve-quote');
                        const approveQuoteUo = {
                          target: createVaultForm.quoteAsset,
                          data: encodeFunctionData({
                            abi: [{
                              inputs: [
                                { name: "spender", type: "address" },
                                { name: "amount", type: "uint256" }
                              ],
                              name: "approve",
                              outputs: [{ name: "", type: "bool" }],
                              stateMutability: "nonpayable",
                              type: "function",
                            }],
                            functionName: "approve",
                            args: [crystalVaults, amountQuote],
                          }),
                          value: 0n,
                        };
                        await sendUserOperationAsync({ uo: approveQuoteUo });
                      }

                      // Step 3: Approve Base Token
                      if (createVaultForm.baseAsset.toLowerCase() !== eth.toLowerCase()) {
                        setCreateVaultStep('approve-base');
                        const approveBaseUo = {
                          target: createVaultForm.baseAsset,
                          data: encodeFunctionData({
                            abi: [{
                              inputs: [
                                { name: "spender", type: "address" },
                                { name: "amount", type: "uint256" }
                              ],
                              name: "approve",
                              outputs: [{ name: "", type: "bool" }],
                              stateMutability: "nonpayable",
                              type: "function",
                            }],
                            functionName: "approve",
                            args: [crystalVaults, amountBase],
                          }),
                          value: 0n,
                        };
                        await sendUserOperationAsync({ uo: approveBaseUo });
                      }

                      // Step 4: Creating Vault
                      setCreateVaultStep('creating');

                      const ethValue =
                        createVaultForm.quoteAsset.toLowerCase() === eth.toLowerCase() ? amountQuote :
                          createVaultForm.baseAsset.toLowerCase() === eth.toLowerCase() ? amountBase : 0n;

                      const deployUo = {
                        target: crystalVaults,
                        data: encodeFunctionData({
                          abi: CrystalVaultsAbi,
                          functionName: "deploy",
                          args: [
                            createVaultForm.quoteAsset as `0x${string}`,
                            createVaultForm.baseAsset as `0x${string}`,
                            amountQuote,
                            amountBase,
                            0n,
                            0n,
                            true,
                            {
                              name: createVaultForm.name || 'Unnamed Vault',
                              description: createVaultForm.description || 'No description provided',
                              social1: createVaultForm.social1 || '',
                              social2: createVaultForm.social2 || '',
                              social3: createVaultForm.social2 || ''
                            },
                          ],
                        }),
                        value: ethValue,
                      };

                      await sendUserOperationAsync({ uo: deployUo });

                      // Step 5: Success
                      setCreateVaultStep('success');

                      // Wait a moment to show success state
                      setTimeout(() => {
                        setCreateVaultForm({
                          name: '',
                          description: '',
                          selectedMarket: '',
                          quoteAsset: '',
                          baseAsset: '',
                          amountQuote: '',
                          amountBase: '',
                          social1: '',
                          social2: '',
                          showMarketDropdown: false,
                          marketSearchTerm: ''
                        });
                        setCreateVaultStep('idle');
                        setCreateVaultError('');
                        setpopup(0);
                        refetch?.();
                      }, 2000);

                    } catch (e: any) {
                      console.error('Vault creation error:', e);
                      setCreateVaultError(e?.message || 'An error occurred while creating the vault. Please try again.');
                      setCreateVaultStep('idle');
                    } finally {
                      setIsVaultDepositSigning(false);
                    }
                  }}
                >
                  {createVaultStep === 'success' ? (
                    <div className="button-content">
                      <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M13.5 4L6 11.5L2.5 8" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" />
                      </svg>
                      Vault Created!
                    </div>
                  ) : createVaultStep !== 'idle' ? (
                    <div className="button-content">
                      <div className="loading-spinner" />
                    </div>
                  ) : (
                    'Create Vault'
                  )}
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 30 ? ( // perps-deposit-popup
          <div className="modal-overlay">
            <div className="modal-content" ref={popupref}>
              <div className="modal-header">
                <h2>Deposit</h2>
                <button
                  className="modal-close"
                  onClick={() => {
                    setpopup(0);
                    setPerpsDepositAmount('');
                  }}
                >
                  <img src={closebutton} className="close-button-icon" />
                </button>
              </div>

              <div className="modal-body">
                <div className="perps-deposit-form">
                  <div className="form-group">
                    <label>Exchange Native USDC for USDC on EdgeX</label>
                    <div className="perps-deposit-input-wrapper">
                      <div className="perps-deposit-balance">
                        Converting
                        <div className="">
                          <span>Balance: </span>
                          <span>0.00</span>
                          <button
                            className="perps-max-button"
                            onClick={() => {
                              const usdcBalance = tokenBalances['0xaf88d065e77c8cC2239327C5EDb3A432268e5831'] || 0n;
                              const maxAmount = (Number(usdcBalance) / 1e6).toFixed(2);
                              setPerpsDepositAmount(maxAmount);
                            }}
                          >
                            Max
                          </button>
                        </div>
                      </div>
                      <div className="perps-input-bottom-row">
                        <input
                          type="text"
                          placeholder="0.00"
                          className="perps-deposit-input"
                          value={perpsDepositAmount}
                          onChange={(e) => {
                            const value = e.target.value;
                            if (/^\d*\.?\d{0,2}$/.test(value)) {
                              setPerpsDepositAmount(value);
                            }
                          }}
                        />
                        <div className="perps-deposit-token-badge">
                          <img className="perps-deposit-icon" src={iconusdc} />
                          <span>USDC</span>
                        </div>
                      </div>
                    </div>
                    <div className="perps-switch-icon" onClick={() => {
                      setpopup(31);
                      setPerpsDepositAmount('');
                    }}>
                      <img className="perps-switch-img" src={switchicon} />
                    </div>
                    <div className="perps-deposit-input-wrapper">
                      <div className="perps-deposit-balance">
                        Receiving
                        <div className="">
                          <span>Balance: </span>
                          <span>0.00</span>
                        </div>
                      </div>
                      <div className="perps-input-bottom-row">
                        <input
                          type="text"
                          placeholder="0.00"
                          className="perps-deposit-input"
                          value={perpsDepositAmount}
                          readOnly
                        />
                        <div className="perps-deposit-token-badge">
                          <img className="perps-deposit-icon" src={iconusdc} />
                          <img className="edgeX-icon" src={edgeX} />
                          <span>USDC</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              </div>

              <div className="modal-footer">
                <button
                  className={`perps-confirm-button ${isVaultDepositSigning ? 'signing' : ''}`}
                  disabled={!perpsDepositAmount || parseFloat(perpsDepositAmount) < 1 || isVaultDepositSigning}
                  style={{
                    opacity: !perpsDepositAmount || parseFloat(perpsDepositAmount) < 1 || isVaultDepositSigning ? 0.5 : 1,
                    cursor: !perpsDepositAmount || parseFloat(perpsDepositAmount) < 1 || isVaultDepositSigning ? 'not-allowed' : 'pointer'
                  }}
                  onClick={async () => {
                    if (!perpsDepositAmount || parseFloat(perpsDepositAmount) < 1 || isVaultDepositSigning) return;

                    try {
                      setIsVaultDepositSigning(true);
                      const amount = BigInt(Math.floor(parseFloat(perpsDepositAmount) * 1e6));

                      await alchemyconfig?._internal?.wagmiConfig?.state?.connections?.entries()?.next()?.value?.[1]?.connector?.switchChain({ chainId: 42161 as any });
                      await rawSendUserOperationAsync({
                        uo: {
                          target: '0x81144d6E7084928830f9694a201E8c1ce6eD0cb2' as `0x${string}`,
                          data: encodeFunctionData({
                            abi: [{
                              inputs: [
                                { name: "token", type: "address" },
                                { name: "amount", type: "uint256" },
                                { name: "starkKey", type: "uint256" },
                                { name: "accountId", type: "uint256" },
                                { name: "exchangeData", type: "bytes" }
                              ],
                              name: "deposit",
                              outputs: [],
                              stateMutability: "nonpayable",
                              type: "function",
                            }],
                            functionName: "deposit",
                            args: ['0xaf88d065e77c8cC2239327C5EDb3A432268e5831', amount, perpsKeystore.publicKey, BigInt(perpsKeystore.accountId), '0x00'],
                          }),
                          value: 0n,
                        }
                      });
                      setPerpsDepositAmount('');
                      setpopup(0);
                    } catch (error) {
                      console.error('Perps deposit error:', error);
                    } finally {
                      handleSetChain();
                      setIsVaultDepositSigning(false);
                    }
                  }}
                >
                  {isVaultDepositSigning ? (
                    <div className="button-content">
                      <div className="loading-spinner" />
                      {validOneCT ? '' : t('signTransaction')}
                    </div>
                  ) : !perpsDepositAmount || parseFloat(perpsDepositAmount) < 1 ? (
                    'Minimum deposit: 1 USDC'
                  ) : (
                    'Deposit'
                  )}
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 31 ? ( // perps-withdraw-popup
          <div className="modal-overlay">
            <div className="modal-content" ref={popupref}>
              <div className="modal-header">
                <h2>Withdraw</h2>
                <button
                  className="modal-close"
                  onClick={() => setpopup(0)}
                >
                  <img src={closebutton} className="close-button-icon" />
                </button>
              </div>

              <div className="modal-body">
                <div className="perps-deposit-form">
                  <div className="form-group">
                    <label>Exchange  USDC on EdgeX for native USDC on Monad</label>
                    <div className="perps-deposit-input-wrapper">
                      <div className="perps-deposit-balance">
                        Withdrawing
                        <div className="">
                          <span>Balance: </span>
                          <span>0.00</span>
                          <button className="perps-max-button">Max</button>
                        </div>
                      </div>
                      <div className="perps-input-bottom-row">
                        <input
                          type="text"
                          placeholder="0.0"
                          className="perps-deposit-input"
                        />
                        <div className="perps-deposit-token-badge">
                          <img className="perps-deposit-icon" src={iconusdc} />
                          <img className="edgeX-icon" src={edgeX} />
                          <span>USDC</span>
                        </div>
                      </div>
                    </div>
                    <div className="perps-switch-icon" onClick={() => setpopup(30)}
                    >                      <img className="perps-switch-img" src={switchicon} />
                    </div>
                    <div className="perps-deposit-input-wrapper">
                      <div className="perps-deposit-balance">
                        Receiving
                        <div className="">
                          <span>Balance: </span>
                          <span>0.00</span>
                        </div>
                      </div>
                      <div className="perps-input-bottom-row">
                        <input
                          type="text"
                          placeholder="0.0"
                          className="perps-deposit-input"
                        />
                        <div className="perps-deposit-token-badge">
                          <img className="perps-deposit-icon" src={iconusdc} />
                          <span>USDC</span>
                        </div>
                      </div>
                    </div>



                  </div>
                </div>
              </div>

              <div className="modal-footer">
                <button className="perps-confirm-button">
                  Withdraw
                </button>
              </div>
            </div>
          </div>
        ) : null}

        {popup === 32 ? (
          <div ref={popupref}>
            <ImportWalletsPopup
              onClose={() => setpopup(0)}
              onImport={handleImportWallets}
            />
          </div>
        ) : null}

        {popup === 33 ? (
          <div ref={popupref}>
            <LiveTradesSettingsPopup
              onClose={() => setpopup(0)}
            />
          </div>
        ) : null}

        {popup === 34 ? (
          <div ref={popupref}>
            <TradingPresetsPopup
              onClose={() => setpopup(0)}
            />
          </div>
        ) : null}


        {popup === 35 ? (
          <div className="leverage-modal-overlay">
            <div className="leverage-modal-content" ref={popupref}>
              <div className="leverage-modal-header">
                <h2 className="leverage-modal-title">Adjust Leverage</h2>
                <button
                  className="close-button"
                  onClick={() => setpopup(0)}
                >
                  
                </button>
              </div>

              <div className="leverage-modal-body">
                <p className="leverage-description">
                  Adjust your leverage to manage your exposure. Higher leverage increases
                  both potential profits and risks.
                </p>

                <div className="leverage-slider-section">
                  <div className="leverage-slider-container">
                    <input
                      ref={(el) => {
                        if (el && popup === 35) {
                          const leverageValue = parseFloat(perpsLeverage) || 10;
                          const percent = ((leverageValue - 1) / Number(perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage)) * 100;
                          const thumbW = 16;
                          const container = el.parentElement;
                          if (container) {
                            const popup = container.querySelector('.leverage-value-popup') as HTMLElement;
                            if (popup) {
                              const containerRect = container.getBoundingClientRect();
                              const inputRect = el.getBoundingClientRect();
                              const inputLeft = inputRect.left - containerRect.left;
                              const x = inputLeft + (percent / 100) * (inputRect.width - thumbW) + thumbW / 2;
                              popup.style.left = `${x}px`;
                              popup.style.transform = 'translateX(-50%)';
                            }
                          }
                        }
                      }}
                      type="range"
                      min="1"
                      max={perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage}
                      step="1"
                      value={parseFloat(perpsLeverage) || 10}
                      onChange={(e) => {
                        const value = e.target.value;
                        setPerpsLeverage(value);

                        const container = e.target.parentElement;
                        if (container) {
                          const popup = container.querySelector('.leverage-value-popup') as HTMLElement;
                          if (popup) {
                            const percent = ((parseInt(value) - 1) / Number(perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage)) * 100;
                            const thumbW = 16;
                            const containerRect = container.getBoundingClientRect();
                            const inputRect = e.target.getBoundingClientRect();
                            const inputLeft = inputRect.left - containerRect.left;
                            const x = inputLeft + (percent / 100) * (inputRect.width - thumbW) + thumbW / 2;
                            popup.style.left = `${x}px`;
                            popup.style.transform = 'translateX(-50%)';
                          }
                        }
                      }}
                      onMouseDown={(e) => {
                        const container = e.currentTarget.parentElement;
                        if (container) {
                          const popup = container.querySelector('.leverage-value-popup') as HTMLElement;
                          if (popup) popup.classList.add('visible');
                        }
                      }}
                      onMouseUp={(e) => {
                        const container = e.currentTarget.parentElement;
                        if (container) {
                          const popup = container.querySelector('.leverage-value-popup') as HTMLElement;
                          if (popup) popup.classList.remove('visible');
                        }
                      }}
                      className="leverage-slider-input"
                      style={{
                        background: `linear-gradient(to right, #aaaecf ${((parseFloat(perpsLeverage) || 10) - 1) / Number(perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage) * 100}%, #2a2a2f ${((parseFloat(perpsLeverage) || 10) - 1) / Number(perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage) * 100}%)`
                      }}
                    />

                    <div className="leverage-value-popup">
                      {parseFloat(perpsLeverage) || 10}x
                    </div>

                    <div className="leverage-marks">
                      {[1, Number(perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage) / 4, Number(perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage) / 2, Number(perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage) / 4 * 3, Number(perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage)].map((mark) => (
                        <span
                          key={mark}
                          className="leverage-mark"
                          data-active={parseFloat(perpsLeverage) >= mark}
                          onClick={() => {
                            setPerpsLeverage(mark.toString());
                            const sliderContainer = document.querySelector('.leverage-slider-container');
                            if (sliderContainer) {
                              const input = sliderContainer.querySelector('.leverage-slider-input') as HTMLInputElement;
                              const popup = sliderContainer.querySelector('.leverage-value-popup') as HTMLElement;
                              if (input && popup) {
                                const percent = ((mark - 1) / Number(perpsMarketsData[perpsActiveMarketKey]?.displayMaxLeverage)) * 100;
                                const thumbW = 16;
                                const containerRect = sliderContainer.getBoundingClientRect();
                                const inputRect = input.getBoundingClientRect();
                                const inputLeft = inputRect.left - containerRect.left;
                                const x = inputLeft + (percent / 100) * (inputRect.width - thumbW) + thumbW / 2;
                                popup.style.left = `${x}px`;
                                popup.style.transform = 'translateX(-50%)';
                              }
                            }
                          }}
                        >
                          {mark}x
                        </span>
                      ))}
                    </div>
                  </div>

                  <div className="leverage-display">
                    Leverage: <span className="leverage-value">{parseFloat(perpsLeverage) || 10}x</span>
                  </div>
                </div>

                <button
                  className="leverage-update-button"
                  onClick={() => {
                    localStorage.setItem('crystal_perps_leverage', perpsLeverage);
                    setpopup(0);
                  }}
                >
                  Update Leverage
                </button>
              </div>
            </div>
          </div>
        ) : null}
        {popup === 36 ? (
          <div ref={popupref}>
            <MemeSearch
              setpopup={setpopup}
              monUsdPrice={monUsdPrice}
              onTokenClick={handleTokenClick}
              onQuickBuy={handleQuickBuy}
              sendUserOperationAsync={sendUserOperationAsync}
              quickAmounts={quickAmounts}
              setQuickAmount={setQuickAmount}
              activePresets={activePresets}
              setActivePreset={setActivePreset}
              handleInputFocus={handleInputFocus}
              buyPresets={buyPresets}
              marketsData={marketsData}
              tokendict={tokendict}
              onMarketSelect={onMarketSelect}
            />
          </div>
        ) : null}
      </div>
    </>
  );

  // trade ui component
  const swap = (
    <div className="rectangle">
      <div className="navlinkwrapper" onClick={() => {
        if (windowWidth <= 1020 && !simpleView && !showTrade) {
          setShowTrade(true);
          document.querySelector('.trade-mobile-switch')?.classList.add('open');
        }
      }} data-active={location.pathname.slice(1)}>
        <div className="innernavlinkwrapper">
          <Link
            to={simpleView ? "/swap" : "/market"}
            className={`navlink ${location.pathname.slice(1) === 'market' || location.pathname.slice(1) === 'swap' ? 'active' : ''}`}
            onClick={(e) => {
              if ((location.pathname === '/swap' && simpleView) ||
                (location.pathname === '/market' && !simpleView)) {
                e.preventDefault();
              }
            }}
          >
            {simpleView ? t('swap') : t('market')}
          </Link>
          <Link
            to="/limit"
            className={`navlink ${location.pathname.slice(1) === 'limit' ? 'active' : ''}`}
          >
            {t('limit')}
          </Link>
          <span
            ref={(el: HTMLSpanElement | null) => {
              sendButtonRef.current = el;
            }}
            className={`navlink ${location.pathname.slice(1) === 'send' || location.pathname.slice(1) === 'scale' ? 'active' : ''}`}
            onClick={(e: React.MouseEvent) => {
              e.preventDefault();
              setShowSendDropdown(!showSendDropdown);
            }}
          >
            <span className="current-pro-text">{t(currentProText)}</span>
            <svg
              className={`dropdown-arrow ${showSendDropdown ? 'open' : ''}`}
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="12"
              height="12"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            >
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </span>
          <button
            className={`refresh-quote-button ${isRefreshing ? 'refreshing' : ''}`}
            onClick={handleRefreshQuote}
            disabled={isRefreshing}
          >
            <img src={reset} className="refresh-quote-icon"></img>
            <svg className="refresh-timer-circle" viewBox="0 0 24 24">
              <circle className="timer-circle-border" cx="12" cy="12" r="9" />
            </svg>
          </button>
          {showSendDropdown && (
            <div className="navlink-dropdown" ref={sendDropdownRef}>
              <Link
                to="/send"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('send');
                }}
              >
                {t('send')}
              </Link>
              <Link
                to="/scale"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('scale');
                }}
              >
                <TooltipLabel
                  label={t('scale')}
                  tooltipText={
                    <div>
                      <div className="tooltip-description">
                        {t('scaleTooltip')}
                      </div>
                    </div>
                  }
                  className="impact-label"
                />
              </Link>

            </div>
          )}
        </div>
        <div className="sliding-tab-indicator" />
      </div>
      <div className="swapmodal">
        <div
          className={`inputbg ${connected && amountIn > tokenBalances[tokenIn] && !txPending.current
            ? 'exceed-balance'
            : ''
            }`}
        >
          <div className="Pay">{t('pay')}</div>
          <div className="inputbutton1container">
            {displayValuesLoading &&
              switched == true &&
              !(inputString == '' && outputString == '') ? (
              <div className="output-skeleton" />
            ) : (
              <input
                inputMode="decimal"
                className={`input ${connected &&
                  amountIn > tokenBalances[tokenIn] && !txPending.current
                  ? 'exceed-balance'
                  : ''
                  }`}
                onCompositionStart={() => {
                  setIsComposing(true);
                }}
                onCompositionEnd={(
                  e: React.CompositionEvent<HTMLInputElement>,
                ) => {
                  setIsComposing(false);
                  if (/^\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                    setInputString(e.currentTarget.value);
                    if (
                      (inputString.endsWith('.') && e.currentTarget.value === inputString.slice(0, -1)) ||
                      (e.currentTarget.value.endsWith('.') && e.currentTarget.value.slice(0, -1) === inputString)
                    ) {
                      return;
                    }
                    const inputValue = BigInt(
                      Math.round(
                        (parseFloat(e.currentTarget.value || '0') || 0) *
                        10 ** Number(tokendict[tokenIn].decimals),
                      ),
                    );
                    debouncedSetAmount(inputValue);
                    setswitched(false);
                    if (isWrap) {
                      setamountOutSwap(inputValue);
                      setoutputString(e.currentTarget.value);
                    }
                    const percentage = !tokenBalances[tokenIn]
                      ? 0
                      : Math.min(
                        100,
                        Math.floor(
                          Number(
                            (inputValue * BigInt(100)) /
                            tokenBalances[tokenIn],
                          ),
                        ),
                      );
                    setSliderPercent(percentage);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                }}
                onChange={(e) => {
                  if (isComposing) {
                    setInputString(e.target.value);
                    return;
                  }
                  if (/^\d*\.?\d{0,18}$/.test(e.target.value)) {
                    setInputString(e.target.value);
                    if (
                      (inputString.endsWith('.') && e.target.value === inputString.slice(0, -1)) ||
                      (e.target.value.endsWith('.') && e.target.value.slice(0, -1) === inputString)
                    ) {
                      return;
                    }
                    const inputValue = BigInt(
                      Math.round(
                        (parseFloat(e.target.value || '0') || 0) *
                        10 ** Number(tokendict[tokenIn].decimals),
                      ),
                    );
                    debouncedSetAmount(inputValue);
                    setswitched(false);
                    if (isWrap) {
                      setamountOutSwap(inputValue);
                      setoutputString(e.target.value);
                    }
                    const percentage = !tokenBalances[tokenIn]
                      ? 0
                      : Math.min(
                        100,
                        Math.floor(
                          Number(
                            (inputValue * BigInt(100)) /
                            tokenBalances[tokenIn],
                          ),
                        ),
                      );
                    setSliderPercent(percentage);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                }}
                placeholder="0.00"
                value={inputString}
                autoFocus={
                  outputString === '' &&
                  switched === false &&
                  !(windowWidth <= 1020)
                }
              />
            )}
            <button
              className={`button1 ${connected &&
                amountIn > tokenBalances[tokenIn] && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onClick={() => {
                setpopup(1);
              }}
            >
              <img className="button1pic" src={tokendict[tokenIn].image} />
              <span>{tokendict[tokenIn].ticker || '?'}</span>
              <svg
                className={`button-arrow ${popup == 1 ? 'open' : ''}`}
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                width="16"
                height="16"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </button>
          </div>
          <div className="balance1maxcontainer">
            {displayValuesLoading &&
              switched == true &&
              !(inputString == '' && outputString == '') ? (
              <div className="output-usd-skeleton" />
            ) : (
              <span className="usd-value">
                {Math.round(
                  (parseFloat(inputString || '0') || 0) *
                  10 ** Number(tokendict[tokenIn].decimals),
                ) == 0
                  ? '$0.00'
                  : formatUSDDisplay(
                    calculateUSDValue(
                      BigInt(
                        Math.round(
                          (parseFloat(inputString || '0') || 0) *
                          10 ** Number(tokendict[tokenIn].decimals),
                        ),
                      ),
                      tradesByMarket[
                      (({ baseAsset, quoteAsset }) =>
                        (baseAsset === wethticker ? ethticker : baseAsset) +
                        (quoteAsset === wethticker ? ethticker : quoteAsset)
                      )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                      ],
                      tokenIn,
                      getMarket(
                        activeMarket.path.at(0),
                        activeMarket.path.at(1),
                      ),
                    ),
                  )}
              </span>
            )}
            <div className="balance1">
              <img src={walleticon} className="balance-wallet-icon" />{' '}
              {formatSubscript(formatDisplayValue(
                tokenBalances[tokenIn],
                Number(tokendict[tokenIn].decimals),
              ))}
            </div>
            <div
              className="max-button"
              onClick={() => {
                if (tokenBalances[tokenIn] != BigInt(0)) {
                  let amount =
                    (tokenIn == eth && !client)
                      ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount >
                        BigInt(0)
                        ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount
                        : BigInt(0)
                      : tokenBalances[tokenIn];
                  debouncedSetAmount(BigInt(amount));
                  setswitched(false);
                  setInputString(
                    customRound(
                      Number(amount) /
                      10 ** Number(tokendict[tokenIn].decimals),
                      3,
                    ).toString(),
                  );
                  if (isWrap) {
                    setamountOutSwap(BigInt(amount));
                    setoutputString(
                      customRound(
                        Number(amount) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      ).toString(),
                    );
                  }
                  setSliderPercent(100);
                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    const trackWidth = rect.width - 15;
                    const thumbPosition = trackWidth + 15 / 2;
                    (popup as HTMLElement).style.left = `${thumbPosition}px`;
                  }
                }
              }}
            >
              {t('max')}{' '}
            </div>
          </div>
        </div>
        <div
          className="switch-button"
          onClick={() => {
            setTokenIn(tokenOut);
            setTokenOut(tokenIn);
            if (amountIn != BigInt(0) || amountOutSwap != BigInt(0)) {
              if (!isWrap) {
                if (switched == false) {
                  setswitched(true);
                  setStateIsLoading(true);
                  setInputString('');
                  setamountIn(BigInt(0));
                  setamountOutSwap(amountIn);
                  setoutputString(
                    amountIn == BigInt(0)
                      ? ''
                      : String(
                        customRound(
                          Number(amountIn) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ),
                      ),
                  );
                } else {
                  setswitched(false);
                  setStateIsLoading(true);
                  setoutputString('');
                  setamountOutSwap(BigInt(0));
                  setamountIn(amountOutSwap);
                  setInputString(
                    amountOutSwap == BigInt(0)
                      ? ''
                      : String(
                        customRound(
                          Number(amountOutSwap) /
                          10 ** Number(tokendict[tokenOut].decimals),
                          3,
                        ),
                      ),
                  );
                  const percentage = !tokenBalances[tokenOut]
                    ? 0
                    : Math.min(
                      100,
                      Math.floor(
                        Number(
                          (amountOutSwap * BigInt(100)) /
                          tokenBalances[tokenOut],
                        ),
                      ),
                    );
                  setSliderPercent(percentage);
                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    (popup as HTMLElement).style.left =
                      `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                  }
                }
              }
            }
          }}
        >
          <img src={tradearrow} className="switch-arrow" />
        </div>
        <div className="swap-container-divider" />
        <div className="outputbg">
          <div className="Recieve">{t('receive')}</div>
          <div className="outputbutton2container">
            {displayValuesLoading &&
              switched == false &&
              !(inputString == '' && outputString == '') ? (
              <div className="output-skeleton" />
            ) : (
              <input
                inputMode="decimal"
                className="output"
                onCompositionStart={() => {
                  setIsComposing(true);
                }}
                onCompositionEnd={(
                  e: React.CompositionEvent<HTMLInputElement>,
                ) => {
                  setIsComposing(false);
                  if (/^\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                    setoutputString(e.currentTarget.value);
                    if (
                      (outputString.endsWith('.') && e.currentTarget.value === outputString.slice(0, -1)) ||
                      (e.currentTarget.value.endsWith('.') && e.currentTarget.value.slice(0, -1) === outputString)
                    ) {
                      return;
                    }
                    const outputValue = BigInt(
                      Math.round(
                        (parseFloat(e.currentTarget.value || '0') || 0) *
                        10 ** Number(tokendict[tokenOut].decimals),
                      ),
                    );
                    if (isWrap) {
                      setamountIn(outputValue);
                      setInputString(e.currentTarget.value);
                    }
                    debouncedSetAmountOut(outputValue);
                    setswitched(true);
                  }
                }}
                onChange={(e) => {
                  if (isComposing) {
                    setoutputString(e.target.value);
                    return;
                  }
                  if (/^\d*\.?\d{0,18}$/.test(e.target.value)) {
                    setoutputString(e.target.value);
                    if (
                      (outputString.endsWith('.') && e.target.value === outputString.slice(0, -1)) ||
                      (e.target.value.endsWith('.') && e.target.value.slice(0, -1) === outputString)
                    ) {
                      return;
                    }
                    const outputValue = BigInt(
                      Math.round(
                        (parseFloat(e.target.value || '0') || 0) *
                        10 ** Number(tokendict[tokenOut].decimals),
                      ),
                    );
                    if (isWrap) {
                      setamountIn(outputValue);
                      setInputString(e.target.value);
                    }
                    debouncedSetAmountOut(outputValue);
                    setswitched(true);
                  }
                }}
                value={outputString}
                placeholder="0.00"
              />
            )}
            <button
              className="button2"
              onClick={() => {
                setpopup(2);
              }}
            >
              <img className="button2pic" src={tokendict[tokenOut].image} />
              <span>{tokendict[tokenOut].ticker || '?'}</span>
              <svg
                className={`button-arrow ${popup == 2 ? 'open' : ''}`}
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                width="16"
                height="16"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </button>
          </div>
          <div className="balance1maxcontainer">
            {displayValuesLoading &&
              switched == false &&
              !(inputString == '' && outputString == '') ? (
              <div className="output-usd-skeleton" />
            ) : (
              <div className="output-usd-value">
                {amountOutSwap === BigInt(0)
                  ? '$0.00'
                  : (() => {
                    const outputUSD = calculateUSDValue(
                      BigInt(
                        Math.round(
                          (parseFloat(outputString || '0') || 0) *
                          10 ** Number(tokendict[tokenOut].decimals),
                        ),
                      ),
                      tradesByMarket[
                      (({ baseAsset, quoteAsset }) =>
                        (baseAsset === wethticker ? ethticker : baseAsset) +
                        (quoteAsset === wethticker ? ethticker : quoteAsset)
                      )(getMarket(activeMarket.path.at(-2), activeMarket.path.at(-1)))
                      ],
                      tokenOut,
                      getMarket(
                        activeMarket.path.at(-2),
                        activeMarket.path.at(-1),
                      ),
                    );

                    const inputUSD = calculateUSDValue(
                      amountIn,
                      tradesByMarket[
                      (({ baseAsset, quoteAsset }) =>
                        (baseAsset === wethticker ? ethticker : baseAsset) +
                        (quoteAsset === wethticker ? ethticker : quoteAsset)
                      )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                      ],
                      tokenIn,
                      getMarket(
                        activeMarket.path.at(0),
                        activeMarket.path.at(1),
                      ),
                    );

                    const percentageDiff =
                      inputUSD > 0
                        ? ((outputUSD - inputUSD) / inputUSD) * 100
                        : 0;

                    return (
                      <div className="output-usd-container">
                        <span>{formatUSDDisplay(outputUSD)}</span>
                        {inputUSD > 0 && !displayValuesLoading && !stateIsLoading && (
                          <span
                            className={`output-percentage ${percentageDiff >= 0 ? 'positive' : 'negative'}`}
                          >
                            ({percentageDiff >= 0 ? '+' : ''}
                            {percentageDiff.toFixed(2)}%)
                          </span>
                        )}
                      </div>
                    );
                  })()}
              </div>
            )}
            <div className="balance2">
              <img src={walleticon} className="balance-wallet-icon" />{' '}
              {formatSubscript(formatDisplayValue(
                tokenBalances[tokenOut],
                Number(tokendict[tokenOut].decimals),
              ))}
            </div>
          </div>
        </div>
        <div className="balance-slider-wrapper">
          {spotSliderMode === 'presets' ? (
            <div className="slider-container presets-mode">
              <div className="preset-buttons">
                {spotSliderPresets.map((preset: number, index: number) => (
                  <button
                    key={index}
                    className={`preset-button ${sliderPercent === preset ? 'active' : ''}`}
                    onClick={() => {
                      if (connected) {
                        const newAmount =
                          (((tokenIn == eth && !client)
                            ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount >
                              BigInt(0)
                              ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount
                              : BigInt(0)
                            : tokenBalances[tokenIn]) *
                            BigInt(preset)) /
                          100n;
                        setSliderPercent(preset);
                        setInputString(
                          newAmount == BigInt(0)
                            ? ''
                            : customRound(
                              Number(newAmount) /
                              10 ** Number(tokendict[tokenIn].decimals),
                              3,
                            ).toString(),
                        );
                        debouncedSetAmount(newAmount);
                        setswitched(false);
                        if (isWrap) {
                          setoutputString(
                            newAmount == BigInt(0)
                              ? ''
                              : customRound(
                                Number(newAmount) /
                                10 ** Number(tokendict[tokenIn].decimals),
                                3,
                              ).toString(),
                          );
                          setamountOutSwap(newAmount);
                        }
                        if (location.pathname.slice(1) === 'limit') {
                          setamountOutSwap(
                            limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                                : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                              : BigInt(0),
                          );
                          setoutputString(
                            (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? customRound(
                                  Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                                : customRound(
                                  Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        const slider = document.querySelector('.balance-amount-slider');
                        const popup = document.querySelector('.slider-percentage-popup');
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left = `${(rect.width - 15) * (preset / 100) + 15 / 2}px`;
                        }
                      }
                    }}
                    disabled={!connected}
                  >
                    {preset}%
                  </button>
                ))}
              </div>
            </div>
          ) : spotSliderMode === 'increment' ? (
            <div className="slider-container increment-mode">
              <button
                className="increment-button minus"
                onClick={() => {
                  if (connected && sliderPercent > 0) {
                    const newPercent = Math.max(0, sliderPercent - spotSliderIncrement);
                    const newAmount =
                      (((tokenIn == eth && !client)
                        ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : tokenBalances[tokenIn]) *
                        BigInt(newPercent)) /
                      100n;
                    setSliderPercent(newPercent);
                    setInputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    debouncedSetAmount(newAmount);
                    setswitched(false);
                    if (isWrap) {
                      setoutputString(
                        newAmount == BigInt(0)
                          ? ''
                          : customRound(
                            Number(newAmount) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          ).toString(),
                      );
                      setamountOutSwap(newAmount);
                    }
                    if (location.pathname.slice(1) === 'limit') {
                      setamountOutSwap(
                        limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                            : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                          : BigInt(0),
                      );
                      setoutputString(
                        (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                            : customRound(
                              Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                          : ''
                        ).toString(),
                      );
                    }
                    const slider = document.querySelector('.balance-amount-slider');
                    const popup = document.querySelector('.slider-percentage-popup');
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (newPercent / 100) + 15 / 2}px`;
                    }
                  }
                }}
                disabled={!connected || sliderPercent === 0}
              >
                
              </button>
              <div className="increment-display">
                <div className="increment-amount">{spotSliderIncrement}%</div>
              </div>
              <button
                className="increment-button plus"
                onClick={() => {
                  if (connected && sliderPercent < 100) {
                    const newPercent = Math.min(100, sliderPercent + spotSliderIncrement);
                    const newAmount =
                      (((tokenIn == eth && !client)
                        ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : tokenBalances[tokenIn]) *
                        BigInt(newPercent)) /
                      100n;
                    setSliderPercent(newPercent);
                    setInputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    debouncedSetAmount(newAmount);
                    setswitched(false);
                    if (isWrap) {
                      setoutputString(
                        newAmount == BigInt(0)
                          ? ''
                          : customRound(
                            Number(newAmount) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          ).toString(),
                      );
                      setamountOutSwap(newAmount);
                    }
                    if (location.pathname.slice(1) === 'limit') {
                      setamountOutSwap(
                        limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                            : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                          : BigInt(0),
                      );
                      setoutputString(
                        (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                            : customRound(
                              Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                          : ''
                        ).toString(),
                      );
                    }
                    const slider = document.querySelector('.balance-amount-slider');
                    const popup = document.querySelector('.slider-percentage-popup');
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (newPercent / 100) + 15 / 2}px`;
                    }
                  }
                }}
                disabled={!connected || sliderPercent === 100}
              >
                +
              </button>
            </div>
          ) : (
            <div className="slider-container slider-mode">
              <input
                type="range"
                className={`balance-amount-slider ${isDragging ? 'dragging' : ''}`}
                min="0"
                max="100"
                step="1"
                value={sliderPercent}
                disabled={!connected}
                onChange={(e) => {
                  const percent = parseInt(e.target.value);
                  const newAmount =
                    (((tokenIn == eth && !client)
                      ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount >
                        BigInt(0)
                        ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount
                        : BigInt(0)
                      : tokenBalances[tokenIn]) *
                      BigInt(percent)) /
                    100n;
                  setSliderPercent(percent);
                  setInputString(
                    newAmount == BigInt(0)
                      ? ''
                      : customRound(
                        Number(newAmount) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      ).toString(),
                  );
                  debouncedSetAmount(newAmount);
                  setswitched(false);
                  if (isWrap) {
                    setoutputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    setamountOutSwap(newAmount);
                  }
                  if (location.pathname.slice(1) === 'limit') {
                    setamountOutSwap(
                      limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                          : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                        : BigInt(0),
                    );
                    setoutputString(
                      (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                            10 ** Number(tokendict[tokenOut].decimals),
                            3,
                          )
                          : customRound(
                            Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                            10 ** Number(tokendict[tokenOut].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                  }
                  const slider = e.target;
                  const rect = slider.getBoundingClientRect();
                  const trackWidth = rect.width - 15;
                  const thumbPosition = (percent / 100) * trackWidth + 15 / 2;
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) {
                    popup.style.left = `${thumbPosition}px`;
                  }
                }}
                onMouseDown={() => {
                  setIsDragging(true);
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) popup.classList.add('visible');
                }}
                onMouseUp={() => {
                  setIsDragging(false);
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) popup.classList.remove('visible');
                }}
                style={{
                  background: `linear-gradient(to right,rgb(171, 176, 224) ${sliderPercent}%,rgb(21, 21, 27, 1) ${sliderPercent}%)`,
                }}
              />
              <div className="slider-percentage-popup">{sliderPercent}%</div>
              <div className="balance-slider-marks">
                {[0, 25, 50, 75, 100].map((markPercent) => (
                  <span
                    key={markPercent}
                    className="balance-slider-mark"
                    data-active={sliderPercent >= markPercent}
                    data-percentage={markPercent}
                    onClick={() => {
                      if (connected) {
                        const newAmount =
                          (((tokenIn == eth && !client)
                            ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount >
                              BigInt(0)
                              ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount
                              : BigInt(0)
                            : tokenBalances[tokenIn]) *
                            BigInt(markPercent)) /
                          100n;
                        setSliderPercent(markPercent);
                        setInputString(
                          newAmount == BigInt(0)
                            ? ''
                            : customRound(
                              Number(newAmount) /
                              10 ** Number(tokendict[tokenIn].decimals),
                              3,
                            ).toString(),
                        );
                        debouncedSetAmount(newAmount);
                        setswitched(false);
                        if (isWrap) {
                          setoutputString(
                            newAmount == BigInt(0)
                              ? ''
                              : customRound(
                                Number(newAmount) /
                                10 ** Number(tokendict[tokenIn].decimals),
                                3,
                              ).toString(),
                          );
                          setamountOutSwap(newAmount);
                        }
                        if (location.pathname.slice(1) === 'limit') {
                          setamountOutSwap(
                            limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                                : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                              : BigInt(0),
                          );
                          setoutputString(
                            (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? customRound(
                                  Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                                : customRound(
                                  Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup: HTMLElement | null = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          popup.style.left = `${(rect.width - 15) * (markPercent / 100) + 15 / 2
                            }px`;
                        }
                      }
                    }}
                  >
                    {markPercent}%
                  </span>
                ))}
              </div>
            </div>
          )}
        </div>
        <button
          className={`swap-button ${isSigning ? 'signing' : ''}`}
          onClick={async () => {
            if (connected && userchain === activechain) {
              if (warning == 1) {
                setpopup(13);
                const confirmed = await new Promise((resolve) => {
                  const handleConfirm = () => {
                    cleanup();
                    resolve(true);
                  };

                  const handleCancel = () => {
                    cleanup();
                    resolve(false);
                  };

                  const cleanup = () => {
                    window.removeEventListener('high-impact-confirm', handleConfirm);
                    window.removeEventListener('high-impact-cancel', handleCancel);
                  };

                  window.addEventListener('high-impact-confirm', handleConfirm);
                  window.addEventListener('high-impact-cancel', handleCancel);

                });
                if (!confirmed) return;
              }
              let hash: any;
              setIsSigning(true);
              if (client) {
                txPending.current = true;
              }
              try {
                if (tokenIn == eth && tokenOut == weth) {
                  hash = await sendUserOperationAsync({ uo: wrapeth(amountIn, weth) }, (rpcQueryData?.gasEstimate ?? 0n));
                  newTxPopup(
                    hash,
                    'wrap',
                    eth,
                    weth,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    '',
                    ''
                  );
                } else if (tokenIn == weth && tokenOut == eth) {
                  hash = await sendUserOperationAsync({ uo: unwrapeth(amountIn, weth) }, (rpcQueryData?.gasEstimate ?? 0n));
                  newTxPopup(
                    hash,
                    'unwrap',
                    weth,
                    eth,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    '',
                    ''
                  );
                } else if (tokenIn == eth && tokendict[tokenOut]?.lst == true && isStake) {
                  hash = await sendUserOperationAsync({ uo: stake(tokenOut, address, amountIn) }, (rpcQueryData?.gasEstimate ?? 0n) * 1100n / 1000n);
                  newTxPopup(
                    hash,
                    'stake',
                    eth,
                    tokenOut,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    customRound(Number(amountIn) / 10 ** Number(tokendict[eth].decimals), 3),
                    '',
                    ''
                  );
                } else {
                  if (switched == false) {
                    if (tokenIn == eth) {
                      if (orderType == 1 || multihop) {
                        hash = await sendUserOperationAsync({
                          uo: swapExactETHForTokens(
                            router,
                            amountIn,
                            (amountOutSwap * slippage + 5000n) / 10000n,
                            activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                            address as `0x${string}`,
                            BigInt(Math.floor(Date.now() / 1000) + 900),
                            usedRefAddress as `0x${string}`
                          )
                        }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                      } else {
                        hash = await sendUserOperationAsync({
                          uo: _swap(
                            router,
                            amountIn,
                            activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                            activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                            true,
                            BigInt(0),
                            amountIn,
                            tokenIn == activeMarket.quoteAddress
                              ? (lowestAsk * 10000n + slippage / 2n) / slippage
                              : (highestBid * slippage + 5000n) / 10000n,
                            BigInt(Math.floor(Date.now() / 1000) + 900),
                            usedRefAddress as `0x${string}`
                          )
                        }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                      }
                    } else {
                      if (allowance < amountIn) {
                        if (client) {
                          let uo = []
                          uo.push(approve(
                            tokenIn as `0x${string}`,
                            router,
                            maxUint256
                          ))
                          if (tokenOut == eth) {
                            if (orderType == 1 || multihop) {
                              uo.push(swapExactTokensForETH(
                                router,
                                amountIn,
                                (amountOutSwap * slippage + 5000n) / 10000n,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            } else {
                              uo.push(_swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                true,
                                BigInt(0),
                                amountIn,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            }
                          } else {
                            if (orderType == 1 || multihop) {
                              uo.push(swapExactTokensForTokens(
                                router,
                                amountIn,
                                (amountOutSwap * slippage + 5000n) / 10000n,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            } else {
                              uo.push(_swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                true,
                                BigInt(0),
                                amountIn,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            }
                          }
                          hash = await sendUserOperationAsync({ uo: uo })
                          newTxPopup(
                            hash,
                            'approve',
                            tokenIn,
                            '',
                            customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn].decimals), 3),
                            0,
                            '',
                            router
                          );
                        }
                        else {
                          hash = await sendUserOperationAsync({
                            uo: approve(
                              tokenIn as `0x${string}`,
                              router,
                              maxUint256
                            )
                          })
                          newTxPopup(
                            hash,
                            'approve',
                            tokenIn,
                            '',
                            customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn].decimals), 3),
                            0,
                            '',
                            router
                          );
                        }
                      }
                      if (!client || !(allowance < amountIn)) {
                        if (tokenOut == eth) {
                          if (orderType == 1 || multihop) {
                            hash = await sendUserOperationAsync({
                              uo: swapExactTokensForETH(
                                router,
                                amountIn,
                                (amountOutSwap * slippage + 5000n) / 10000n,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          } else {
                            hash = await sendUserOperationAsync({
                              uo: _swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                true,
                                BigInt(0),
                                amountIn,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          }
                        } else {
                          if (orderType == 1 || multihop) {
                            hash = await sendUserOperationAsync({
                              uo: swapExactTokensForTokens(
                                router,
                                amountIn,
                                (amountOutSwap * slippage + 5000n) / 10000n,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          } else {
                            hash = await sendUserOperationAsync({
                              uo: _swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                true,
                                BigInt(0),
                                amountIn,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          }
                        }
                      }
                    }
                  } else {
                    if (tokenIn == eth) {
                      if (orderType == 1 || multihop) {
                        hash = await sendUserOperationAsync({
                          uo: swapETHForExactTokens(
                            router,
                            amountOutSwap,
                            (amountIn * 10000n + slippage / 2n) / slippage,
                            activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                            address as `0x${string}`,
                            BigInt(Math.floor(Date.now() / 1000) + 900),
                            usedRefAddress as `0x${string}`
                          )
                        }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                      } else {
                        hash = await sendUserOperationAsync({
                          uo: _swap(
                            router,
                            BigInt((amountIn * 10000n + slippage / 2n) / slippage),
                            activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                            activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                            false,
                            BigInt(0),
                            amountOutSwap,
                            tokenIn == activeMarket.quoteAddress
                              ? (lowestAsk * 10000n + slippage / 2n) / slippage
                              : (highestBid * slippage + 5000n) / 10000n,
                            BigInt(Math.floor(Date.now() / 1000) + 900),
                            usedRefAddress as `0x${string}`
                          )
                        }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                      }
                    } else {
                      if (allowance < amountIn) {
                        if (client) {
                          let uo = []
                          uo.push(approve(
                            tokenIn as `0x${string}`,
                            router,
                            maxUint256
                          ))
                          if (tokenOut == eth) {
                            if (orderType == 1 || multihop) {
                              uo.push(swapTokensForExactETH(
                                router,
                                amountOutSwap,
                                (amountIn * 10000n + slippage / 2n) / slippage,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            } else {
                              uo.push(_swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                true,
                                BigInt(0),
                                amountOutSwap,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            }
                          } else {
                            if (orderType == 1 || multihop) {
                              uo.push(swapTokensForExactTokens(
                                router,
                                amountOutSwap,
                                (amountIn * 10000n + slippage / 2n) / slippage,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            } else {
                              uo.push(_swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                true,
                                BigInt(0),
                                amountOutSwap,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              ))
                            }
                          }
                          hash = await sendUserOperationAsync({ uo: uo })
                          newTxPopup(
                            hash,
                            'approve',
                            tokenIn,
                            '',
                            customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn].decimals), 3),
                            0,
                            '',
                            router
                          );
                        }
                        else {
                          hash = await sendUserOperationAsync({
                            uo: approve(
                              tokenIn as `0x${string}`,
                              router,
                              maxUint256
                            )
                          })
                          newTxPopup(
                            hash,
                            'approve',
                            tokenIn,
                            '',
                            customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn].decimals), 3),
                            0,
                            '',
                            router
                          );
                        }
                      }
                      if (!client || !(allowance < amountIn)) {
                        if (tokenOut == eth) {
                          if (orderType == 1 || multihop) {
                            hash = await sendUserOperationAsync({
                              uo: swapTokensForExactETH(
                                router,
                                amountOutSwap,
                                (amountIn * 10000n + slippage / 2n) / slippage,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          } else {
                            hash = await sendUserOperationAsync({
                              uo: _swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                true,
                                BigInt(0),
                                amountOutSwap,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          }
                        } else {
                          if (orderType == 1 || multihop) {
                            hash = await sendUserOperationAsync({
                              uo: swapTokensForExactTokens(
                                router,
                                amountOutSwap,
                                (amountIn * 10000n + slippage / 2n) / slippage,
                                activeMarket.path[0] == tokenIn ? activeMarket.path : [...activeMarket.path].reverse(),
                                address as `0x${string}`,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          } else {
                            hash = await sendUserOperationAsync({
                              uo: _swap(
                                router,
                                BigInt(0),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(0) : activeMarket.path.at(1),
                                activeMarket.path[0] == tokenIn ? activeMarket.path.at(1) : activeMarket.path.at(0),
                                true,
                                BigInt(0),
                                amountOutSwap,
                                tokenIn == activeMarket.quoteAddress
                                  ? (lowestAsk * 10000n + slippage / 2n) / slippage
                                  : (highestBid * slippage + 5000n) / 10000n,
                                BigInt(Math.floor(Date.now() / 1000) + 900),
                                usedRefAddress as `0x${string}`
                              )
                            }, (rpcQueryData?.gasEstimate ?? 0n) * 1500n / 1000n)
                          }
                        }
                      }
                    }
                  }
                }
                if (!client) {
                  txPending.current = true
                }
                setswitched(false);
                setInputString('');
                setamountIn(BigInt(0));
                setoutputString('')
                setamountOutSwap(BigInt(0));
                setSliderPercent(0);
                setSwapButtonDisabled(true);
                setSwapButton(1);
                setIsSigning(false)
                const slider = document.querySelector('.balance-amount-slider');
                const popup = document.querySelector('.slider-percentage-popup');
                if (slider && popup) {
                  (popup as HTMLElement).style.left = `${15 / 2}px`;
                }
                await refetch()
                txPending.current = false
              } catch (error) {
                if (!(error instanceof TransactionExecutionError)) {
                  newTxPopup(
                    hash,
                    "swapFailed",
                    tokenIn == eth ? eth : tokenIn,
                    tokenOut == eth ? eth : tokenOut,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn == eth ? eth : tokenIn].decimals), 3),
                    customRound(Number(amountOutSwap) / 10 ** Number(tokendict[tokenOut == eth ? eth : tokenOut].decimals), 3),
                    "",
                    "",
                  );
                }
              } finally {
                txPending.current = false
                setIsSigning(false)
              }
            } else {
              !connected ? setpopup(4) : handleSetChain();
            }
          }}
          disabled={swapButtonDisabled || displayValuesLoading || isSigning}
        >
          {isSigning ? (
            <div className="button-content">
              <div className="loading-spinner" />
              {validOneCT ? t('') : t('signTransaction')}
            </div>
          ) : swapButton == 0 ? (
            t('insufficientLiquidity')
          ) : swapButton == 1 ? (
            t('enterAmount')
          ) : swapButton == 2 ? (
            t('swap')
          ) : swapButton == 3 ? (
            t('insufficient') +
            (tokendict[tokenIn].ticker || '?') +
            ' ' +
            t('bal')
          ) : swapButton == 4 ? (
            `${t('switchto')} ${t(settings.chainConfig[activechain].name)}`
          ) : swapButton == 5 ? (
            t('connectWallet')
          ) : (
            client ? t('swap') : t('approve')
          )}
        </button>
      </div>
      <div className="trade-info-rectangle">
        {(tokenIn == eth && tokendict[tokenOut]?.lst == true) && <div className="trade-fee">
          <div className="label-container">
            <TooltipLabel
              label={t('stake')}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {t('stakeSubtitle')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <ToggleSwitch
            checked={isStake}
            onChange={() => {
              const newValue = isStake == true ? false : true;
              setIsStake(newValue);
            }}
          />
        </div>}
        {!multihop && !isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) && (
          <div className="trade-fee">
            <div className="label-container">
              <TooltipLabel
                label={t('partialFill')}
                tooltipText={
                  <div>
                    <div className="tooltip-description">
                      {t('partialFillSubtitle')}
                    </div>
                  </div>
                }
                className="impact-label"
              />
            </div>
            <ToggleSwitch
              checked={orderType === 0}
              onChange={() => {
                const newValue = orderType === 1 ? 0 : 1;
                setorderType(newValue);
                localStorage.setItem(
                  'crystal_order_type',
                  JSON.stringify(newValue),
                );
              }}
            />
          </div>
        )}

        {!isWrap && !((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) && (
          <div className="slippage-row">
            <div className="label-container">
              <div className="slippage-group">
                <TooltipLabel
                  label={t('slippage')}
                  tooltipText={
                    <div>
                      <div className="tooltip-description">
                        {t('slippageHelp')}
                      </div>
                    </div>
                  }
                  className="slippage-label"
                />
              </div>
            </div>
            <div className="slippage-input-container">
              <input
                inputMode="decimal"
                className={`slippage-inline-input ${parseFloat(slippageString) > 5 ? 'red' : ''
                  }`}
                type="text"
                value={slippageString}
                onKeyDown={(e) => {
                  if (e.key === 'Enter') {
                    (e.target as HTMLInputElement).blur()
                    e.stopPropagation()
                  };
                }}
                onChange={(e) => {
                  const value = e.target.value;

                  if (
                    /^(?!0{2})\d*\.?\d{0,2}$/.test(value) &&
                    !/^\d{2}\.\d{2}$/.test(value)
                  ) {
                    if (value === '') {
                      setSlippageString('');
                      setSlippage(BigInt(9900));
                      localStorage.setItem('crystal_slippage_string', '1');
                      localStorage.setItem('crystal_slippage', '9900');
                    } else if (parseFloat(value) <= 50) {
                      setSlippageString(value);
                      localStorage.setItem('crystal_slippage_string', value);

                      const newSlippage = BigInt(
                        10000 - parseFloat(value) * 100,
                      );
                      setSlippage(newSlippage);
                      localStorage.setItem(
                        'crystal_slippage',
                        newSlippage.toString(),
                      );
                    }
                  }
                }}
                onBlur={() => {
                  if (slippageString === '') {
                    setSlippageString('1');
                    localStorage.setItem('crystal_slippage_string', '1');

                    setSlippage(BigInt(9900));
                    localStorage.setItem('crystal_slippage', '9900');
                  }
                }}
              />
              <span
                className={`slippage-symbol ${parseFloat(slippageString) > 5 ? 'red' : ''
                  }`}
              >
                %
              </span>
            </div>
          </div>
        )}

        {!isWrap && (
          <div className="average-price">
            <div className="label-container">
              <TooltipLabel
                label={t('averagePrice')}
                tooltipText={
                  <div>
                    <div className="tooltip-description">
                      {t('averagePriceHelp')}
                    </div>
                  </div>
                }
                className="impact-label"
              />
            </div>
            <div className="value-container">
              {displayValuesLoading ? (
                <div className="limit-fee-skeleton" style={{ width: 80 }} />
              ) : isWrap ? (
                `1 ${tokendict[tokenOut].ticker}`
              ) : (
                `${formatSubscript(averagePrice)} ${multihop ? tokendict[tokenIn].ticker : activeMarket.quoteAsset}`
              )}
            </div>
          </div>
        )}

        <div className="price-impact">
          <div className="label-container">
            <TooltipLabel
              label={t('priceImpact')}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {t('priceImpactHelp')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <div className="value-container">
            {displayValuesLoading ? (
              <div className="limit-fee-skeleton" style={{ width: 60 }} />
            ) : isWrap || ((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) ? (
              `0%`
            ) : priceImpact ? (
              formatCommas(priceImpact)
            ) : (
              '0.00%'
            )}
          </div>
        </div>

        <div className="trade-fee">
          <div className="label-container">
            <TooltipLabel
              label={`${t('fee')} (0.${isWrap || ((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) ? '00' : String(Number(BigInt(100000) - activeMarket.fee) / 100).replace(/\./g, "")}%)`}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {isWrap ? t('nofeeforwrap') : t('takerfeeexplanation')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <div className="value-container">
            {displayValuesLoading ? (
              <div className="limit-fee-skeleton" style={{ width: 70 }} />
            ) : isWrap || ((tokenIn == eth && tokendict[tokenOut]?.lst == true) && isStake) ? (
              `0 ${tokendict[tokenIn].ticker}`
            ) : (
              formatCommas(tradeFee)
            )}
          </div>
        </div>

        {(warning == 1 && (
          <div className="price-impact-warning">{t('Warning')}</div>
        )) ||
          (warning == 2 && (
            <div className="price-impact-warning">
              {t('insufficientLiquidityWarning')}
            </div>
          )) ||
          (warning == 3 && (
            <div className="price-impact-warning">
              {t('insufficientLiquidityWarningMultihop')}
            </div>
          ))}
      </div>
    </div>
  );

  // limit ui component
  const limit = (
    <div className="rectangle">
      <div className="navlinkwrapper" data-active={location.pathname.slice(1)} onClick={() => {
        if (windowWidth <= 1020 && !simpleView && !showTrade) {
          setShowTrade(true);
          document.querySelector('.trade-mobile-switch')?.classList.add('open');
        }
      }}>
        <div className="innernavlinkwrapper">
          <Link
            to={simpleView ? "/swap" : "/market"}
            className={`navlink ${location.pathname.slice(1) === 'swap' ? 'active' : ''}`}
          >
            {simpleView ? t('swap') : t('market')}
          </Link>
          <Link
            to="/limit"
            className={`navlink ${location.pathname.slice(1) === 'limit' ? 'active' : ''}`}
            onClick={(e) => {
              if (location.pathname === '/limit') {
                e.preventDefault();
              }
            }}
          >
            {t('limit')}
          </Link>
          <span
            ref={(el: HTMLSpanElement | null) => {
              sendButtonRef.current = el;
            }}
            className={`navlink ${location.pathname.slice(1) != 'swap' && location.pathname.slice(1) != 'limit' ? 'active' : ''}`}
            onClick={(e: React.MouseEvent) => {
              e.preventDefault();
              setShowSendDropdown(!showSendDropdown);
            }}
          >
            <span className="current-pro-text">{t(currentProText)}</span>
            <svg
              className={`dropdown-arrow ${showSendDropdown ? 'open' : ''}`}
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="12"
              height="12"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            >
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </span>

          {showSendDropdown && (
            <div className="navlink-dropdown" ref={sendDropdownRef}>
              <Link
                to="/send"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('send');
                }}
              >
                {t('send')}
              </Link>
              <Link
                to="/scale"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('scale');
                }}
              >
                <TooltipLabel
                  label={t('scale')}
                  tooltipText={
                    <div>
                      <div className="tooltip-description">
                        {t('scaleTooltip')}
                      </div>
                    </div>
                  }
                  className="impact-label"
                />
              </Link>

            </div>
          )}
        </div>
        <div className="sliding-tab-indicator" />
      </div>
      <div className="swapmodal">
        <div
          className={`inputbg ${connected &&
            ((amountIn > tokenBalances[tokenIn]) ||
              (amountIn != BigInt(0) &&
                (tokenIn == activeMarket.quoteAddress
                  ? amountIn < activeMarket.minSize
                  : (amountIn * limitPrice) / activeMarket.scaleFactor <
                  activeMarket.minSize))) && !txPending.current
            ? 'exceed-balance'
            : ''
            }`}
        >
          <div className="Pay">{t('pay')}</div>
          <div className="inputbutton1container">
            <input
              inputMode="decimal"
              className={`input ${connected &&
                ((amountIn > tokenBalances[tokenIn]) ||
                  (amountIn !== BigInt(0) &&
                    (tokenIn === activeMarket.quoteAddress
                      ? amountIn < activeMarket.minSize
                      : (amountIn * limitPrice) / activeMarket.scaleFactor <
                      activeMarket.minSize))) && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onCompositionStart={() => {
                setIsComposing(true);
              }}
              onCompositionEnd={(
                e: React.CompositionEvent<HTMLInputElement>,
              ) => {
                setIsComposing(false);
                if (/^\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                  setInputString(e.currentTarget.value);
                  if (
                    (inputString.endsWith('.') && e.currentTarget.value === inputString.slice(0, -1)) ||
                    (e.currentTarget.value.endsWith('.') && e.currentTarget.value.slice(0, -1) === inputString)
                  ) {
                    return;
                  }
                  const inputValue = BigInt(
                    Math.round(
                      (parseFloat(e.currentTarget.value || '0') || 0) *
                      10 ** Number(tokendict[tokenIn].decimals),
                    ),
                  );

                  setamountOutSwap(
                    limitPrice !== BigInt(0) && inputValue !== BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? (inputValue * limitPrice) /
                        (activeMarket.scaleFactor || BigInt(1))
                        : (inputValue *
                          (activeMarket.scaleFactor || BigInt(1))) /
                        limitPrice
                      : BigInt(0),
                  );

                  setoutputString(
                    (limitPrice !== BigInt(0) && inputValue !== BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? customRound(
                          Number(
                            (inputValue * limitPrice) /
                            (activeMarket.scaleFactor || BigInt(1)),
                          ) /
                          10 ** Number(tokendict[tokenOut].decimals),
                          3,
                        )
                        : customRound(
                          Number(
                            (inputValue *
                              (activeMarket.scaleFactor || BigInt(1))) /
                            limitPrice,
                          ) /
                          10 ** Number(tokendict[tokenOut].decimals),
                          3,
                        )
                      : ''
                    ).toString(),
                  );

                  debouncedSetAmount(inputValue);
                  setswitched(false);

                  const percentage = !tokenBalances[tokenIn]
                    ? 0
                    : Math.min(
                      100,
                      Math.floor(
                        Number(
                          (inputValue * BigInt(100)) / tokenBalances[tokenIn],
                        ),
                      ),
                    );
                  setSliderPercent(percentage);

                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    (popup as HTMLElement).style.left =
                      `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                  }
                }
              }}
              onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                if (isComposing) {
                  setInputString(e.target.value);
                  return;
                }

                if (/^\d*\.?\d{0,18}$/.test(e.target.value)) {
                  setInputString(e.target.value);
                  if (
                    (inputString.endsWith('.') && e.target.value === inputString.slice(0, -1)) ||
                    (e.target.value.endsWith('.') && e.target.value.slice(0, -1) === inputString)
                  ) {
                    return;
                  }
                  const inputValue = BigInt(
                    Math.round(
                      (parseFloat(e.target.value || '0') || 0) *
                      10 ** Number(tokendict[tokenIn].decimals),
                    ),
                  );

                  setamountOutSwap(
                    limitPrice !== BigInt(0) && inputValue !== BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? (inputValue * limitPrice) /
                        (activeMarket.scaleFactor || BigInt(1))
                        : (inputValue *
                          (activeMarket.scaleFactor || BigInt(1))) /
                        limitPrice
                      : BigInt(0),
                  );

                  setoutputString(
                    (limitPrice !== BigInt(0) && inputValue !== BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? customRound(
                          Number(
                            (inputValue * limitPrice) /
                            (activeMarket.scaleFactor || BigInt(1)),
                          ) /
                          10 ** Number(tokendict[tokenOut].decimals),
                          3,
                        )
                        : customRound(
                          Number(
                            (inputValue *
                              (activeMarket.scaleFactor || BigInt(1))) /
                            limitPrice,
                          ) /
                          10 ** Number(tokendict[tokenOut].decimals),
                          3,
                        )
                      : ''
                    ).toString(),
                  );

                  debouncedSetAmount(inputValue);
                  setswitched(false);

                  const percentage = !tokenBalances[tokenIn]
                    ? 0
                    : Math.min(
                      100,
                      Math.floor(
                        Number(
                          (inputValue * BigInt(100)) / tokenBalances[tokenIn],
                        ),
                      ),
                    );
                  setSliderPercent(percentage);

                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    (popup as HTMLElement).style.left =
                      `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                  }
                }
              }}
              placeholder="0.00"
              value={inputString}
              autoFocus={!(windowWidth <= 1020)}
            />
            <button
              className={`button1 ${connected &&
                ((amountIn > tokenBalances[tokenIn]) ||
                  (amountIn != BigInt(0) &&
                    (tokenIn == activeMarket.quoteAddress
                      ? amountIn < activeMarket.minSize
                      : (amountIn * limitPrice) / activeMarket.scaleFactor <
                      activeMarket.minSize))) && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onClick={() => {
                setpopup(1);
              }}
            >
              <img className="button1pic" src={tokendict[tokenIn].image} />
              <span>{tokendict[tokenIn].ticker || '?'}</span>
              <svg
                className={`button-arrow ${popup == 1 ? 'open' : ''}`}
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                width="16"
                height="16"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </button>
          </div>
          <div className="balance1maxcontainer">
            <span className="usd-value">
              {Math.round(
                (parseFloat(inputString || '0') || 0) *
                10 ** Number(tokendict[tokenIn].decimals),
              ) == 0
                ? '$0.00'
                : formatUSDDisplay(
                  calculateUSDValue(
                    BigInt(
                      Math.round(
                        (parseFloat(inputString || '0') || 0) *
                        10 ** Number(tokendict[tokenIn].decimals),
                      ),
                    ),
                    tradesByMarket[
                    (({ baseAsset, quoteAsset }) =>
                      (baseAsset === wethticker ? ethticker : baseAsset) +
                      (quoteAsset === wethticker ? ethticker : quoteAsset)
                    )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                    ],
                    tokenIn,
                    getMarket(
                      activeMarket.path.at(0),
                      activeMarket.path.at(1),
                    ),
                  ),
                )}
            </span>
            <div className="balance1">
              <img src={walleticon} className="balance-wallet-icon" />{' '}
              {formatSubscript(formatDisplayValue(
                tokenBalances[tokenIn],
                Number(tokendict[tokenIn].decimals),
              ))}
            </div>
            <div
              className="max-button"
              onClick={() => {
                if (tokenBalances[tokenIn] != BigInt(0)) {
                  let amount =
                    (tokenIn == eth && !client)
                      ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount >
                        BigInt(0)
                        ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount
                        : BigInt(0)
                      : tokenBalances[tokenIn];
                  setamountIn(BigInt(amount));
                  setswitched(false);
                  setInputString(
                    customRound(
                      Number(amount) /
                      10 ** Number(tokendict[tokenIn].decimals),
                      3,
                    ).toString(),
                  );
                  setamountOutSwap(
                    limitPrice != BigInt(0) && amount != BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? (amount * limitPrice) /
                        (activeMarket.scaleFactor || BigInt(1))
                        : (BigInt(amount) *
                          (activeMarket.scaleFactor || BigInt(1))) /
                        limitPrice
                      : BigInt(0),
                  );
                  setoutputString(
                    (limitPrice != BigInt(0) && amount != BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? customRound(
                          Number(
                            (amount * limitPrice) /
                            (activeMarket.scaleFactor || BigInt(1)),
                          ) /
                          10 ** Number(tokendict[tokenOut].decimals),
                          3,
                        )
                        : customRound(
                          Number(
                            (BigInt(amount) *
                              (activeMarket.scaleFactor || BigInt(1))) /
                            limitPrice,
                          ) /
                          10 ** Number(tokendict[tokenOut].decimals),
                          3,
                        )
                      : ''
                    ).toString(),
                  );
                  setSliderPercent(100);
                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    const trackWidth = rect.width - 15;
                    const thumbPosition = trackWidth + 15 / 2;
                    (popup as HTMLElement).style.left = `${thumbPosition}px`;
                  }
                }
              }}
            >
              {t('max')}{' '}
            </div>
          </div>
        </div>
        <div
          className="switch-button"
          onClick={() => {
            setTokenIn(tokenOut);
            setTokenOut(tokenIn);
            setswitched((switched) => { return !switched });
            if (amountIn != BigInt(0)) {
              if (limitChase && mids?.[activeMarketKey]?.[0]) {
                const price = tokenOut === activeMarket?.baseAddress ? mids[activeMarketKey][0] == mids[activeMarketKey][1] ? mids[activeMarketKey][2] : mids[activeMarketKey][0] : mids[activeMarketKey][0] == mids[activeMarketKey][2] ? mids[activeMarketKey][1] : mids[activeMarketKey][0]
                setlimitPrice(price);
                setlimitPriceString(
                  (
                    Number(price) / Number(activeMarket.priceFactor)
                  ).toFixed(Math.floor(Math.log10(activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10((Number(price) / Number(activeMarket.priceFactor)) || 1)) - 1) : Number(activeMarket.priceFactor)))),
                );
                setamountOutSwap(
                  price != BigInt(0) && amountIn != BigInt(0)
                    ? tokenOut === activeMarket?.baseAddress
                      ? (amountIn * price) /
                      (activeMarket.scaleFactor || BigInt(1))
                      : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                      price
                    : BigInt(0),
                );
                setoutputString(
                  (price != BigInt(0) && amountIn != BigInt(0)
                    ? tokenOut === activeMarket?.baseAddress
                      ? customRound(
                        Number(
                          (amountIn * price) /
                          (activeMarket.scaleFactor || BigInt(1)),
                        ) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      )
                      : customRound(
                        Number(
                          (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                          price,
                        ) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      )
                    : ''
                  ).toString(),
                );
              }
              setInputString(outputString);
              setoutputString(inputString);
              setamountIn(amountOutSwap);
              setamountOutSwap(amountIn);
              const percentage = !tokenBalances[tokenOut]
                ? 0
                : Math.min(
                  100,
                  Math.floor(
                    Number(
                      (amountOutSwap * BigInt(100)) /
                      tokenBalances[tokenOut],
                    ),
                  ),
                );
              setSliderPercent(percentage);
              const slider = document.querySelector('.balance-amount-slider');
              const popup = document.querySelector('.slider-percentage-popup');
              if (slider && popup) {
                const rect = slider.getBoundingClientRect();
                (popup as HTMLElement).style.left =
                  `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
              }
            }
          }}
        >
          <img src={tradearrow} className="switch-arrow" />
        </div>
        <div className="swap-container-divider" />
        <div className="outputbg">
          <div className="Recieve">{t('receive')}</div>
          <div className="outputbutton2container">
            <>
              <input
                inputMode="decimal"
                className="output"
                onCompositionStart={() => {
                  setIsComposing(true);
                }}
                onCompositionEnd={(
                  e: React.CompositionEvent<HTMLInputElement>,
                ) => {
                  setIsComposing(false);
                  if (/^\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                    setoutputString(e.currentTarget.value);
                    const outputValue = BigInt(
                      Math.round(
                        (parseFloat(e.currentTarget.value || '0') || 0) *
                        10 ** Number(tokendict[tokenOut].decimals),
                      ),
                    );
                    setamountOutSwap(outputValue);
                    setswitched(true);
                    setamountIn(
                      limitPrice !== BigInt(0) && outputValue !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (outputValue *
                            (activeMarket.scaleFactor || BigInt(1))) /
                          limitPrice
                          : (outputValue * limitPrice) /
                          (activeMarket.scaleFactor || BigInt(1))
                        : BigInt(0),
                    );
                    setInputString(
                      (limitPrice !== BigInt(0) && outputValue !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number(
                              (outputValue *
                                (activeMarket.scaleFactor || BigInt(1))) /
                              limitPrice,
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                          : customRound(
                            Number(
                              (outputValue * limitPrice) /
                              (activeMarket.scaleFactor || BigInt(1)),
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                    const percentage =
                      tokenBalances[tokenIn] === BigInt(0)
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (limitPrice !== BigInt(0) &&
                                outputValue !== BigInt(0)
                                ? tokenIn === activeMarket?.baseAddress
                                  ? (outputValue *
                                    (activeMarket.scaleFactor ||
                                      BigInt(1))) /
                                  limitPrice
                                  : (outputValue * limitPrice) /
                                  (activeMarket.scaleFactor || BigInt(1))
                                : BigInt(0)) * BigInt(100),
                            ) / tokenBalances[tokenIn],
                          ),
                        );
                    setSliderPercent(percentage);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                }}
                onChange={(e) => {
                  if (isComposing) {
                    setoutputString(e.target.value);
                    return;
                  }
                  if (/^\d*\.?\d{0,18}$/.test(e.target.value)) {
                    setoutputString(e.target.value);
                    const outputValue = BigInt(
                      Math.round(
                        (parseFloat(e.target.value || '0') || 0) *
                        10 ** Number(tokendict[tokenOut].decimals),
                      ),
                    );
                    setamountOutSwap(outputValue);
                    setswitched(true);
                    setamountIn(
                      limitPrice !== BigInt(0) && outputValue !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (outputValue *
                            (activeMarket.scaleFactor || BigInt(1))) /
                          limitPrice
                          : (outputValue * limitPrice) /
                          (activeMarket.scaleFactor || BigInt(1))
                        : BigInt(0),
                    );
                    setInputString(
                      (limitPrice !== BigInt(0) && outputValue !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number(
                              (outputValue *
                                (activeMarket.scaleFactor || BigInt(1))) /
                              limitPrice,
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                          : customRound(
                            Number(
                              (outputValue * limitPrice) /
                              (activeMarket.scaleFactor || BigInt(1)),
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                    const percentage =
                      tokenBalances[tokenIn] === BigInt(0)
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (limitPrice !== BigInt(0) &&
                                outputValue !== BigInt(0)
                                ? tokenIn === activeMarket?.baseAddress
                                  ? (outputValue *
                                    (activeMarket.scaleFactor ||
                                      BigInt(1))) /
                                  limitPrice
                                  : (outputValue * limitPrice) /
                                  (activeMarket.scaleFactor || BigInt(1))
                                : BigInt(0)) * BigInt(100) / tokenBalances[tokenIn]
                            )
                          ),
                        );
                    setSliderPercent(percentage);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                }}
                value={outputString}
                placeholder="0.00"
              />
              <button
                className="button2"
                onClick={() => {
                  setpopup(2);
                }}
              >
                <img className="button2pic" src={tokendict[tokenOut].image} />
                <span>{tokendict[tokenOut].ticker || '?'}</span>
                <svg
                  className={`button-arrow ${popup == 2 ? 'open' : ''}`}
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  width="16"
                  height="16"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
              </button>
            </>
          </div>
          <div className="balance1maxcontainer">
            <div className="output-usd-value">
              {amountOutSwap === BigInt(0)
                ? '$0.00'
                : (() => {
                  const outputUSD = calculateUSDValue(
                    amountOutSwap,
                    tradesByMarket[
                    (({ baseAsset, quoteAsset }) =>
                      (baseAsset === wethticker ? ethticker : baseAsset) +
                      (quoteAsset === wethticker ? ethticker : quoteAsset)
                    )(getMarket(activeMarket.path.at(-2), activeMarket.path.at(-1)))
                    ],
                    tokenOut,
                    getMarket(
                      activeMarket.path.at(-2),
                      activeMarket.path.at(-1),
                    ),
                  );

                  const inputUSD = calculateUSDValue(
                    limitPrice != BigInt(0) && amountOutSwap != BigInt(0)
                      ? tokenIn === activeMarket?.baseAddress
                        ? (amountOutSwap *
                          (activeMarket.scaleFactor || BigInt(1))) /
                        limitPrice
                        : (amountOutSwap * limitPrice) /
                        (activeMarket.scaleFactor || BigInt(1))
                      : BigInt(0),
                    tradesByMarket[
                    (({ baseAsset, quoteAsset }) =>
                      (baseAsset === wethticker ? ethticker : baseAsset) +
                      (quoteAsset === wethticker ? ethticker : quoteAsset)
                    )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                    ],
                    tokenIn,
                    getMarket(
                      activeMarket.path.at(0),
                      activeMarket.path.at(1),
                    ),
                  );

                  const percentageDiff =
                    inputUSD > 0
                      ? ((outputUSD - inputUSD) / inputUSD) * 100
                      : 0;

                  return (
                    <div className="output-usd-container">
                      <span>{formatUSDDisplay(outputUSD)}</span>
                      {inputUSD > 0 && (
                        <span
                          className={`output-percentage ${percentageDiff >= 0 ? 'positive' : 'negative'}`}
                        >
                          ({percentageDiff >= 0 ? '+' : ''}
                          {percentageDiff.toFixed(2)}%)
                        </span>
                      )}
                    </div>
                  );
                })()}
            </div>
            <div className="balance2">
              <img src={walleticon} className="balance-wallet-icon" />{' '}
              {formatSubscript(formatDisplayValue(
                tokenBalances[tokenOut],
                Number(tokendict[tokenOut].decimals),
              ))}
            </div>
          </div>
        </div>
        <div className="swap-container-divider" />
        <div
          className={`limitbg ${connected &&
            !(
              amountIn > tokenBalances[tokenIn]) &&
            addliquidityonly &&
            amountIn != BigInt(0) &&
            ((limitPrice >= lowestAsk &&
              tokenIn == activeMarket.quoteAddress) ||
              (limitPrice <= highestBid &&
                tokenIn == activeMarket.baseAddress)) &&
            !(tokenIn == activeMarket.quoteAddress
              ? amountIn < activeMarket.minSize
              : (amountIn * limitPrice) / activeMarket.scaleFactor <
              activeMarket.minSize) && !txPending.current
            ? 'exceed-balance'
            : ''
            }`}
        >
          <div className="limit-label">
            <span>{t('When')}</span>
            <button
              className="limit-token-button"
              onClick={() => {
                tokenIn == activeMarket?.quoteAddress
                  ? setpopup(2)
                  : setpopup(1);
              }}
            >
              <img
                className="limit-token-icon"
                src={tokendict[activeMarket?.baseAddress].image}
              />
              <span>{tokendict[activeMarket?.baseAddress].ticker || '?'}</span>
            </button>
            <span>{t('isWorth')}</span>
            <button
              className="use-market-button"
              onClick={() => {
                setlimitChase(true);
              }}
            >
              {t('useMarket')}
            </button>
          </div>
          <div className="limitpricecontainer">
            <input
              inputMode="decimal"
              className={`limit-order ${connected &&
                !(
                  amountIn > tokenBalances[tokenIn]) &&
                addliquidityonly &&
                amountIn != BigInt(0) &&
                ((limitPrice >= lowestAsk &&
                  tokenIn == activeMarket.quoteAddress) ||
                  (limitPrice <= highestBid &&
                    tokenIn == activeMarket.baseAddress)) &&
                !(tokenIn == activeMarket.quoteAddress
                  ? amountIn < activeMarket.minSize
                  : (amountIn * limitPrice) / activeMarket.scaleFactor <
                  activeMarket.minSize) && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onFocus={() => setLimitIsEditing(true)}
              onBlur={() => setLimitIsEditing(false)}
              onCompositionStart={() => {
                setIsComposing(true);
              }}
              onCompositionEnd={(
                e: React.CompositionEvent<HTMLInputElement>,
              ) => {
                setIsComposing(false);
                if (
                  new RegExp(
                    `^\\d*\\.?\\d{0,${Math.floor(Math.log10(Number(activeMarket.priceFactor)))}}$`
                  ).test(e.currentTarget.value) && (activeMarket?.marketType != 0 ? e.currentTarget.value.replace(/^0+|\.|e.*$/gi, '').replace(/^0+/, '').replace(/0+$/, match => '').length <= 5 : true)
                ) {
                  setlimitChase(false);
                  setlimitPriceString(e.currentTarget.value);
                  let price = BigInt(
                    Math.round(
                      (parseFloat(e.currentTarget.value || '0') || 0) *
                      Number(activeMarket.priceFactor)
                    )
                  );
                  setlimitPrice(price);
                  if (switched) {
                    setamountIn(
                      price !== BigInt(0) && amountOutSwap !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (amountOutSwap *
                            (activeMarket.scaleFactor || BigInt(1))) /
                          price
                          : (amountOutSwap * price) /
                          (activeMarket.scaleFactor || BigInt(1))
                        : BigInt(0),
                    );
                    setInputString(
                      (price !== BigInt(0) && amountOutSwap !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number(
                              (amountOutSwap *
                                (activeMarket.scaleFactor || BigInt(1))) /
                              price,
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                          : customRound(
                            Number(
                              (amountOutSwap * price) /
                              (activeMarket.scaleFactor || BigInt(1)),
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                    const percentage =
                      tokenBalances[tokenIn] === BigInt(0)
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (price !== BigInt(0) &&
                                amountOutSwap !== BigInt(0)
                                ? tokenIn === activeMarket?.baseAddress
                                  ? (amountOutSwap *
                                    (activeMarket.scaleFactor ||
                                      BigInt(1))) /
                                  price
                                  : (amountOutSwap * price) /
                                  (activeMarket.scaleFactor || BigInt(1))
                                : BigInt(0)) * BigInt(100) / tokenBalances[tokenIn]
                            )
                          ),
                        );
                    setSliderPercent(percentage);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                  else {
                    setamountOutSwap(
                      price != BigInt(0) && amountIn != BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (amountIn * price) /
                          (activeMarket.scaleFactor || BigInt(1))
                          : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                          price
                        : BigInt(0)
                    );
                    setoutputString(
                      (
                        price != BigInt(0) && amountIn != BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number(
                                (amountIn * price) /
                                (activeMarket.scaleFactor || BigInt(1))
                              ) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3
                            )
                            : customRound(
                              Number(
                                (amountIn *
                                  (activeMarket.scaleFactor || BigInt(1))) /
                                price
                              ) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3
                            )
                          : ''
                      ).toString()
                    );
                  }
                }
              }}
              onChange={(e) => {
                if (isComposing) {
                  setlimitPriceString(e.target.value);
                  return;
                }
                if (
                  new RegExp(
                    `^\\d*\\.?\\d{0,${Math.floor(Math.log10(Number(activeMarket.priceFactor)))}}$`
                  ).test(e.target.value) && (activeMarket?.marketType != 0 ? e.target.value.replace(/^0+|\.|e.*$/gi, '').replace(/^0+/, '').replace(/0+$/, match => '').length <= 5 : true)
                ) {
                  setlimitChase(false);
                  setlimitPriceString(e.target.value);
                  let price = BigInt(
                    Math.round(
                      (parseFloat(e.target.value || '0') || 0) *
                      Number(activeMarket.priceFactor)
                    )
                  );
                  setlimitPrice(price);
                  if (switched) {
                    setamountIn(
                      price !== BigInt(0) && amountOutSwap !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (amountOutSwap *
                            (activeMarket.scaleFactor || BigInt(1))) /
                          price
                          : (amountOutSwap * price) /
                          (activeMarket.scaleFactor || BigInt(1))
                        : BigInt(0),
                    );
                    setInputString(
                      (price !== BigInt(0) && amountOutSwap !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number(
                              (amountOutSwap *
                                (activeMarket.scaleFactor || BigInt(1))) /
                              price,
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                          : customRound(
                            Number(
                              (amountOutSwap * price) /
                              (activeMarket.scaleFactor || BigInt(1)),
                            ) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                    const percentage =
                      tokenBalances[tokenIn] === BigInt(0)
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (price !== BigInt(0) &&
                                amountOutSwap !== BigInt(0)
                                ? tokenIn === activeMarket?.baseAddress
                                  ? (amountOutSwap *
                                    (activeMarket.scaleFactor ||
                                      BigInt(1))) /
                                  price
                                  : (amountOutSwap * price) /
                                  (activeMarket.scaleFactor || BigInt(1))
                                : BigInt(0)) * BigInt(100) / tokenBalances[tokenIn]
                            )
                          ),
                        );
                    setSliderPercent(percentage);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                  else {
                    setamountOutSwap(
                      price != BigInt(0) && amountIn != BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (amountIn * price) /
                          (activeMarket.scaleFactor || BigInt(1))
                          : (amountIn * (activeMarket.scaleFactor || BigInt(1))) /
                          price
                        : BigInt(0)
                    );
                    setoutputString(
                      (
                        price != BigInt(0) && amountIn != BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number(
                                (amountIn * price) /
                                (activeMarket.scaleFactor || BigInt(1))
                              ) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3
                            )
                            : customRound(
                              Number(
                                (amountIn *
                                  (activeMarket.scaleFactor || BigInt(1))) /
                                price
                              ) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3
                            )
                          : ''
                      ).toString()
                    );
                  }
                }
              }}
              placeholder="0.00"
              value={limitPriceString}
              step={1 / Math.pow(10, Math.floor(Math.log10(Number(activeMarket.priceFactor))))}
            />
            <span className="limit-order-usd-label">{activeMarket.quoteAsset}</span>
          </div>
          <div className="limit-price-buttons">
            <button
              className="limit-price-button limit-custom-button"
              onClick={() => {
                const customButton = document.querySelector('.limit-custom-button');
                if (customButton) {
                  customButton.classList.add('editing');
                }

                setTimeout(() => {
                  const input = document.querySelector('.limit-custom-input') as HTMLInputElement | null;
                  if (input) {
                    input.value = '';
                    input.focus();
                  }
                }, 10);
              }}
            >
              <span className="limit-custom-label">
                {(() => {
                  const marketPrice = Number(tokenIn === activeMarket?.baseAddress ? mids[activeMarketKey]?.[0] == mids[activeMarketKey]?.[1] ? mids[activeMarketKey]?.[2] : mids[activeMarketKey]?.[0] : mids[activeMarketKey]?.[0] == mids[activeMarketKey]?.[2] ? mids[activeMarketKey]?.[1] : mids[activeMarketKey]?.[0])

                  if (marketPrice > 0 && limitPrice > 0) {
                    const percentDiff = ((Number(limitPrice) - marketPrice) / marketPrice) * 100;
                    if (Math.abs(percentDiff) < 0.01) {
                      return t('custom');
                    }

                    return (percentDiff >= 0 ? "+" : "") + percentDiff.toFixed(1) + "%";
                  }

                  return t('custom');
                })()}
              </span>
              <div className="custom-input-container">
                <input
                  className="limit-custom-input"
                  type="text"
                  inputMode="decimal"
                  placeholder={tokenIn === activeMarket?.quoteAddress ? "-%" : "+%"}
                  onBlur={(e) => {
                    const customButton = document.querySelector('.limit-custom-button');
                    if (customButton) {
                      customButton.classList.remove('editing');
                    }

                    let value = e.target.value.replace(/[^0-9.]/g, '');

                    let numValue = parseFloat(value);
                    if (isNaN(numValue)) numValue = 0;
                    if (numValue > 100) {
                      value = "100";
                      numValue = 100;
                    }

                    if (value) {
                      const marketPrice = tokenIn === activeMarket?.baseAddress
                        ? Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor)
                        : Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor);

                      let newPrice;
                      if (tokenIn === activeMarket?.quoteAddress) {
                        newPrice = marketPrice * (1 - numValue / 100);
                      } else {
                        newPrice = marketPrice * (1 + numValue / 100);
                      }

                      updateLimitAmount(newPrice, Number(activeMarket.priceFactor), activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(newPrice ?? 1)) - 1) : Number(activeMarket.priceFactor));
                    }
                  }}
                  onFocus={(e) => {
                    const value = e.target.value.replace(/[^0-9.]/g, '');
                    e.target.value = value;
                  }}
                  onKeyDown={(e) => {
                    if (e.key === 'Enter') {
                      const input = e.target as HTMLInputElement;
                      input.blur();
                    } else if (e.key === 'Escape') {
                      const customButton = document.querySelector('.limit-custom-button');
                      if (customButton) {
                        customButton.classList.remove('editing');
                      }
                    }
                    if ([46, 8, 9, 27, 13, 110, 190].indexOf(e.keyCode) !== -1 ||
                      (e.keyCode === 65 && e.ctrlKey === true) ||
                      (e.keyCode === 67 && e.ctrlKey === true) ||
                      (e.keyCode === 86 && e.ctrlKey === true) ||
                      (e.keyCode === 88 && e.ctrlKey === true) ||
                      (e.keyCode >= 35 && e.keyCode <= 39)) {
                      return;
                    }

                    if ((e.shiftKey || (e.keyCode < 48 || e.keyCode > 57)) &&
                      (e.keyCode < 96 || e.keyCode > 105)) {
                      e.preventDefault();
                    }
                  }}
                  onChange={(e) => {
                    let value = e.target.value.replace(/[^0-9.]/g, '');

                    const numValue = parseFloat(value);
                    if (!isNaN(numValue) && numValue > 100) {
                      value = "100";
                    }

                    const sign = tokenIn === activeMarket?.quoteAddress ? "-" : "+";

                    if (value && value !== "0") {
                      e.target.value = sign + value;
                    } else {
                      e.target.value = value;
                    }
                  }}
                  onClick={(e) => e.stopPropagation()}
                />
              </div>
            </button>
            <button
              className="limit-price-button"
              onClick={() => {
                const marketPrice = tokenIn === activeMarket?.baseAddress
                  ? Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor)
                  : Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor);

                const newPrice = tokenIn === activeMarket?.quoteAddress
                  ? Math.max(0, marketPrice * 0.99)
                  : marketPrice * 1.01;

                updateLimitAmount(newPrice, Number(activeMarket.priceFactor), activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(newPrice ?? 1)) - 1) : Number(activeMarket.priceFactor));
              }}
            >
              {tokenIn === activeMarket?.quoteAddress ? "-1%" : "+1%"}
            </button>
            <button
              className="limit-price-button"
              onClick={() => {
                const marketPrice = tokenIn === activeMarket?.baseAddress
                  ? Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor)
                  : Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor);
                const newPrice = tokenIn === activeMarket?.quoteAddress
                  ? Math.max(0, marketPrice * 0.95)
                  : marketPrice * 1.05;

                updateLimitAmount(newPrice, Number(activeMarket.priceFactor), activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(newPrice ?? 1)) - 1) : Number(activeMarket.priceFactor));
              }}
            >
              {tokenIn === activeMarket?.quoteAddress ? "-5%" : "+5%"}
            </button>
            <button
              className="limit-price-button"
              onClick={() => {
                const marketPrice = tokenIn === activeMarket?.baseAddress
                  ? Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor)
                  : Number(mids[activeMarketKey]?.[0]) / Number(activeMarket.priceFactor);

                const newPrice = tokenIn === activeMarket?.quoteAddress
                  ? Math.max(0, marketPrice * 0.9)
                  : marketPrice * 1.1;

                updateLimitAmount(newPrice, Number(activeMarket.priceFactor), activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(newPrice ?? 1)) - 1) : Number(activeMarket.priceFactor));
              }}
            >
              {tokenIn === activeMarket?.quoteAddress ? "-10%" : "+10%"}
            </button>
          </div>
        </div>
        <div className="balance-slider-wrapper">
          {spotSliderMode === 'presets' ? (
            <div className="slider-container presets-mode">
              <div className="preset-buttons">
                {spotSliderPresets.map((preset: number, index: number) => (
                  <button
                    key={index}
                    className={`preset-button ${sliderPercent === preset ? 'active' : ''}`}
                    onClick={() => {
                      if (connected) {
                        const newAmount =
                          (((tokenIn == eth && !client)
                            ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount >
                              BigInt(0)
                              ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount
                              : BigInt(0)
                            : tokenBalances[tokenIn]) *
                            BigInt(preset)) /
                          100n;
                        setSliderPercent(preset);
                        setInputString(
                          newAmount == BigInt(0)
                            ? ''
                            : customRound(
                              Number(newAmount) /
                              10 ** Number(tokendict[tokenIn].decimals),
                              3,
                            ).toString(),
                        );
                        debouncedSetAmount(newAmount);
                        setswitched(false);
                        if (isWrap) {
                          setoutputString(
                            newAmount == BigInt(0)
                              ? ''
                              : customRound(
                                Number(newAmount) /
                                10 ** Number(tokendict[tokenIn].decimals),
                                3,
                              ).toString(),
                          );
                          setamountOutSwap(newAmount);
                        }
                        if (location.pathname.slice(1) === 'limit') {
                          setamountOutSwap(
                            limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                                : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                              : BigInt(0),
                          );
                          setoutputString(
                            (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? customRound(
                                  Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                                : customRound(
                                  Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        const slider = document.querySelector('.balance-amount-slider');
                        const popup = document.querySelector('.slider-percentage-popup');
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left = `${(rect.width - 15) * (preset / 100) + 15 / 2}px`;
                        }
                      }
                    }}
                    disabled={!connected}
                  >
                    {preset}%
                  </button>
                ))}
              </div>
            </div>
          ) : spotSliderMode === 'increment' ? (
            <div className="slider-container increment-mode">
              <button
                className="increment-button minus"
                onClick={() => {
                  if (connected && sliderPercent > 0) {
                    const newPercent = Math.max(0, sliderPercent - spotSliderIncrement);
                    const newAmount =
                      (((tokenIn == eth && !client)
                        ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : tokenBalances[tokenIn]) *
                        BigInt(newPercent)) /
                      100n;
                    setSliderPercent(newPercent);
                    setInputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    debouncedSetAmount(newAmount);
                    setswitched(false);
                    if (isWrap) {
                      setoutputString(
                        newAmount == BigInt(0)
                          ? ''
                          : customRound(
                            Number(newAmount) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          ).toString(),
                      );
                      setamountOutSwap(newAmount);
                    }
                    if (location.pathname.slice(1) === 'limit') {
                      setamountOutSwap(
                        limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                            : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                          : BigInt(0),
                      );
                      setoutputString(
                        (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                            : customRound(
                              Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                          : ''
                        ).toString(),
                      );
                    }
                    const slider = document.querySelector('.balance-amount-slider');
                    const popup = document.querySelector('.slider-percentage-popup');
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (newPercent / 100) + 15 / 2}px`;
                    }
                  }
                }}
                disabled={!connected || sliderPercent === 0}
              >
                
              </button>
              <div className="increment-display">
                <div className="increment-amount">{spotSliderIncrement}%</div>
              </div>
              <button
                className="increment-button plus"
                onClick={() => {
                  if (connected && sliderPercent < 100) {
                    const newPercent = Math.min(100, sliderPercent + spotSliderIncrement);
                    const newAmount =
                      (((tokenIn == eth && !client)
                        ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : tokenBalances[tokenIn]) *
                        BigInt(newPercent)) /
                      100n;
                    setSliderPercent(newPercent);
                    setInputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    debouncedSetAmount(newAmount);
                    setswitched(false);
                    if (isWrap) {
                      setoutputString(
                        newAmount == BigInt(0)
                          ? ''
                          : customRound(
                            Number(newAmount) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          ).toString(),
                      );
                      setamountOutSwap(newAmount);
                    }
                    if (location.pathname.slice(1) === 'limit') {
                      setamountOutSwap(
                        limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                            : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                          : BigInt(0),
                      );
                      setoutputString(
                        (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                            : customRound(
                              Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                          : ''
                        ).toString(),
                      );
                    }
                    const slider = document.querySelector('.balance-amount-slider');
                    const popup = document.querySelector('.slider-percentage-popup');
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (newPercent / 100) + 15 / 2}px`;
                    }
                  }
                }}
                disabled={!connected || sliderPercent === 100}
              >
                +
              </button>
            </div>
          ) : (
            <div className="slider-container slider-mode">
              <input
                type="range"
                className={`balance-amount-slider ${isDragging ? 'dragging' : ''}`}
                min="0"
                max="100"
                step="1"
                value={sliderPercent}
                disabled={!connected}
                onChange={(e) => {
                  const percent = parseInt(e.target.value);
                  const newAmount =
                    (((tokenIn == eth && !client)
                      ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount >
                        BigInt(0)
                        ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount
                        : BigInt(0)
                      : tokenBalances[tokenIn]) *
                      BigInt(percent)) /
                    100n;
                  setSliderPercent(percent);
                  setInputString(
                    newAmount == BigInt(0)
                      ? ''
                      : customRound(
                        Number(newAmount) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      ).toString(),
                  );
                  debouncedSetAmount(newAmount);
                  setswitched(false);
                  if (isWrap) {
                    setoutputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    setamountOutSwap(newAmount);
                  }
                  if (location.pathname.slice(1) === 'limit') {
                    setamountOutSwap(
                      limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                          : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                        : BigInt(0),
                    );
                    setoutputString(
                      (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                            10 ** Number(tokendict[tokenOut].decimals),
                            3,
                          )
                          : customRound(
                            Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                            10 ** Number(tokendict[tokenOut].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                  }
                  const slider = e.target;
                  const rect = slider.getBoundingClientRect();
                  const trackWidth = rect.width - 15;
                  const thumbPosition = (percent / 100) * trackWidth + 15 / 2;
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) {
                    popup.style.left = `${thumbPosition}px`;
                  }
                }}
                onMouseDown={() => {
                  setIsDragging(true);
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) popup.classList.add('visible');
                }}
                onMouseUp={() => {
                  setIsDragging(false);
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) popup.classList.remove('visible');
                }}
                style={{
                  background: `linear-gradient(to right,rgb(171, 176, 224) ${sliderPercent}%,rgba(21, 21, 27, 1) ${sliderPercent}%)`,
                }}
              />
              <div className="slider-percentage-popup">{sliderPercent}%</div>
              <div className="balance-slider-marks">
                {[0, 25, 50, 75, 100].map((markPercent) => (
                  <span
                    key={markPercent}
                    className="balance-slider-mark"
                    data-active={sliderPercent >= markPercent}
                    data-percentage={markPercent}
                    onClick={() => {
                      if (connected) {
                        const newAmount =
                          (((tokenIn == eth && !client)
                            ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount >
                              BigInt(0)
                              ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount
                              : BigInt(0)
                            : tokenBalances[tokenIn]) *
                            BigInt(markPercent)) /
                          100n;
                        setSliderPercent(markPercent);
                        setInputString(
                          newAmount == BigInt(0)
                            ? ''
                            : customRound(
                              Number(newAmount) /
                              10 ** Number(tokendict[tokenIn].decimals),
                              3,
                            ).toString(),
                        );
                        debouncedSetAmount(newAmount);
                        setswitched(false);
                        if (isWrap) {
                          setoutputString(
                            newAmount == BigInt(0)
                              ? ''
                              : customRound(
                                Number(newAmount) /
                                10 ** Number(tokendict[tokenIn].decimals),
                                3,
                              ).toString(),
                          );
                          setamountOutSwap(newAmount);
                        }
                        if (location.pathname.slice(1) === 'limit') {
                          setamountOutSwap(
                            limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                                : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                              : BigInt(0),
                          );
                          setoutputString(
                            (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? customRound(
                                  Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                                : customRound(
                                  Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup: HTMLElement | null = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          popup.style.left = `${(rect.width - 15) * (markPercent / 100) + 15 / 2
                            }px`;
                        }
                      }
                    }}
                  >
                    {markPercent}%
                  </span>
                ))}
              </div>
            </div>
          )}
        </div>
        <button
          className={`limit-swap-button ${isSigning ? 'signing' : ''}`}
          onClick={async () => {
            if (connected && userchain === activechain) {
              let hash;
              setIsSigning(true)
              if (client) {
                txPending.current = true
              }
              try {
                if (tokenIn == eth) {
                  if (addliquidityonly) {
                    hash = await sendUserOperationAsync({
                      uo: limitOrder(
                        router,
                        amountIn,
                        eth,
                        tokenOut as `0x${string}`,
                        limitPrice,
                        amountIn,
                        BigInt(Math.floor(Date.now() / 1000) + 900),
                      )
                    })
                  } else {
                    hash = await sendUserOperationAsync({
                      uo: _swap(
                        router,
                        amountIn,
                        eth,
                        tokenOut as `0x${string}`,
                        true,
                        BigInt(2),
                        amountIn,
                        limitPrice,
                        BigInt(Math.floor(Date.now() / 1000) + 900),
                        usedRefAddress as `0x${string}`,
                      )
                    })
                  }
                } else {
                  if (allowance < amountIn) {
                    if (client) {
                      let uo = []
                      uo.push(approve(
                        tokenIn as `0x${string}`,
                        router,
                        maxUint256,
                      ))
                      if (addliquidityonly) {
                        uo.push(limitOrder(
                          router,
                          BigInt(0),
                          tokenIn as `0x${string}`,
                          tokenOut as `0x${string}`,
                          limitPrice,
                          amountIn,
                          BigInt(Math.floor(Date.now() / 1000) + 900),
                        ))
                      } else {
                        uo.push(_swap(
                          router,
                          BigInt(0),
                          tokenIn as `0x${string}`,
                          tokenOut as `0x${string}`,
                          true,
                          BigInt(2),
                          amountIn,
                          limitPrice,
                          BigInt(Math.floor(Date.now() / 1000) + 900),
                          usedRefAddress as `0x${string}`,
                        ))
                      }
                      hash = await sendUserOperationAsync({ uo: uo })
                      newTxPopup(
                        hash,
                        'approve',
                        tokenIn,
                        '',
                        customRound(
                          Number(amountIn) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ),
                        0,
                        '',
                        router,
                      );
                    }
                    else {
                      hash = await sendUserOperationAsync({
                        uo: approve(
                          tokenIn as `0x${string}`,
                          router,
                          maxUint256,
                        )
                      })
                      newTxPopup(
                        hash,
                        'approve',
                        tokenIn,
                        '',
                        customRound(
                          Number(amountIn) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ),
                        0,
                        '',
                        router,
                      );
                    }
                  }
                  if (!client || !(allowance < amountIn)) {
                    if (addliquidityonly) {
                      hash = await sendUserOperationAsync({
                        uo: limitOrder(
                          router,
                          BigInt(0),
                          tokenIn as `0x${string}`,
                          tokenOut as `0x${string}`,
                          limitPrice,
                          amountIn,
                          BigInt(Math.floor(Date.now() / 1000) + 900),
                        )
                      })
                    } else {
                      hash = await sendUserOperationAsync({
                        uo: _swap(
                          router,
                          BigInt(0),
                          tokenIn as `0x${string}`,
                          tokenOut as `0x${string}`,
                          true,
                          BigInt(2),
                          amountIn,
                          limitPrice,
                          BigInt(Math.floor(Date.now() / 1000) + 900),
                          usedRefAddress as `0x${string}`,
                        )
                      })
                    }
                  }
                }
                if (!client && hash) {
                  txPending.current = true
                }
                setInputString('');
                setamountIn(BigInt(0));
                setamountOutSwap(BigInt(0));
                setoutputString('');
                setLimitButtonDisabled(true);
                setLimitButton(0);
                setSliderPercent(0);
                setIsSigning(false)
                const slider = document.querySelector('.balance-amount-slider');
                const popup = document.querySelector('.slider-percentage-popup');
                if (slider && popup) {
                  (popup as HTMLElement).style.left = `${15 / 2}px`;
                }
                await refetch()
                txPending.current = false
              } catch (error) {
                console.log(error)
                if (!(error instanceof TransactionExecutionError)) {
                  newTxPopup(
                    hash,
                    "limitFailed",
                    tokenIn == eth ? eth : tokenIn,
                    tokenOut == eth ? eth : tokenOut,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn == eth ? eth : tokenIn].decimals), 3),
                    customRound(Number(amountOutSwap) / 10 ** Number(tokendict[tokenOut == eth ? eth : tokenOut].decimals), 3),
                    `${limitPrice / activeMarket.priceFactor} ${activeMarket.quoteAsset}`,
                    "",
                  );
                }
              } finally {
                txPending.current = false
                setIsSigning(false)
              }
            } else {
              !connected ? setpopup(4) : handleSetChain();
            }
          }}
          disabled={limitButtonDisabled || isSigning}
        >
          {isSigning ? (
            <div className="button-content">
              <div className="loading-spinner" />
              {validOneCT ? t('') : t('signTransaction')}
            </div>
          ) : limitButton == 0 ? (
            t('enterAmount')
          ) : limitButton == 1 ? (
            t('enterLimitPrice')
          ) : limitButton == 2 ? (
            t('priceOutOfRangeBuy')
          ) : limitButton == 3 ? (
            t('priceOutOfRangeSell')
          ) : limitButton == 4 ? (
            t('lessThanMinSize')
          ) : limitButton == 5 ? (
            (tokenIn == activeMarket.quoteAddress ? t('buy') : t('sell')) + ' ' + activeMarket.baseAsset
          ) : limitButton == 6 ? (
            t('insufficient') +
            (tokendict[tokenIn].ticker || '?') +
            ' ' +
            t('bal')
          ) : limitButton == 7 ? (
            `${t('switchto')} ${t(settings.chainConfig[activechain].name)}`
          ) : limitButton == 8 ? (
            t('connectWallet')
          ) : (
            client ? (tokenIn == activeMarket.quoteAddress ? t('buy') : t('sell')) + ' ' + activeMarket.baseAsset : t('approve')
          )}
        </button>
      </div>
      <div className="limit-info-rectangle">
        <div className="trade-fee">
          <div className="label-container">
            <TooltipLabel
              label={t('addLiquidityOnly')}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {t('addLiquidityOnlySubtitle')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <ToggleSwitch
            checked={addliquidityonly}
            onChange={() => {
              const newValue = !addliquidityonly;
              setAddLiquidityOnly(newValue);
              localStorage.setItem(
                'crystal_add_liquidity_only',
                JSON.stringify(newValue),
              );
            }}
          />
        </div>
        <div className="trade-fee">
          <div className="label-container">
            <TooltipLabel
              label={`${t('fee')} (0.00%)`}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {t('makerfeeexplanation')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <div className="value-container">
            {`${0} ${tokendict[tokenIn].ticker}`}
          </div>
        </div>

        {!addliquidityonly && !limitChase &&
          limitPrice != BigInt(0) &&
          ((limitPrice >= lowestAsk && tokenIn == activeMarket.quoteAddress) ||
            (limitPrice <= highestBid &&
              tokenIn == activeMarket.baseAddress)) &&
          amountIn != BigInt(0) && (
            <div className="limit-impact-warning">
              {tokenIn == activeMarket.quoteAddress
                ? t('priceOutOfRangeWarningBuy')
                : t('priceOutOfRangeWarningSell')}
            </div>
          )}
      </div>
      {simpleView && <div className="orders-info-rectangle">
        <SimpleOrdersContainer
          orders={orders}
          router={router}
          address={address}
          refetch={refetch}
          sendUserOperationAsync={sendUserOperationAsync}
          setChain={handleSetChain}
        />
      </div>}
    </div>
  );

  // send ui component
  const send = (
    <div className="rectangle">
      <div className="navlinkwrapper" onClick={() => {
        if (windowWidth <= 1020 && !simpleView && !showTrade) {
          setShowTrade(true);
          document.querySelector('.trade-mobile-switch')?.classList.add('open');
        }
      }} data-active={location.pathname.slice(1)}>
        <div className="innernavlinkwrapper">
          <Link
            to={simpleView ? "/swap" : "/market"}
            className={`navlink ${location.pathname.slice(1) === 'swap' ? 'active' : ''}`}
          >
            {simpleView ? t('swap') : t('market')}
          </Link>
          <Link
            to="/limit"
            className={`navlink ${location.pathname.slice(1) === 'limit' ? 'active' : ''}`}
          >
            {t('limit')}
          </Link>
          <span
            ref={(el: HTMLSpanElement | null) => {
              sendButtonRef.current = el;
            }}
            className={`navlink ${location.pathname.slice(1) != 'swap' && location.pathname.slice(1) != 'limit' ? 'active' : ''}`}
            onClick={(e: React.MouseEvent) => {
              e.preventDefault();
              setShowSendDropdown(!showSendDropdown);
            }}
          >
            <span className="current-pro-text">{t(currentProText)}</span>
            <svg
              className={`dropdown-arrow ${showSendDropdown ? 'open' : ''}`}
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="12"
              height="12"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            >
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </span>

          {showSendDropdown && (
            <div className="navlink-dropdown" ref={sendDropdownRef}>
              <Link
                to="/send"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('send');
                }}
              >
                {t('send')}
              </Link>
              <Link
                to="/scale"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('scale');
                }}
              >
                <TooltipLabel
                  label={t('scale')}
                  tooltipText={
                    <div>
                      <div className="tooltip-description">
                        {t('scaleTooltip')}
                      </div>
                    </div>
                  }
                  className="impact-label"
                />
              </Link>

            </div>
          )}
        </div>
        <div className="sliding-tab-indicator" />
      </div>
      <div className="swapmodal">
        <div
          className={`sendbg ${connected && amountIn > tokenBalances[tokenIn] && !txPending.current
            ? 'exceed-balance'
            : ''
            }`}
        >
          <div className="sendbutton1container">
            <div className="send-Send">{t('send')}</div>
            <button
              className="send-button1"
              onClick={() => {
                setpopup(1);
              }}
            >
              <img className="send-button1pic" src={tokendict[tokenIn].image} />
              <span>{tokendict[tokenIn].ticker || '?'}</span>
            </button>
          </div>
          <div className="sendinputcontainer">
            <input
              inputMode="decimal"
              className={`send-input ${connected &&
                amountIn > tokenBalances[tokenIn] && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onCompositionStart={() => {
                setIsComposing(true);
              }}
              onCompositionEnd={(
                e: React.CompositionEvent<HTMLInputElement>,
              ) => {
                setIsComposing(false);
                const value = e.currentTarget.value;

                if (/^\$?\d*\.?\d{0,18}$/.test(value)) {
                  if (displayMode === 'usd') {
                    if (value === '$') {
                      setsendInputString('');
                      setInputString('');
                      debouncedSetAmount(BigInt(0));
                      setSliderPercent(0);

                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        (popup as HTMLElement).style.left = `${15 / 2}px`;
                      }
                    } else {
                      const numericValue = value.replace(/^\$/, '');
                      setsendInputString(`$${numericValue}`);

                      const tokenBigInt = calculateTokenAmount(
                        numericValue,
                        tradesByMarket[
                        (({ baseAsset, quoteAsset }) =>
                          (baseAsset === wethticker ? ethticker : baseAsset) +
                          (quoteAsset === wethticker ? ethticker : quoteAsset)
                        )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                        ],
                        tokenIn,
                        getMarket(
                          activeMarket.path.at(0),
                          activeMarket.path.at(1),
                        ),
                      );

                      setInputString(
                        customRound(
                          Number(tokenBigInt) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                      );

                      debouncedSetAmount(tokenBigInt);
                      setswitched(false);

                      const percentage = !tokenBalances[tokenIn]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (tokenBigInt * BigInt(100)) /
                              tokenBalances[tokenIn],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);

                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                          }px`;
                      }
                    }
                  } else {
                    setInputString(value);

                    const tokenBigInt = BigInt(
                      Math.round(
                        (parseFloat(value || '0') || 0) *
                        10 ** Number(tokendict[tokenIn].decimals),
                      ),
                    );
                    debouncedSetAmount(tokenBigInt);
                    setswitched(false);

                    const usd = calculateUSDValue(
                      tokenBigInt,
                      tradesByMarket[
                      (({ baseAsset, quoteAsset }) =>
                        (baseAsset === wethticker ? ethticker : baseAsset) +
                        (quoteAsset === wethticker ? ethticker : quoteAsset)
                      )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                      ],
                      tokenIn,
                      getMarket(
                        activeMarket.path.at(0),
                        activeMarket.path.at(1),
                      ),
                    ).toFixed(2);
                    setsendInputString(`$${usd}`);

                    const percentage = !tokenBalances[tokenIn]
                      ? 0
                      : Math.min(
                        100,
                        Math.floor(
                          Number(
                            (tokenBigInt * BigInt(100)) /
                            tokenBalances[tokenIn],
                          ),
                        ),
                      );
                    setSliderPercent(percentage);

                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                }
              }}
              onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                if (isComposing) {
                  if (displayMode === 'usd') {
                    setsendInputString(e.target.value);
                  } else {
                    setInputString(e.target.value);
                  }
                  return;
                }

                const value = e.target.value;
                if (/^\$?\d*\.?\d{0,18}$/.test(value)) {
                  if (displayMode === 'usd') {
                    if (value === '$') {
                      setsendInputString('');
                      setInputString('');
                      debouncedSetAmount(BigInt(0));
                      setSliderPercent(0);

                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        (popup as HTMLElement).style.left = `${15 / 2}px`;
                      }
                    } else {
                      const numericValue = value.replace(/^\$/, '');
                      setsendInputString(`$${numericValue}`);

                      const tokenBigInt = calculateTokenAmount(
                        numericValue,
                        tradesByMarket[
                        (({ baseAsset, quoteAsset }) =>
                          (baseAsset === wethticker ? ethticker : baseAsset) +
                          (quoteAsset === wethticker ? ethticker : quoteAsset)
                        )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                        ],
                        tokenIn,
                        getMarket(
                          activeMarket.path.at(0),
                          activeMarket.path.at(1),
                        ),
                      );

                      setInputString(
                        customRound(
                          Number(tokenBigInt) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                      );
                      debouncedSetAmount(tokenBigInt);
                      setswitched(false);

                      const percentage = !tokenBalances[tokenIn]
                        ? 0
                        : Math.min(
                          100,
                          Math.floor(
                            Number(
                              (tokenBigInt * BigInt(100)) /
                              tokenBalances[tokenIn],
                            ),
                          ),
                        );
                      setSliderPercent(percentage);

                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                          }px`;
                      }
                    }
                  } else {
                    setInputString(value);
                    const tokenBigInt = BigInt(
                      Math.round(
                        (parseFloat(value || '0') || 0) *
                        10 ** Number(tokendict[tokenIn].decimals),
                      ),
                    );
                    debouncedSetAmount(tokenBigInt);
                    setswitched(false);

                    const usd = calculateUSDValue(
                      tokenBigInt,
                      tradesByMarket[
                      (({ baseAsset, quoteAsset }) =>
                        (baseAsset === wethticker ? ethticker : baseAsset) +
                        (quoteAsset === wethticker ? ethticker : quoteAsset)
                      )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                      ],
                      tokenIn,
                      getMarket(
                        activeMarket.path.at(0),
                        activeMarket.path.at(1),
                      ),
                    ).toFixed(2);
                    setsendInputString(`$${usd}`);

                    const percentage = !tokenBalances[tokenIn]
                      ? 0
                      : Math.min(
                        100,
                        Math.floor(
                          Number(
                            (tokenBigInt * BigInt(100)) /
                            tokenBalances[tokenIn],
                          ),
                        ),
                      );
                    setSliderPercent(percentage);

                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                        }px`;
                    }
                  }
                }
              }}
              placeholder={displayMode === 'usd' ? '$0.00' : '0.00'}
              value={displayMode === 'usd' ? sendInputString : inputString}
              autoFocus={!(windowWidth <= 1020)}
            />
          </div>
          <div className="send-balance-wrapper">
            <div className="send-balance-max-container">
              <div className="send-balance1">
                <img src={walleticon} className="send-balance-wallet-icon" />{' '}
                {formatSubscript(formatDisplayValue(
                  tokenBalances[tokenIn],
                  Number(tokendict[tokenIn].decimals),
                ))}
              </div>
              <div
                className="send-max-button"
                onClick={() => {
                  if (tokenBalances[tokenIn] != BigInt(0)) {
                    let amount =
                      (tokenIn == eth && !client)
                        ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : tokenBalances[tokenIn];
                    debouncedSetAmount(BigInt(amount));
                    setswitched(false);
                    setInputString(
                      customRound(
                        Number(amount) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      ).toString(),
                    );
                    setsendInputString(
                      `$${calculateUSDValue(
                        amount,
                        tradesByMarket[
                        (({ baseAsset, quoteAsset }) =>
                          (baseAsset === wethticker ? ethticker : baseAsset) +
                          (quoteAsset === wethticker ? ethticker : quoteAsset)
                        )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                        ],
                        tokenIn,
                        getMarket(
                          activeMarket.path.at(0),
                          activeMarket.path.at(1),
                        ),
                      ).toFixed(2)}`,
                    );
                    setSliderPercent(100);
                    const slider = document.querySelector(
                      '.balance-amount-slider',
                    );
                    const popup = document.querySelector(
                      '.slider-percentage-popup',
                    );
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      const trackWidth = rect.width - 15;
                      const thumbPosition = trackWidth + 15 / 2;
                      (popup as HTMLElement).style.left = `${thumbPosition}px`;
                    }
                  }
                }}
              >
                {t('max')}
              </div>
            </div>
            <div
              className="send-usd-switch-wrapper"
              onClick={() => {
                if (displayMode === 'usd') {
                  setDisplayMode('token');
                  if (parseFloat(sendInputString.replace(/^\$|,/g, '')) == 0) {
                    setInputString('');
                  }
                } else {
                  setDisplayMode('usd');
                  if (parseFloat(inputString) == 0) {
                    setsendInputString('');
                  }
                }
              }}
            >
              <div className="send-usd-value">
                {displayMode === 'usd'
                  ? `${customRound(
                    Number(amountIn) /
                    10 ** Number(tokendict[tokenIn].decimals),
                    3,
                  )} ${tokendict[tokenIn].ticker}`
                  : amountIn === BigInt(0)
                    ? '$0.00'
                    : Math.round(
                      (parseFloat(inputString || '0') || 0) *
                      10 ** Number(tokendict[tokenIn].decimals),
                    ) == 0
                      ? '$0.00'
                      : formatUSDDisplay(
                        calculateUSDValue(
                          BigInt(
                            Math.round(
                              (parseFloat(inputString || '0') || 0) *
                              10 ** Number(tokendict[tokenIn].decimals),
                            ),
                          ),
                          tradesByMarket[
                          (({ baseAsset, quoteAsset }) =>
                            (baseAsset === wethticker ? ethticker : baseAsset) +
                            (quoteAsset === wethticker ? ethticker : quoteAsset)
                          )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                          ],
                          tokenIn,
                          getMarket(
                            activeMarket.path.at(0),
                            activeMarket.path.at(1),
                          ),
                        ),
                      )}
              </div>
              <img src={sendSwitch} className="send-arrow" />
            </div>
          </div>
        </div>
        <div className="swap-container-divider" />

        <div className="sendaddressbg">
          <div className="send-To">{t('to')}</div>
          <div className="send-address-input-container">
            <input
              className="send-output"
              onChange={(e) => {
                if (e.target.value === '' || /^(0x[0-9a-fA-F]{0,40}|0)$/.test(e.target.value)) {
                  setrecipient(e.target.value);
                }
              }}
              value={recipient}
              placeholder={t('enterWalletAddress')}
            />
            <button
              className="address-paste-button"
              onClick={async () => {
                try {
                  const text = await navigator.clipboard.readText();
                  if (/^(0x[0-9a-fA-F]{40})$/.test(text)) {
                    setrecipient(text);
                  }
                } catch (err) {
                  console.error('Failed to read clipboard: ', err);
                }
              }}
            >
              <svg
                width="16"
                height="16"
                viewBox="0 0 24 24"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path>
                <rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect>
              </svg>
            </button>
          </div>
        </div>
        <button
          className={`send-swap-button ${isSigning ? 'signing' : ''}`}
          onClick={async () => {
            if (
              connected &&
              userchain === activechain
            ) {
              let hash: any;
              setIsSigning(true)
              if (client) {
                txPending.current = true
              }
              try {
                if (tokenIn == eth) {
                  hash = await sendUserOperationAsync({
                    uo: sendeth(
                      recipient as `0x${string}`,
                      amountIn,
                    )
                  });
                  if (!client) {
                    txPending.current = true
                  }
                  newTxPopup(
                    (hash),
                    'send',
                    eth,
                    '',
                    customRound(
                      Number(amountIn) / 10 ** Number(tokendict[eth].decimals),
                      3,
                    ),
                    0,
                    '',
                    recipient,
                  );
                } else {
                  hash = await sendUserOperationAsync({
                    uo: sendtokens(
                      tokenIn as `0x${string}`,
                      recipient as `0x${string}`,
                      amountIn,
                    )
                  });
                  if (!client) {
                    txPending.current = true
                  }
                  newTxPopup(
                    (hash),
                    'send',
                    tokenIn,
                    '',
                    customRound(
                      Number(amountIn) /
                      10 ** Number(tokendict[tokenIn].decimals),
                      3,
                    ),
                    0,
                    '',
                    recipient,
                  );
                }
                setInputString('');
                setsendInputString('');
                setamountIn(BigInt(0));
                setSliderPercent(0);
                setSendButton(0);
                setSendButtonDisabled(true);
                setIsSigning(false)
                const slider = document.querySelector('.balance-amount-slider');
                const popup = document.querySelector(
                  '.slider-percentage-popup',
                );
                if (slider && popup) {
                  (popup as HTMLElement).style.left = `${15 / 2}px`;
                }
                await refetch()
                txPending.current = false
              } catch (error) {
                if (!(error instanceof TransactionExecutionError)) {
                  newTxPopup(
                    hash,
                    "sendFailed",
                    tokenIn === eth ? eth : tokenIn,
                    "",
                    customRound(
                      Number(amountIn) / 10 ** Number(tokendict[tokenIn === eth ? eth : tokenIn].decimals),
                      3,
                    ),
                    0,
                    "",
                    recipient,
                  );
                }
              } finally {
                txPending.current = false
                setIsSigning(false)
              }
            } else {
              !connected
                ? setpopup(4)
                : handleSetChain()
            }
          }}
          disabled={sendButtonDisabled || isSigning}
        >
          {isSigning ? (
            <div className="button-content">
              <div className="loading-spinner" />
              {validOneCT ? t('') : t('signTransaction')}
            </div>
          ) : !connected ? (
            t('connectWallet')
          ) : sendButton == 0 ? (
            t('enterAmount')
          ) : sendButton == 1 ? (
            t('enterWalletAddress')
          ) : sendButton == 2 ? (
            t('send')
          ) : sendButton == 3 ? (
            t('insufficient') +
            (tokendict[tokenIn].ticker || '?') +
            ' ' +
            t('bal')
          ) : sendButton == 4 ? (
            `${t('switchto')} ${t(settings.chainConfig[activechain].name)}`
          ) : (
            t('connectWallet')
          )}
        </button>
      </div>
    </div>
  );

  // scale ui component
  const scale = (
    <div className="rectangle">
      <div className="navlinkwrapper" onClick={() => {
        if (windowWidth <= 1020 && !simpleView && !showTrade) {
          setShowTrade(true);
          document.querySelector('.trade-mobile-switch')?.classList.add('open');
        }
      }} data-active={location.pathname.slice(1)}>
        <div className="innernavlinkwrapper">
          <Link
            to={simpleView ? "/swap" : "/market"}
            className={`navlink ${location.pathname.slice(1) === 'swap' ? 'active' : ''}`}
          >
            {simpleView ? t('swap') : t('market')}
          </Link>
          <Link
            to="/limit"
            className={`navlink ${location.pathname.slice(1) === 'limit' ? 'active' : ''}`}
          >
            {t('limit')}
          </Link>
          <span
            ref={(el: HTMLSpanElement | null) => {
              sendButtonRef.current = el;
            }}
            className={`navlink ${location.pathname.slice(1) != 'swap' && location.pathname.slice(1) != 'limit' ? 'active' : ''}`}
            onClick={(e: React.MouseEvent) => {
              e.preventDefault();
              setShowSendDropdown(!showSendDropdown);
            }}
          >
            <span className="current-pro-text">{t(currentProText)}</span>
            <svg
              className={`dropdown-arrow ${showSendDropdown ? 'open' : ''}`}
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              width="12"
              height="12"
              fill="none"
              stroke="currentColor"
              strokeWidth="2"
              strokeLinecap="round"
              strokeLinejoin="round"
            >
              <polyline points="6 9 12 15 18 9"></polyline>
            </svg>
          </span>

          {showSendDropdown && (
            <div className="navlink-dropdown" ref={sendDropdownRef}>
              <Link
                to="/send"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('send');
                }}
              >
                {t('send')}
              </Link>
              <Link
                to="/scale"
                className="dropdown-item"
                onClick={() => {
                  setShowSendDropdown(false);
                  setCurrentProText('scale');
                }}
              >
                <TooltipLabel
                  label={t('scale')}
                  tooltipText={
                    <div>
                      <div className="tooltip-description">
                        {t('scaleTooltip')}
                      </div>
                    </div>
                  }
                  className="impact-label"
                />
              </Link>

            </div>
          )}
        </div>
        <div className="sliding-tab-indicator" />
      </div>
      <div className="swapmodal">
        <div
          className={`inputbg ${connected &&
            ((amountIn > tokenBalances[tokenIn] &&
              !isLoading &&
              !stateIsLoading) ||
              (amountIn != BigInt(0) &&
                (tokenIn == activeMarket.quoteAddress
                  ? amountIn < activeMarket.minSize
                  : (amountIn * limitPrice) / activeMarket.scaleFactor <
                  activeMarket.minSize))) && !txPending.current
            ? 'exceed-balance'
            : ''
            }`}
        >
          <div className="Pay">{t('pay')}</div>
          <div className="inputbutton1container">
            <input
              inputMode="decimal"
              className={`input ${connected &&
                ((amountIn > tokenBalances[tokenIn] &&
                  !isLoading &&
                  !stateIsLoading) ||
                  (amountIn !== BigInt(0) &&
                    (tokenIn === activeMarket.quoteAddress
                      ? amountIn < activeMarket.minSize
                      : (amountIn * limitPrice) / activeMarket.scaleFactor <
                      activeMarket.minSize))) && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onCompositionStart={() => {
                setIsComposing(true);
              }}
              onCompositionEnd={(
                e: React.CompositionEvent<HTMLInputElement>,
              ) => {
                setIsComposing(false);
                if (/^\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                  setInputString(e.currentTarget.value);
                  if (
                    (inputString.endsWith('.') && e.currentTarget.value === inputString.slice(0, -1)) ||
                    (e.currentTarget.value.endsWith('.') && e.currentTarget.value.slice(0, -1) === inputString)
                  ) {
                    return;
                  }
                  const inputValue = BigInt(
                    Math.round(
                      (parseFloat(e.currentTarget.value || '0') || 0) *
                      10 ** Number(tokendict[tokenIn].decimals),
                    ),
                  );
                  if (scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                    setScaleOutput(Number(inputValue), Number(scaleStart), Number(scaleEnd), Number(scaleOrders), Number(scaleSkew))
                  }
                  else {
                    setScaleOutput(Number(inputValue), Number(scaleStart), Number(scaleEnd), Number(0), Number(scaleSkew))
                  }

                  debouncedSetAmount(inputValue);
                  setswitched(false);

                  const percentage = !tokenBalances[tokenIn]
                    ? 0
                    : Math.min(
                      100,
                      Math.floor(
                        Number(
                          (inputValue * BigInt(100)) / tokenBalances[tokenIn],
                        ),
                      ),
                    );
                  setSliderPercent(percentage);

                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    (popup as HTMLElement).style.left =
                      `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                  }
                }
              }}
              onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                if (isComposing) {
                  setInputString(e.target.value);
                  return;
                }

                if (/^\d*\.?\d{0,18}$/.test(e.target.value)) {
                  setInputString(e.target.value);
                  if (
                    (inputString.endsWith('.') && e.target.value === inputString.slice(0, -1)) ||
                    (e.target.value.endsWith('.') && e.target.value.slice(0, -1) === inputString)
                  ) {
                    return;
                  }
                  const inputValue = BigInt(
                    Math.round(
                      (parseFloat(e.currentTarget.value || '0') || 0) *
                      10 ** Number(tokendict[tokenIn].decimals),
                    ),
                  );
                  if (scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                    setScaleOutput(Number(inputValue), Number(scaleStart), Number(scaleEnd), Number(scaleOrders), Number(scaleSkew))
                  }
                  else {
                    setScaleOutput(Number(inputValue), Number(scaleStart), Number(scaleEnd), Number(0), Number(scaleSkew))
                  }

                  debouncedSetAmount(inputValue);
                  setswitched(false);

                  const percentage = !tokenBalances[tokenIn]
                    ? 0
                    : Math.min(
                      100,
                      Math.floor(
                        Number(
                          (inputValue * BigInt(100)) / tokenBalances[tokenIn],
                        ),
                      ),
                    );
                  setSliderPercent(percentage);

                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    (popup as HTMLElement).style.left =
                      `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
                  }
                }
              }}
              placeholder="0.00"
              value={inputString}
              autoFocus={!(windowWidth <= 1020)}
            />
            <button
              className={`button1 ${connected &&
                ((amountIn > tokenBalances[tokenIn] &&
                  !isLoading &&
                  !stateIsLoading) ||
                  (amountIn != BigInt(0) &&
                    (tokenIn == activeMarket.quoteAddress
                      ? amountIn < activeMarket.minSize
                      : (amountIn * limitPrice) / activeMarket.scaleFactor <
                      activeMarket.minSize))) && !txPending.current
                ? 'exceed-balance'
                : ''
                }`}
              onClick={() => {
                setpopup(1);
              }}
            >
              <img className="button1pic" src={tokendict[tokenIn].image} />
              <span>{tokendict[tokenIn].ticker || '?'}</span>
              <svg
                className={`button-arrow ${popup == 1 ? 'open' : ''}`}
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 24 24"
                width="16"
                height="16"
                fill="none"
                stroke="currentColor"
                strokeWidth="2"
                strokeLinecap="round"
                strokeLinejoin="round"
              >
                <polyline points="6 9 12 15 18 9"></polyline>
              </svg>
            </button>
          </div>
          <div className="balance1maxcontainer">
            <span className="usd-value">
              {Math.round(
                (parseFloat(inputString || '0') || 0) *
                10 ** Number(tokendict[tokenIn].decimals),
              ) == 0
                ? '$0.00'
                : formatUSDDisplay(
                  calculateUSDValue(
                    BigInt(
                      Math.round(
                        (parseFloat(inputString || '0') || 0) *
                        10 ** Number(tokendict[tokenIn].decimals),
                      ),
                    ),
                    tradesByMarket[
                    (({ baseAsset, quoteAsset }) =>
                      (baseAsset === wethticker ? ethticker : baseAsset) +
                      (quoteAsset === wethticker ? ethticker : quoteAsset)
                    )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                    ],
                    tokenIn,
                    getMarket(
                      activeMarket.path.at(0),
                      activeMarket.path.at(1),
                    ),
                  ),
                )}
            </span>
            <div className="balance1">
              <img src={walleticon} className="balance-wallet-icon" />{' '}
              {formatSubscript(formatDisplayValue(
                tokenBalances[tokenIn],
                Number(tokendict[tokenIn].decimals),
              ))}
            </div>
            <div
              className="max-button"
              onClick={() => {
                if (tokenBalances[tokenIn] != BigInt(0)) {
                  let amount =
                    (tokenIn == eth && !client)
                      ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount >
                        BigInt(0)
                        ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount
                        : BigInt(0)
                      : tokenBalances[tokenIn];
                  debouncedSetAmount(BigInt(amount));
                  setswitched(false);
                  setInputString(
                    customRound(
                      Number(amount) /
                      10 ** Number(tokendict[tokenIn].decimals),
                      3,
                    ).toString(),
                  );
                  if (scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                    setScaleOutput(Number(amount), Number(scaleStart), Number(scaleEnd), Number(scaleOrders), Number(scaleSkew))
                  }
                  else {
                    setScaleOutput(Number(amount), Number(scaleStart), Number(scaleEnd), Number(0), Number(scaleSkew))
                  }
                  setSliderPercent(100);
                  const slider = document.querySelector(
                    '.balance-amount-slider',
                  );
                  const popup = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (slider && popup) {
                    const rect = slider.getBoundingClientRect();
                    const trackWidth = rect.width - 15;
                    const thumbPosition = trackWidth + 15 / 2;
                    (popup as HTMLElement).style.left = `${thumbPosition}px`;
                  }
                }
              }}
            >
              {t('max')}{' '}
            </div>
          </div>
        </div>
        <div
          className="switch-button"
          onClick={() => {
            setTokenIn(tokenOut);
            setTokenOut(tokenIn);
            setswitched((switched) => { return !switched });
            if (amountIn != BigInt(0) && scaleStart && scaleEnd && scaleOrders && scaleSkew) {
              setInputString(outputString);
              setoutputString(inputString);
              setamountIn(amountOutSwap);
              setamountOutSwap(amountIn);
              const percentage = !tokenBalances[tokenOut]
                ? 0
                : Math.min(
                  100,
                  Math.floor(
                    Number(
                      (amountOutSwap * BigInt(100)) /
                      tokenBalances[tokenOut],
                    ),
                  ),
                );
              setSliderPercent(percentage);
              const slider = document.querySelector('.balance-amount-slider');
              const popup = document.querySelector('.slider-percentage-popup');
              if (slider && popup) {
                const rect = slider.getBoundingClientRect();
                (popup as HTMLElement).style.left =
                  `${(rect.width - 15) * (percentage / 100) + 15 / 2}px`;
              }
            }
            else {
              setamountIn(BigInt(0))
              setInputString('')
            }
          }}
        >
          <img src={tradearrow} className="switch-arrow" />
        </div>
        <div className="swap-container-divider" />
        <div className="outputbg">
          <div className="Recieve">{t('receive')}</div>
          <div className="outputbutton2container">
            <>
              <input
                inputMode="decimal"
                className="output"
                onCompositionStart={() => {
                  setIsComposing(true);
                }}
                onCompositionEnd={(
                  e: React.CompositionEvent<HTMLInputElement>,
                ) => {
                  setIsComposing(false);
                  if (/^\d*\.?\d{0,18}$/.test(e.currentTarget.value)) {
                    setoutputString(e.currentTarget.value);
                    const outputValue = BigInt(
                      Math.round(
                        (parseFloat(e.currentTarget.value || '0') || 0) *
                        10 ** Number(tokendict[tokenOut].decimals),
                      ),
                    )
                    setamountOutSwap(outputValue);
                    setswitched(true);
                    if (scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                      const requiredInput = calculateScaleInput(
                        outputValue,
                        Number(scaleStart),
                        Number(scaleEnd),
                        Number(scaleOrders),
                        Number(scaleSkew)
                      );
                      setamountIn(requiredInput);
                      setInputString(
                        customRound(
                          Number(requiredInput) / 10 ** Number(tokendict[tokenIn].decimals),
                          3
                        ).toString()
                      );
                      const percentage =
                        tokenBalances[tokenIn] === BigInt(0)
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (requiredInput) * BigInt(100) / tokenBalances[tokenIn])
                            ),
                          );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                          }px`;
                      }
                    }
                    else {
                      const requiredInput = calculateScaleInput(
                        outputValue,
                        Number(scaleStart),
                        Number(scaleEnd),
                        Number(0),
                        Number(scaleSkew)
                      );
                      setamountIn(requiredInput);
                      setInputString('');
                      const percentage =
                        tokenBalances[tokenIn] === BigInt(0)
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (requiredInput) * BigInt(100) / tokenBalances[tokenIn])
                            ),
                          );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                          }px`;
                      }
                    }
                  }
                }}
                onChange={(e: React.ChangeEvent<HTMLInputElement>) => {
                  if (isComposing) {
                    setoutputString(e.target.value);
                    return;
                  }
                  if (/^\d*\.?\d{0,18}$/.test(e.target.value)) {
                    setoutputString(e.target.value);
                    const outputValue = BigInt(
                      Math.round(
                        (parseFloat(e.target.value || '0') || 0) *
                        10 ** Number(tokendict[tokenOut].decimals),
                      ),
                    )
                    setamountOutSwap(outputValue);
                    setswitched(true);
                    if (scaleStart && scaleEnd && scaleOrders && scaleSkew) {
                      const requiredInput = calculateScaleInput(
                        outputValue,
                        Number(scaleStart),
                        Number(scaleEnd),
                        Number(scaleOrders),
                        Number(scaleSkew)
                      );
                      setamountIn(requiredInput);
                      setInputString(
                        customRound(
                          Number(requiredInput) / 10 ** Number(tokendict[tokenIn].decimals),
                          3
                        ).toString()
                      );
                      const percentage =
                        tokenBalances[tokenIn] === BigInt(0)
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (requiredInput) * BigInt(100) / tokenBalances[tokenIn])
                            ),
                          );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                          }px`;
                      }
                    }
                    else {
                      const requiredInput = calculateScaleInput(
                        outputValue,
                        Number(scaleStart),
                        Number(scaleEnd),
                        Number(0),
                        Number(scaleSkew)
                      );
                      setamountIn(requiredInput);
                      setInputString('');
                      const percentage =
                        tokenBalances[tokenIn] === BigInt(0)
                          ? 0
                          : Math.min(
                            100,
                            Math.floor(
                              Number(
                                (requiredInput) * BigInt(100) / tokenBalances[tokenIn])
                            ),
                          );
                      setSliderPercent(percentage);
                      const slider = document.querySelector(
                        '.balance-amount-slider',
                      );
                      const popup = document.querySelector(
                        '.slider-percentage-popup',
                      );
                      if (slider && popup) {
                        const rect = slider.getBoundingClientRect();
                        (popup as HTMLElement).style.left = `${(rect.width - 15) * (percentage / 100) + 15 / 2
                          }px`;
                      }
                    }
                  }
                }}
                placeholder="0.00"
                value={outputString}
              />
              <button
                className="button2"
                onClick={() => {
                  setpopup(2);
                }}
              >
                <img className="button2pic" src={tokendict[tokenOut].image} />
                <span>{tokendict[tokenOut].ticker || "?"}</span>
                <svg
                  className={`button-arrow ${popup == 2 ? 'open' : ''}`}
                  xmlns="http://www.w3.org/2000/svg"
                  viewBox="0 0 24 24"
                  width="16"
                  height="16"
                  fill="none"
                  stroke="currentColor"
                  strokeWidth="2"
                  strokeLinecap="round"
                  strokeLinejoin="round"
                >
                  <polyline points="6 9 12 15 18 9"></polyline>
                </svg>
              </button>
            </>
          </div>
          <div className="balance1maxcontainer">
            <div className="output-usd-value">
              {amountOutSwap === BigInt(0)
                ? "$0.00"
                : (() => {
                  const outputUSD = calculateUSDValue(
                    amountOutSwap,
                    tradesByMarket[
                    (({ baseAsset, quoteAsset }) =>
                      (baseAsset === wethticker ? ethticker : baseAsset) +
                      (quoteAsset === wethticker ? ethticker : quoteAsset)
                    )(getMarket(activeMarket.path.at(-2), activeMarket.path.at(-1)))
                    ],
                    tokenOut,
                    getMarket(
                      activeMarket.path.at(-2),
                      activeMarket.path.at(-1)
                    )
                  );

                  const inputUSD = calculateUSDValue(
                    BigInt(
                      Math.round(
                        (parseFloat(inputString || "0") || 0) *
                        10 ** Number(tokendict[tokenIn].decimals)
                      )
                    ),
                    tradesByMarket[
                    (({ baseAsset, quoteAsset }) =>
                      (baseAsset === wethticker ? ethticker : baseAsset) +
                      (quoteAsset === wethticker ? ethticker : quoteAsset)
                    )(getMarket(activeMarket.path.at(0), activeMarket.path.at(1)))
                    ],
                    tokenIn,
                    getMarket(
                      activeMarket.path.at(0),
                      activeMarket.path.at(1)
                    )
                  );

                  const percentageDiff =
                    inputUSD > 0 ? ((outputUSD - inputUSD) / inputUSD) * 100 : 0;

                  return (
                    <div className="output-usd-container">
                      <span>{formatUSDDisplay(outputUSD)}</span>
                      {inputUSD > 0 && (
                        <span
                          className={`output-percentage ${percentageDiff >= 0 ? "positive" : "negative"
                            }`}
                        >
                          ({percentageDiff >= 0 ? "+" : ""}
                          {percentageDiff.toFixed(2)}%)
                        </span>
                      )}
                    </div>
                  );
                })()}
            </div>
            <div className="balance2">
              <img src={walleticon} className="balance-wallet-icon" />{" "}
              {formatSubscript(formatDisplayValue(
                tokenBalances[tokenOut],
                Number(tokendict[tokenOut].decimals)
              ))}
            </div>
          </div>
        </div>
        <div className="scale-start-end-container">
          <div
            className={`scalebgtop ${connected &&
              !(
                amountIn > tokenBalances[tokenIn] &&
                !isLoading &&
                !stateIsLoading
              ) &&
              amountIn != BigInt(0) &&
              ((scaleStart >= lowestAsk &&
                tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
                (scaleStart <= highestBid &&
                  tokenIn == activeMarket.baseAddress && (addliquidityonly))) &&
              !(tokenIn == activeMarket.quoteAddress
                ? amountIn < activeMarket.minSize
                : (amountIn * scaleStart) / activeMarket.scaleFactor <
                activeMarket.minSize) && !txPending.current
              ? 'exceed-balance'
              : ''
              }`}
          >
            <div className="scalepricecontainer">
              <span className="scale-order-start-label">{t('start')}</span>
              <input
                inputMode="decimal"
                className={`scale-input ${connected &&
                  !(
                    amountIn > tokenBalances[tokenIn] &&
                    !isLoading &&
                    !stateIsLoading
                  ) &&
                  amountIn != BigInt(0) &&
                  ((scaleStart >= lowestAsk &&
                    tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
                    (scaleStart <= highestBid &&
                      tokenIn == activeMarket.baseAddress && (addliquidityonly))) &&
                  !(tokenIn == activeMarket.quoteAddress
                    ? amountIn < activeMarket.minSize
                    : (amountIn * scaleStart) / activeMarket.scaleFactor <
                    activeMarket.minSize) && !txPending.current
                  ? 'exceed-balance'
                  : ''
                  }`}
                onChange={(e) => {
                  if (
                    new RegExp(
                      `^\\d*\\.?\\d{0,${Math.floor(Math.log10(activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(Number(e.target.value) == 0 ? 1 : Number(e.target.value) ?? 1)) - 1) : Number(activeMarket.priceFactor)))}}$`
                    ).test(e.target.value)
                  ) {
                    setScaleStartString(e.target.value);
                    let price = BigInt(
                      Math.round(
                        (parseFloat(e.target.value || '0') || 0) *
                        Number(activeMarket.priceFactor)
                      )
                    );
                    setScaleStart(price);
                    if (price && scaleEnd && scaleOrders && scaleSkew) {
                      if (!switched) {
                        setScaleOutput(
                          Number(amountIn),
                          Number(price),
                          Number(scaleEnd),
                          Number(scaleOrders),
                          Number(scaleSkew)
                        );
                      } else {
                        const requiredInput = calculateScaleInput(
                          BigInt(Number(outputString) * 10 ** Number(tokendict[tokenOut].decimals)),
                          Number(price),
                          Number(scaleEnd),
                          Number(scaleOrders),
                          Number(scaleSkew)
                        );
                        setamountIn(BigInt(requiredInput));
                        setInputString(
                          customRound(
                            Number(requiredInput) / 10 ** Number(tokendict[tokenIn].decimals),
                            3
                          ).toString()
                        );
                      }
                    }
                  }
                }}
                placeholder="0.00"
                value={scaleStartString}
              />
            </div>
          </div>
          <div
            className={`scalebgtop ${connected &&
              !(
                amountIn > tokenBalances[tokenIn] &&
                !isLoading &&
                !stateIsLoading
              ) &&
              amountIn != BigInt(0) &&
              ((scaleEnd >= lowestAsk &&
                tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
                (scaleEnd <= highestBid &&
                  tokenIn == activeMarket.baseAddress && (addliquidityonly))) &&
              !(tokenIn == activeMarket.quoteAddress
                ? amountIn < activeMarket.minSize
                : (amountIn * scaleEnd) / activeMarket.scaleFactor <
                activeMarket.minSize) && !txPending.current
              ? 'exceed-balance'
              : ''
              }`}
          >
            <div className="scalepricecontainer">
              <span className="scale-order-end-label">{t('end')}</span>
              <input
                inputMode="decimal"
                className={`scale-input ${connected &&
                  !(
                    amountIn > tokenBalances[tokenIn] &&
                    !isLoading &&
                    !stateIsLoading
                  ) &&
                  amountIn != BigInt(0) &&
                  ((scaleEnd >= lowestAsk &&
                    tokenIn == activeMarket.quoteAddress && (addliquidityonly)) ||
                    (scaleEnd <= highestBid &&
                      tokenIn == activeMarket.baseAddress && (addliquidityonly))) &&
                  !(tokenIn == activeMarket.quoteAddress
                    ? amountIn < activeMarket.minSize
                    : (amountIn * scaleEnd) / activeMarket.scaleFactor <
                    activeMarket.minSize) && !txPending.current
                  ? 'exceed-balance'
                  : ''
                  }`}
                onChange={(e) => {
                  if (
                    new RegExp(
                      `^\\d*\\.?\\d{0,${Math.floor(Math.log10(activeMarket?.marketType != 0 ? 10 ** Math.max(0, 5 - Math.floor(Math.log10(Number(e.target.value) == 0 ? 1 : Number(e.target.value) ?? 1)) - 1) : Number(activeMarket.priceFactor)))}}$`
                    ).test(e.target.value)
                  ) {
                    setScaleEndString(e.target.value);
                    let price = BigInt(
                      Math.round(
                        (parseFloat(e.target.value || '0') || 0) *
                        Number(activeMarket.priceFactor)
                      )
                    );
                    setScaleEnd(price);
                    if (price && scaleStart && scaleOrders && scaleSkew) {
                      if (!switched) {
                        setScaleOutput(
                          Number(amountIn),
                          Number(scaleStart),
                          Number(price),
                          Number(scaleOrders),
                          Number(scaleSkew)
                        );
                      } else {
                        const requiredInput = calculateScaleInput(
                          BigInt(Number(outputString) * 10 ** Number(tokendict[tokenOut].decimals)),
                          Number(scaleStart),
                          Number(price),
                          Number(scaleOrders),
                          Number(scaleSkew)
                        );
                        setamountIn(BigInt(requiredInput));
                        setInputString(
                          customRound(
                            Number(requiredInput) / 10 ** Number(tokendict[tokenIn].decimals),
                            3
                          ).toString()
                        );
                      }
                    }
                  }
                }}
                placeholder="0.00"
                value={scaleEndString}
              />
            </div>
          </div>
        </div>
        <div className="scale-size-skew">
          <div
            className={`scalebottombg ${scaleOrdersString == '1'
              ? 'exceed-balance'
              : ''
              }`}
          >
            <div className="scalebottomcontainer">
              <span className="scale-order-total-label">{t('orders')}</span>
              <input
                inputMode="numeric" pattern="[0-9]*"
                className={`scale-bottom-input ${scaleOrdersString == '1'
                  ? 'exceed-balance'
                  : ''
                  }`}
                onChange={(e) => {
                  if (/^\d*$/.test(e.target.value) && Number(e.target.value) <= 1000) {
                    setScaleOrdersString(e.target.value);
                    let temporders = BigInt(e.target.value == "1" ? 0 : e.target.value)
                    setScaleOrders(temporders)
                    if (temporders && scaleStart && scaleSkew && scaleEnd) {
                      if (!switched) {
                        setScaleOutput(
                          Number(amountIn),
                          Number(scaleStart),
                          Number(scaleEnd),
                          Number(temporders),
                          Number(scaleSkew)
                        );
                      } else {
                        const requiredInput = calculateScaleInput(
                          BigInt(Number(outputString) * 10 ** Number(tokendict[tokenOut].decimals)),
                          Number(scaleStart),
                          Number(scaleEnd),
                          Number(temporders),
                          Number(scaleSkew)
                        );
                        setamountIn(requiredInput);
                        setInputString(
                          customRound(
                            Number(requiredInput) / 10 ** Number(tokendict[tokenIn].decimals),
                            3
                          ).toString()
                        );
                      }
                    }
                    else {
                      setScaleOutput(Number(amountIn), Number(scaleStart), Number(scaleEnd), Number(0), Number(scaleSkew))
                    }
                  }
                }}
                placeholder="0"
                value={scaleOrdersString}
              />
            </div>
          </div>
          <div
            className={`scalebottombg`}
          >
            <div className="scalebottomcontainer">
              <span className="scale-order-size-label">{t('skew')}</span>
              <input
                inputMode="decimal"
                className={`scale-bottom-input`}
                onChange={(e) => {
                  if (/^\d*\.?\d{0,2}$/.test(e.target.value) && Number(e.target.value) <= 100) {
                    setScaleSkewString(e.target.value);
                    let skew = Number(e.target.value)
                    setScaleSkew(skew)
                    if (skew && scaleStart && scaleOrders && scaleEnd) {
                      if (!switched) {
                        setScaleOutput(
                          Number(amountIn),
                          Number(scaleStart),
                          Number(scaleEnd),
                          Number(scaleOrders),
                          Number(skew)
                        );
                      } else {
                        const requiredInput = calculateScaleInput(
                          BigInt(Number(outputString) * 10 ** Number(tokendict[tokenOut].decimals)),
                          Number(scaleStart),
                          Number(scaleEnd),
                          Number(scaleOrders),
                          Number(skew)
                        );
                        setamountIn(requiredInput);
                        setInputString(
                          customRound(
                            Number(requiredInput) / 10 ** Number(tokendict[tokenIn].decimals),
                            3
                          ).toString()
                        );
                      }
                    }
                  }
                }}
                placeholder="0.00"
                value={scaleSkewString}
              />
            </div>
          </div>
        </div>
        <div className="balance-slider-wrapper">
          {spotSliderMode === 'presets' ? (
            <div className="slider-container presets-mode">
              <div className="preset-buttons">
                {spotSliderPresets.map((preset: number, index: number) => (
                  <button
                    key={index}
                    className={`preset-button ${sliderPercent === preset ? 'active' : ''}`}
                    onClick={() => {
                      if (connected) {
                        const newAmount =
                          (((tokenIn == eth && !client)
                            ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount >
                              BigInt(0)
                              ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount
                              : BigInt(0)
                            : tokenBalances[tokenIn]) *
                            BigInt(preset)) /
                          100n;
                        setSliderPercent(preset);
                        setInputString(
                          newAmount == BigInt(0)
                            ? ''
                            : customRound(
                              Number(newAmount) /
                              10 ** Number(tokendict[tokenIn].decimals),
                              3,
                            ).toString(),
                        );
                        debouncedSetAmount(newAmount);
                        setswitched(false);
                        if (isWrap) {
                          setoutputString(
                            newAmount == BigInt(0)
                              ? ''
                              : customRound(
                                Number(newAmount) /
                                10 ** Number(tokendict[tokenIn].decimals),
                                3,
                              ).toString(),
                          );
                          setamountOutSwap(newAmount);
                        }
                        if (location.pathname.slice(1) === 'limit') {
                          setamountOutSwap(
                            limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                                : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                              : BigInt(0),
                          );
                          setoutputString(
                            (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? customRound(
                                  Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                                : customRound(
                                  Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        const slider = document.querySelector('.balance-amount-slider');
                        const popup = document.querySelector('.slider-percentage-popup');
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          (popup as HTMLElement).style.left = `${(rect.width - 15) * (preset / 100) + 15 / 2}px`;
                        }
                      }
                    }}
                    disabled={!connected}
                  >
                    {preset}%
                  </button>
                ))}
              </div>
            </div>
          ) : spotSliderMode === 'increment' ? (
            <div className="slider-container increment-mode">
              <button
                className="increment-button minus"
                onClick={() => {
                  if (connected && sliderPercent > 0) {
                    const newPercent = Math.max(0, sliderPercent - spotSliderIncrement);
                    const newAmount =
                      (((tokenIn == eth && !client)
                        ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : tokenBalances[tokenIn]) *
                        BigInt(newPercent)) /
                      100n;
                    setSliderPercent(newPercent);
                    setInputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    debouncedSetAmount(newAmount);
                    setswitched(false);
                    if (isWrap) {
                      setoutputString(
                        newAmount == BigInt(0)
                          ? ''
                          : customRound(
                            Number(newAmount) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          ).toString(),
                      );
                      setamountOutSwap(newAmount);
                    }
                    if (location.pathname.slice(1) === 'limit') {
                      setamountOutSwap(
                        limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                            : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                          : BigInt(0),
                      );
                      setoutputString(
                        (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                            : customRound(
                              Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                          : ''
                        ).toString(),
                      );
                    }
                    const slider = document.querySelector('.balance-amount-slider');
                    const popup = document.querySelector('.slider-percentage-popup');
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (newPercent / 100) + 15 / 2}px`;
                    }
                  }
                }}
                disabled={!connected || sliderPercent === 0}
              >
                
              </button>
              <div className="increment-display">
                <div className="increment-amount">{spotSliderIncrement}%</div>
              </div>
              <button
                className="increment-button plus"
                onClick={() => {
                  if (connected && sliderPercent < 100) {
                    const newPercent = Math.min(100, sliderPercent + spotSliderIncrement);
                    const newAmount =
                      (((tokenIn == eth && !client)
                        ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount >
                          BigInt(0)
                          ? tokenBalances[tokenIn] -
                          settings.chainConfig[activechain].gasamount
                          : BigInt(0)
                        : tokenBalances[tokenIn]) *
                        BigInt(newPercent)) /
                      100n;
                    setSliderPercent(newPercent);
                    setInputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    debouncedSetAmount(newAmount);
                    setswitched(false);
                    if (isWrap) {
                      setoutputString(
                        newAmount == BigInt(0)
                          ? ''
                          : customRound(
                            Number(newAmount) /
                            10 ** Number(tokendict[tokenIn].decimals),
                            3,
                          ).toString(),
                      );
                      setamountOutSwap(newAmount);
                    }
                    if (location.pathname.slice(1) === 'limit') {
                      setamountOutSwap(
                        limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                            : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                          : BigInt(0),
                      );
                      setoutputString(
                        (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                          ? tokenIn === activeMarket?.baseAddress
                            ? customRound(
                              Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                            : customRound(
                              Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                              10 ** Number(tokendict[tokenOut].decimals),
                              3,
                            )
                          : ''
                        ).toString(),
                      );
                    }
                    const slider = document.querySelector('.balance-amount-slider');
                    const popup = document.querySelector('.slider-percentage-popup');
                    if (slider && popup) {
                      const rect = slider.getBoundingClientRect();
                      (popup as HTMLElement).style.left = `${(rect.width - 15) * (newPercent / 100) + 15 / 2}px`;
                    }
                  }
                }}
                disabled={!connected || sliderPercent === 100}
              >
                +
              </button>
            </div>
          ) : (
            <div className="slider-container slider-mode">
              <input
                type="range"
                className={`balance-amount-slider ${isDragging ? 'dragging' : ''}`}
                min="0"
                max="100"
                step="1"
                value={sliderPercent}
                disabled={!connected}
                onChange={(e) => {
                  const percent = parseInt(e.target.value);
                  const newAmount =
                    (((tokenIn == eth && !client)
                      ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount >
                        BigInt(0)
                        ? tokenBalances[tokenIn] -
                        settings.chainConfig[activechain].gasamount
                        : BigInt(0)
                      : tokenBalances[tokenIn]) *
                      BigInt(percent)) /
                    100n;
                  setSliderPercent(percent);
                  setInputString(
                    newAmount == BigInt(0)
                      ? ''
                      : customRound(
                        Number(newAmount) /
                        10 ** Number(tokendict[tokenIn].decimals),
                        3,
                      ).toString(),
                  );
                  debouncedSetAmount(newAmount);
                  setswitched(false);
                  if (isWrap) {
                    setoutputString(
                      newAmount == BigInt(0)
                        ? ''
                        : customRound(
                          Number(newAmount) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ).toString(),
                    );
                    setamountOutSwap(newAmount);
                  }
                  if (location.pathname.slice(1) === 'limit') {
                    setamountOutSwap(
                      limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                          : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                        : BigInt(0),
                    );
                    setoutputString(
                      (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                        ? tokenIn === activeMarket?.baseAddress
                          ? customRound(
                            Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                            10 ** Number(tokendict[tokenOut].decimals),
                            3,
                          )
                          : customRound(
                            Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                            10 ** Number(tokendict[tokenOut].decimals),
                            3,
                          )
                        : ''
                      ).toString(),
                    );
                  }
                  const slider = e.target;
                  const rect = slider.getBoundingClientRect();
                  const trackWidth = rect.width - 15;
                  const thumbPosition = (percent / 100) * trackWidth + 15 / 2;
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) {
                    popup.style.left = `${thumbPosition}px`;
                  }
                }}
                onMouseDown={() => {
                  setIsDragging(true);
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) popup.classList.add('visible');
                }}
                onMouseUp={() => {
                  setIsDragging(false);
                  const popup: HTMLElement | null = document.querySelector(
                    '.slider-percentage-popup',
                  );
                  if (popup) popup.classList.remove('visible');
                }}
                style={{
                  background: `linear-gradient(to right,rgb(171, 176, 224) ${sliderPercent}%,rgba(21, 21, 27, 1) ${sliderPercent}%)`,
                }}
              />
              <div className="slider-percentage-popup">{sliderPercent}%</div>
              <div className="balance-slider-marks">
                {[0, 25, 50, 75, 100].map((markPercent) => (
                  <span
                    key={markPercent}
                    className="balance-slider-mark"
                    data-active={sliderPercent >= markPercent}
                    data-percentage={markPercent}
                    onClick={() => {
                      if (connected) {
                        const newAmount =
                          (((tokenIn == eth && !client)
                            ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount >
                              BigInt(0)
                              ? tokenBalances[tokenIn] -
                              settings.chainConfig[activechain].gasamount
                              : BigInt(0)
                            : tokenBalances[tokenIn]) *
                            BigInt(markPercent)) /
                          100n;
                        setSliderPercent(markPercent);
                        setInputString(
                          newAmount == BigInt(0)
                            ? ''
                            : customRound(
                              Number(newAmount) /
                              10 ** Number(tokendict[tokenIn].decimals),
                              3,
                            ).toString(),
                        );
                        debouncedSetAmount(newAmount);
                        setswitched(false);
                        if (isWrap) {
                          setoutputString(
                            newAmount == BigInt(0)
                              ? ''
                              : customRound(
                                Number(newAmount) /
                                10 ** Number(tokendict[tokenIn].decimals),
                                3,
                              ).toString(),
                          );
                          setamountOutSwap(newAmount);
                        }
                        if (location.pathname.slice(1) === 'limit') {
                          setamountOutSwap(
                            limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? (newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))
                                : (newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice
                              : BigInt(0),
                          );
                          setoutputString(
                            (limitPrice !== BigInt(0) && newAmount !== BigInt(0)
                              ? tokenIn === activeMarket?.baseAddress
                                ? customRound(
                                  Number((newAmount * limitPrice) / (activeMarket.scaleFactor || BigInt(1))) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                                : customRound(
                                  Number((newAmount * (activeMarket.scaleFactor || BigInt(1))) / limitPrice) /
                                  10 ** Number(tokendict[tokenOut].decimals),
                                  3,
                                )
                              : ''
                            ).toString(),
                          );
                        }
                        const slider = document.querySelector(
                          '.balance-amount-slider',
                        );
                        const popup: HTMLElement | null = document.querySelector(
                          '.slider-percentage-popup',
                        );
                        if (slider && popup) {
                          const rect = slider.getBoundingClientRect();
                          popup.style.left = `${(rect.width - 15) * (markPercent / 100) + 15 / 2
                            }px`;
                        }
                      }
                    }}
                  >
                    {markPercent}%
                  </span>
                ))}
              </div>
            </div>
          )}
        </div>
        <button
          className={`limit-swap-button ${isSigning ? 'signing' : ''}`}
          onClick={async () => {
            if (connected && userchain === activechain) {
              let finalAmountIn = amountIn;
              if (switched) {
                const desiredOutput =
                  Number(outputString) *
                  10 ** Number(tokendict[tokenOut].decimals);
                finalAmountIn = calculateScaleInput(
                  BigInt(desiredOutput),
                  Number(scaleStart),
                  Number(scaleEnd),
                  Number(scaleOrders),
                  Number(scaleSkew)
                );
              }
              let o = calculateScaleOutput(
                finalAmountIn,
                Number(scaleStart),
                Number(scaleEnd),
                Number(scaleOrders),
                Number(scaleSkew)
              );

              const orderbatch: Record<string, any> = {}

              o.forEach(order => {
                const k = activeMarket?.address
                if (!orderbatch[k]) orderbatch[k] = []
                orderbatch[k].push({
                  isRequireSuccess: false,
                  action: tokenIn == activeMarket.quoteAddress ? ((addliquidityonly) ? 2 : 4) : ((addliquidityonly) ? 3 : 5),
                  param1: order[0], // price
                  param2: tokenIn == activeMarket.quoteAddress ? order[2] : order[1], // size/id
                  param3: BigInt(0),  // cloid or extra id
                })
              })

              const batches: any = Object.entries(orderbatch).map(([market, actions]) => ({
                market: market as `0x${string}`,
                actions,
                options: BigInt(tokenIn == eth ? (1n << 48n) : 0)
              }))

              let hash;
              setIsSigning(true)
              if (client) {
                txPending.current = true
              }
              try {
                if (tokenIn == eth) { // sell
                  hash = await sendUserOperationAsync({
                    uo: multiBatchOrders(
                      router,
                      BigInt(finalAmountIn),
                      batches,
                      BigInt(Math.floor(Date.now() / 1000) + 900),
                      usedRefAddress
                    )
                  })
                } else {
                  if (allowance < finalAmountIn) {
                    if (client) {
                      let uo = []
                      uo.push(approve(
                        tokenIn as `0x${string}`,
                        router,
                        maxUint256,
                      ))
                      uo.push(multiBatchOrders(
                        router,
                        BigInt(0),
                        batches,
                        BigInt(Math.floor(Date.now() / 1000) + 900),
                        usedRefAddress
                      ))
                      hash = await sendUserOperationAsync({ uo: uo })
                      newTxPopup(
                        hash,
                        'approve',
                        tokenIn,
                        '',
                        customRound(
                          Number(finalAmountIn) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ),
                        0,
                        '',
                        router,
                      );
                    }
                    else {
                      hash = await sendUserOperationAsync({
                        uo: approve(
                          tokenIn as `0x${string}`,
                          router,
                          maxUint256,
                        )
                      })
                      newTxPopup(
                        hash,
                        'approve',
                        tokenIn,
                        '',
                        customRound(
                          Number(finalAmountIn) /
                          10 ** Number(tokendict[tokenIn].decimals),
                          3,
                        ),
                        0,
                        '',
                        router,
                      );
                    }
                  }
                  if (!client || !(allowance < finalAmountIn)) {
                    hash = await sendUserOperationAsync({
                      uo: multiBatchOrders(
                        router,
                        BigInt(0),
                        batches,
                        BigInt(Math.floor(Date.now() / 1000) + 900),
                        usedRefAddress
                      )
                    })
                  }
                }
                if (!client && hash) {
                  txPending.current = true
                }
                setInputString('');
                setamountIn(BigInt(0));
                setamountOutSwap(BigInt(0));
                setoutputString('');
                setScaleButtonDisabled(true);
                setScaleButton(0);
                setScaleStart(BigInt(0));
                setScaleEnd(BigInt(0));
                setScaleStartString('');
                setScaleEndString('');
                setScaleSkew(1);
                setScaleSkewString('1.00');
                setScaleOrders(BigInt(0));
                setScaleOrdersString('');
                setSliderPercent(0);
                setIsSigning(false)
                const slider = document.querySelector('.balance-amount-slider');
                const popup = document.querySelector('.slider-percentage-popup');
                if (slider && popup) {
                  (popup as HTMLElement).style.left = `${15 / 2}px`;
                }
                await refetch()
                txPending.current = false
              } catch (error) {
                if (!(error instanceof TransactionExecutionError)) {
                  newTxPopup(
                    hash,
                    "limitFailed",
                    tokenIn == eth ? eth : tokenIn,
                    tokenOut == eth ? eth : tokenOut,
                    customRound(Number(amountIn) / 10 ** Number(tokendict[tokenIn == eth ? eth : tokenIn].decimals), 3),
                    customRound(Number(amountOutSwap) / 10 ** Number(tokendict[tokenOut == eth ? eth : tokenOut].decimals), 3),
                    "",
                    "",
                  );
                }
              } finally {
                txPending.current = false
                setIsSigning(false)
              }
            } else {
              !connected ? setpopup(4) : handleSetChain();
            }
          }}
          disabled={scaleButtonDisabled || isSigning}
        >
          {isSigning ? (
            <div className="button-content">
              <div className="loading-spinner" />
              {validOneCT ? t('') : t('signTransaction')}
            </div>
          ) : scaleButton == 0 ? (
            t('enterAmount')
          ) : scaleButton == 1 ? (
            t('enterStartPrice')
          ) : scaleButton == 2 ? (
            t('enterEndPrice')
          ) : scaleButton == 3 ? (
            t('startPriceHigh')
          ) : scaleButton == 4 ? (
            t('startPriceLow')
          ) : scaleButton == 5 ? (
            t('endPriceHigh')
          ) : scaleButton == 6 ? (
            t('endPriceLow')
          ) : scaleButton == 7 ? (
            t('scaleMinSize')
          ) : scaleButton == 8 ? (
            t('enterOrders')
          ) : scaleButton == 9 ? (
            t('enterSkew')
          ) : scaleButton == 10 ? (
            t('insufficient') + (tokendict[tokenIn].ticker || '?') + ' ' + t('bal')
          ) : scaleButton == 11 ? (
            `${t('switchto')} ${t(settings.chainConfig[activechain].name)}`
          ) : scaleButton == 12 ? (
            t('connectWallet')
          ) : scaleButton == 13 ? (
            client ? (tokenIn == activeMarket.quoteAddress ? t('buy') : t('sell')) + ' ' + activeMarket.baseAsset : t('approve')
          ) : (
            (tokenIn == activeMarket.quoteAddress ? t('buy') : t('sell')) + ' ' + activeMarket.baseAsset
          )}
        </button>
      </div>
      <div className="limit-info-rectangle">
        <div className="trade-fee">
          <div className="label-container">
            <TooltipLabel
              label={t('addLiquidityOnly')}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {t('addLiquidityOnlySubtitle')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <ToggleSwitch
            checked={addliquidityonly}
            onChange={() => {
              const newValue = !addliquidityonly;
              setAddLiquidityOnly(newValue);
              localStorage.setItem(
                'crystal_add_liquidity_only',
                JSON.stringify(newValue),
              );
            }}
          />
        </div>
        <div className="trade-fee">
          <div className="label-container">
            <TooltipLabel
              label={`${t('fee')} (0.00%)`}
              tooltipText={
                <div>
                  <div className="tooltip-description">
                    {t('makerfeeexplanation')}
                  </div>
                </div>
              }
              className="impact-label"
            />
          </div>
          <div className="value-container">
            {`${0} ${tokendict[tokenIn].ticker}`}
          </div>
        </div>
      </div>
      {simpleView && <div className="orders-info-rectangle">
        <SimpleOrdersContainer
          orders={orders}
          router={router}
          address={address}
          refetch={refetch}
          sendUserOperationAsync={sendUserOperationAsync}
          setChain={handleSetChain}
        />
      </div>}
    </div>
  );

  const renderChartComponent = useMemo(() => (
    <ChartComponent
      activeMarket={activeMarket}
      tradehistory={tradehistory}
      isMarksVisible={isMarksVisible}
      setIsMarksVisible={setIsMarksVisible}
      orders={orders}
      isOrdersVisible={isOrdersVisible}
      showChartOutliers={showChartOutliers}
      setShowChartOutliers={setShowChartOutliers}
      router={router}
      refetch={refetch}
      sendUserOperationAsync={sendUserOperationAsync}
      setChain={handleSetChain}
      usedRefAddress={usedRefAddress}
      data={chartData}
      setData={setChartData}
      realtimeCallbackRef={realtimeCallbackRef}
      limitPrice={limitPrice}
      updateLimitAmount={updateLimitAmount}
      tokenIn={tokenIn}
      amountIn={amountIn}
      isLimitOrderMode={location.pathname.slice(1) === 'limit'}
      selectedInterval={selectedInterval}
      setSelectedInterval={setSelectedInterval}
    />
  ), [
    activeMarket,
    tradehistory,
    isMarksVisible,
    orders,
    isOrdersVisible,
    showChartOutliers,
    router,
    refetch,
    handleSetChain,
    usedRefAddress,
    chartData,
    realtimeCallbackRef,
    limitPrice,
    updateLimitAmount,
    tokenIn,
    amountIn,
    location.pathname,
    selectedInterval
  ]);

  const TradeLayout = (swapComponent: JSX.Element) => (
    <div className="trade-container">
      {windowWidth <= 1020 && (
        <div className="mobile-nav" data-active={mobileView}>
          <div className="mobile-nav-inner">
            <button
              className={`mobile-nav-link ${mobileView === 'chart' ? 'active' : ''}`}
              onClick={() => setMobileView('chart')}
            >
              {t('chart')}
            </button>
            <button
              className={`mobile-nav-link ${mobileView === 'orderbook' ? 'active' : ''}`}
              onClick={() => {
                setMobileView('orderbook');
                setOBTab('orderbook');
              }}
            >
              {t('orderbook')}
            </button>
            <button
              className={`mobile-nav-link ${mobileView === 'trades' ? 'active' : ''}`}
              onClick={() => {
                setMobileView('trades');
                setOBTab('trades');
              }}
            >
              {t('trades')}
            </button>
            <div className="mobile-sliding-indicator" />
          </div>
        </div>
      )}
      <div
        className={`main-content-wrapper ${simpleView ? 'simple-view' : ''}`}
        style={{
          flexDirection:
            spotLayoutSettings === 'alternative' ? 'row-reverse' : 'row',
        }}
      >
        {simpleView ? (
          <>
            <div className="right-column">{swapComponent}</div>
          </>
        ) : (
          <>
            <div className="chartandorderbookandordercenter">
              <div className="chartandorderbook">
                <ChartOrderbookPanel
                  layoutSettings={spotLayoutSettings}
                  orderbookPosition={spotOrderbookPosition}
                  orderdata={{
                    roundedBuyOrders: roundedBuyOrders?.orders,
                    roundedSellOrders: roundedSellOrders?.orders,
                    spreadData,
                    priceFactor: Number(markets[roundedBuyOrders?.key]?.priceFactor),
                    marketType: markets[roundedBuyOrders?.key]?.marketType,
                    symbolIn: markets[roundedBuyOrders?.key]?.quoteAsset,
                    symbolOut: markets[roundedBuyOrders?.key]?.baseAsset,
                  }}
                  windowWidth={windowWidth}
                  mobileView={mobileView}
                  isOrderbookVisible={isOrderbookVisible}
                  orderbookWidth={orderbookWidth}
                  setOrderbookWidth={setOrderbookWidth}
                  obInterval={obInterval}
                  amountsQuote={roundedBuyOrders?.amountsQuote}
                  setAmountsQuote={setAmountsQuote}
                  obtrades={trades}
                  setOBInterval={setOBInterval}
                  baseInterval={baseInterval}
                  viewMode={viewMode}
                  setViewMode={setViewMode}
                  activeTab={obTab}
                  setActiveTab={setOBTab}
                  updateLimitAmount={updateLimitAmount}
                  renderChartComponent={renderChartComponent}
                  reserveQuote={reserveQuote}
                  reserveBase={reserveBase}
                />
              </div>
              <div
                className={`oc-spacer ${!isOrderCenterVisible ? 'collapsed' : ''}`}
              >
                <div
                  className="ordercenter-drag-handle"
                  onMouseDown={handleVertMouseDown}
                />
              </div>
              <OrderCenter
                orders={orders}
                tradehistory={tradehistory}
                canceledorders={canceledorders}
                router={router}
                address={address}
                trades={tradesByMarket}
                currentMarket={
                  activeMarketKey.replace(
                    new RegExp(
                      `^${wethticker}|${wethticker}$`,
                      'g'
                    ),
                    ethticker
                  )
                }
                orderCenterHeight={orderCenterHeight}
                hideBalances={true}
                tokenList={memoizedTokenList}
                onMarketSelect={onMarketSelect}
                setSendTokenIn={setSendTokenIn}
                setpopup={setpopup}
                sortConfig={memoizedSortConfig}
                onSort={emptyFunction}
                tokenBalances={tokenBalances}
                activeSection={activeSection}
                setActiveSection={setActiveSection}
                filter={filter}
                setFilter={setFilter}
                onlyThisMarket={onlyThisMarket}
                setOnlyThisMarket={setOnlyThisMarket}
                refetch={refetch}
                sendUserOperationAsync={sendUserOperationAsync}
                setChain={handleSetChain}
                isVertDragging={isVertDragging}
                isOrderCenterVisible={isOrderCenterVisible}
                onLimitPriceUpdate={setCurrentLimitPrice}
                openEditOrderPopup={openEditOrderPopup}
                openEditOrderSizePopup={openEditOrderSizePopup}
                marketsData={marketsData}
              />
            </div>
            {windowWidth > 1020 && (
              <div className="right-column"> {swapComponent} </div>
            )}
          </>
        )}
      </div>
    </div>
  );

  return (
    <div className="app-wrapper" key={language}>
      <NavigationProgress location={location} />
      <MemeTransactionPopupManager />

      {Modals}
      <SidebarNav simpleView={simpleView} setSimpleView={setSimpleView} />
      {windowWidth <= 1020 && !simpleView && ['swap', 'limit', 'send', 'scale', 'market'].includes(location.pathname.slice(1)) && (
        <>
          <div
            className={`right-column ${showTrade ? 'show' : ''} ${isMobileDragging ? 'dragging' : ''}`}
            style={{
              transform: showTrade && isMobileDragging
                ? `translateY(${mobileDragY}px)`
                : showTrade
                  ? 'translateY(0)'
                  : 'translateY(calc(100% - 91px))'
            }}
            onTouchStart={(e: React.TouchEvent) => {
              if (windowWidth <= 1020 && showTrade) {
                setMobileStartY(e.touches[0].clientY);
                setIsMobileDragging(true);
              }
            }}
            onTouchMove={(e: React.TouchEvent) => {
              if (!isMobileDragging || windowWidth > 1020 || !showTrade) return;

              const currentY = e.touches[0].clientY;
              const deltaY = currentY - mobileStartY;

              if (deltaY > 0) {
                setMobileDragY(deltaY);
              }
            }}
            onTouchEnd={() => {
              if (!isMobileDragging || windowWidth > 1020) return;

              setIsMobileDragging(false);

              if (mobileDragY > 100) {
                setShowTrade(false);
                document.body.style.overflow = 'auto';
                document.querySelector('.right-column')?.classList.add('hide');
                document.querySelector('.right-column')?.classList.remove('show');
                document.querySelector('.trade-mobile-switch')?.classList.remove('open');
              }
              setMobileDragY(0);
            }}
          >
            <div className="mobile-drag-handle">
              <div className="drag-indicator"></div>
            </div>

            {location.pathname.slice(1) == 'swap' || location.pathname.slice(1) == 'market' ? swap : location.pathname.slice(1) == 'limit' ? limit : location.pathname.slice(1) == 'send' ? send : scale}
          </div>
        </>
      )}
      {
        <div
        // style={getAppContainerStyle()} 
        >

          <Header
            setTokenIn={setTokenIn}
            setTokenOut={setTokenOut}
            setorders={setorders}
            settradehistory={settradehistory}
            settradesByMarket={settradesByMarket}
            setcanceledorders={setcanceledorders}
            setpopup={setpopup}
            setChain={handleSetChain}
            account={{
              connected: connected,
              address: address,
              chainId: userchain,
            }}
            activechain={activechain}
            tokenIn={tokenIn}
            setShowTrade={setShowTrade}
            simpleView={simpleView}
            setSimpleView={setSimpleView}
            tokendict={tokendict}
            transactions={transactions}
            activeMarket={activeMarket}
            orderdata={{
              liquidityBuyOrders,
              liquiditySellOrders,
              reserveQuote,
              reserveBase
            }}
            onMarketSelect={onMarketSelect}
            marketsData={sortedMarkets}
            tradesloading={tradesloading}
            tradesByMarket={tradesByMarket}
            currentWalletIcon={currentWalletIcon}
            subWallets={subWallets}
            walletTokenBalances={walletTokenBalances}
            activeWalletPrivateKey={oneCTSigner}
            setOneCTSigner={setOneCTSigner}
            refetch={refetch}
            isBlurred={isBlurred}
            terminalRefetch={terminalRefetch}
            tokenList={memoizedTokenList}
            logout={logout}
            tokenBalances={tokenBalances}
            lastRefGroupFetch={lastRefGroupFetch}
            tokenData={token}
            monUsdPrice={monUsdPrice}
            sendUserOperationAsync={sendUserOperationAsync}
            setTokenData={setTokenData}
            quickAmounts={quickAmounts}
            setQuickAmount={setQuickAmount}
            activePresets={activePresets}
            setActivePreset={setActivePreset}
            handleInputFocus={handleInputFocus}
            buyPresets={buyPresets}
            sellPresets={sellPresets}
            perpsActiveMarketKey={perpsActiveMarketKey}
            setperpsActiveMarketKey={setperpsActiveMarketKey}
            perpsMarketsData={perpsMarketsData}
            perpsFilterOptions={perpsFilterOptions}
            externalUserStats={currentPNLData}
            lastNonceGroupFetch={lastNonceGroupFetch}
          />
        </div>
      }
      <div className="app-container"  style={{
    marginLeft: trackerWidgetSnap === 'left' ? `${trackerWidgetWidth}px` : undefined,
    marginRight: trackerWidgetSnap === 'right' ? `${trackerWidgetWidth}px` : undefined,
    transition: 'margin 0.3s ease',
  }}>
        <Routes>
          <Route path="/" element={<Navigate to="/market" replace />} />
          <Route path="*" element={<Navigate to="/market" replace />} />
          <Route path="/spectra"
            element={
              <TokenExplorer
                setpopup={setpopup}
                appliedFilters={appliedExplorerFilters}
                onOpenFiltersForColumn={handleOpenFiltersForColumn}
                sendUserOperationAsync={sendUserOperationAsync}
                terminalQueryData={terminalQueryData}
                terminalRefetch={terminalRefetch}
                setTokenData={setTokenData}
                monUsdPrice={monUsdPrice}
                subWallets={subWallets}
                walletTokenBalances={walletTokenBalances}
                activeWalletPrivateKey={oneCTSigner}
                setOneCTSigner={setOneCTSigner}
                refetch={refetch}
                tokenList={memoizedTokenList}
                activechain={activechain}
                logout={logout}
                lastRefGroupFetch={lastRefGroupFetch}
                lastNonceGroupFetch={lastNonceGroupFetch}
                currentWalletIcon={currentWalletIcon}
                isBlurred={isBlurred}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                quickAmounts={quickAmounts}
                setQuickAmounts={setQuickAmounts}
                alertSettingsRef={alertSettingsRef}
                pausedColumnRef={pausedColumnRef}
                pausedTokenQueueRef={pausedTokenQueueRef}
                dispatch={dispatch}
                hidden={hidden}
                tokensByStatus={tokensByStatus}
                alertSettings={alertSettings}
                setAlertSettings={setAlertSettings}
                loading={teLoading}
                isLoading={isTokenExplorerLoading}
                nonces={nonces}
                selectedWallets={selectedWallets}
                setSelectedWallets={setSelectedWallets}
                createSubWallet={createSubWallet}
                setOneCTDepositAddress={setOneCTDepositAddress}
              />
            }
          />
          <Route
            path="/meme/:tokenAddress"
            element={
              <MemeInterface
                sliderMode={'spot' === 'spot' ? spotSliderMode : trenchesSliderMode}
                sliderPresets={'spot' === 'spot' ? spotSliderPresets : trenchesSliderPresets}
                sliderIncrement={'spot' === 'spot' ? spotSliderIncrement : trenchesSliderIncrement}
                marketsData={marketsData}
                onMarketSelect={onMarketSelect}
                setSendTokenIn={setSendTokenIn}
                setpopup={setpopup}
                tokenList={memoizedTokenList}
                sendUserOperationAsync={sendUserOperationAsync}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                setChain={handleSetChain}
                address={address}
                subWallets={subWallets}
                walletTokenBalances={walletTokenBalances}
                activeWalletPrivateKey={oneCTSigner}
                setOneCTSigner={setOneCTSigner}
                refetch={refetch}
                isBlurred={isBlurred}
                tradesByMarket={tradesByMarket}
                markets={markets}
                tokendict={tokendict}
                usdc={usdc}
                wethticker={wethticker}
                ethticker={ethticker}
                terminalRefetch={terminalRefetch}
                tokenData={token}
                setTokenData={setTokenData}
                monUsdPrice={monUsdPrice}
                buyPresets={buyPresets}
                sellPresets={sellPresets}
                monPresets={monPresets}
                setMonPresets={setMonPresets}
                onPNLDataChange={setCurrentPNLData}
                onTokenDataChange={setCurrentTokenData}
                nonces={nonces}
                tokenAddress={token.id}
                trades={memeTrades}
                setTrades={setMemeTrades}
                holders={memeHolders}
                topTraders={memeTopTraders}
                positions={memePositions}
                devTokens={memeDevTokens}
                top10HoldingPercentage={memeTop10HoldingPct}
                userStats={memeUserStats}
                realtimeCallbackRef={memeRealtimeCallbackRef}
                selectedInterval={memeSelectedInterval}
                setSelectedInterval={setMemeSelectedInterval}
                chartData={chartData}
                page={page}
                similarTokens={memeSimilarTokens}
                token={token}
                selectedWallets={selectedWallets}
                setSelectedWallets={setSelectedWallets}
                selectedIntervalRef={memeSelectedIntervalRef}
                isTerminalDataFetching={isTerminalDataFetching}
              />
            }
          />
          <Route path="/board"
            element={
              <TokenBoard
                sendUserOperationAsync={sendUserOperationAsync}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                setChain={handleSetChain}
                setpopup={setpopup}
                terminalQueryData={terminalQueryData}
                terminalRefetch={terminalRefetch}
                setTokenData={setTokenData}
                monUsdPrice={monUsdPrice}
                tokens={tokensByStatus}
              />
            }
          />
          <Route path="/board/:tokenAddress"
            element={
              <TokenDetail
                sendUserOperationAsync={sendUserOperationAsync}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                setChain={handleSetChain}
                setpopup={setpopup}
                terminalQueryData={terminalQueryData}
                terminalRefetch={terminalRefetch}
                walletTokenBalances={walletTokenBalances}
                tokenData={token}
                monUsdPrice={monUsdPrice}
                token={token}
                selectedInterval={memeSelectedInterval}
                setSelectedInterval={setMemeSelectedInterval}
                holders={memeHolders}
                chartData={chartData}
                trades={memeTrades}
                realtimeCallbackRef={memeRealtimeCallbackRef}
                selectedIntervalRef={memeSelectedIntervalRef}
              />
            }
          />
          <Route path="/earn" element={<Navigate to="/earn/vaults" replace />} />
          <Route path="/earn/*"
            element={
              <Earn
                setpopup={setpopup}
                onSelectToken={(token) => {
                  setSelectedToken(token);
                  setTimeout(() => setSelectedToken(null), 100);
                }}
                setOnSelectTokenCallback={setOnSelectTokenCallback}
                selectedToken={selectedToken}
                tokenBalances={tokenBalances}
                tokendict={tokendict}
                address={address}
                connected={connected}
                refetch={refetch}
                tradesByMarket={tradesByMarket}
                markets={markets}
                usdc={usdc}
                wethticker={wethticker}
                ethticker={ethticker}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                sendUserOperationAsync={sendUserOperationAsync}
                activechain={activechain}
                setChain={handleSetChain}
                selectedVault={selectedVault}
                setselectedVault={setselectedVault}
                isVaultDepositSigning={isVaultDepositSigning}
                setIsVaultDepositSigning={setIsVaultDepositSigning}
                isVaultWithdrawSigning={isVaultWithdrawSigning}
                setIsVaultWithdrawSigning={setIsVaultWithdrawSigning}
                crystalVaultsAddress={crystalVaults}
                router={router}
                formatUSDDisplay={formatUSDDisplay}
                calculateUSDValue={calculateUSDValue}
                getMarket={getMarket}
                vaultList={vaultList}
                isLoading={isVaultsLoading}
                depositors={depositors}
                depositHistory={depositHistory}
                withdrawHistory={withdrawHistory}
                openOrders={openOrders}
                allOrders={_allOrders}
                selectedVaultStrategy={selectedVaultStrategy}
                setSelectedVaultStrategy={setSelectedVaultStrategy}
              />
            } />
          <Route path="/earn/vaults/:vaultAddress"
            element={
              <Earn
                setpopup={setpopup}
                onSelectToken={(token) => {
                  setSelectedToken(token);
                  setTimeout(() => setSelectedToken(null), 100);
                }}
                setOnSelectTokenCallback={setOnSelectTokenCallback}
                selectedToken={selectedToken}
                tokenBalances={tokenBalances}
                tokendict={tokendict}
                address={address}
                connected={connected}
                refetch={refetch}
                tradesByMarket={tradesByMarket}
                markets={markets}
                usdc={usdc}
                wethticker={wethticker}
                ethticker={ethticker}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                sendUserOperationAsync={sendUserOperationAsync}
                activechain={activechain}
                setChain={handleSetChain}
                selectedVault={selectedVault}
                setselectedVault={setselectedVault}
                isVaultDepositSigning={isVaultDepositSigning}
                setIsVaultDepositSigning={setIsVaultDepositSigning}
                isVaultWithdrawSigning={isVaultWithdrawSigning}
                setIsVaultWithdrawSigning={setIsVaultWithdrawSigning}
                crystalVaultsAddress={crystalVaults}
                router={router}
                formatUSDDisplay={formatUSDDisplay}
                calculateUSDValue={calculateUSDValue}
                getMarket={getMarket}
                vaultList={vaultList}
                isLoading={isVaultsLoading}
                depositors={depositors}
                depositHistory={depositHistory}
                withdrawHistory={withdrawHistory}
                openOrders={openOrders}
                allOrders={_allOrders}
                selectedVaultStrategy={selectedVaultStrategy}
                setSelectedVaultStrategy={setSelectedVaultStrategy}
              />
            } />
          <Route path="/portfolio"
            element={
              <Portfolio
                orders={orders}
                tradehistory={tradehistory}
                trades={tradesByMarket}
                canceledorders={canceledorders}
                tokenList={memoizedTokenList}
                router={router}
                address={address ?? ''}
                isBlurred={isBlurred}
                setIsBlurred={setIsBlurred}
                onMarketSelect={onMarketSelect}
                setSendTokenIn={setSendTokenIn}
                setpopup={setpopup}
                tokenBalances={tokenBalances}
                totalAccountValue={totalAccountValue}
                setTotalVolume={setTotalVolume}
                totalVolume={totalVolume}
                chartData={typeof totalAccountValue === 'number' ? [
                  ...portGraph.slice(0, -1),
                  {
                    ...portGraph[portGraph.length - 1],
                    value: totalAccountValue,
                  },
                ] : portGraph}
                portChartLoading={portChartLoading}
                chartDays={chartDays}
                setChartDays={setChartDays}
                totalClaimableFees={totalClaimableFees}
                claimableFees={claimableFees}
                refLink={refLink}
                setRefLink={setRefLink}
                filter={filter}
                setFilter={setFilter}
                onlyThisMarket={onlyThisMarket}
                setOnlyThisMarket={setOnlyThisMarket}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                  logout: logout,
                }}
                refetch={refetch}
                sendUserOperationAsync={sendUserOperationAsync}
                setChain={handleSetChain}
                marketsData={marketsData}
                usedRefLink={usedRefLink}
                setUsedRefLink={setUsedRefLink}
                setClaimableFees={setClaimableFees}
                setUsedRefAddress={setUsedRefAddress}
                client={client}
                activechain={activechain}
                markets={markets}
                tokendict={tokendict}
                subWallets={subWallets}
                setSubWallets={saveSubWallets}
                walletTokenBalances={walletTokenBalances}
                walletTotalValues={walletTotalValues}
                walletsLoading={walletsLoading}
                terminalRefetch={terminalRefetch}
                setOneCTSigner={setOneCTSigner}
                isVaultDepositSigning={isVaultDepositSigning}
                setIsVaultDepositSigning={setIsVaultDepositSigning}
                handleSetChain={handleSetChain}
                createSubWallet={createSubWallet}
                Wallet={Wallet}
                activeWalletPrivateKey={oneCTSigner}
                setShowRefModal={undefined}
                lastRefGroupFetch={lastRefGroupFetch}
                scaAddress={scaAddress}
                nonces={nonces}
                setOneCTDepositAddress={setOneCTDepositAddress}
              />
            } />
          <Route path="/trackers"
            element={
              <Tracker
                isBlurred={isBlurred}
                setpopup={setpopup}
                onImportWallets={handleImportWallets}
                monUsdPrice={monUsdPrice}
                walletTokenBalances={walletTokenBalances}
                activechain={activechain}
                tokenList={memoizedTokenList}
                marketsData={marketsData}
              />
            } />
          <Route path="/perps" element={<Navigate to={`/perps/${perpsActiveMarketKey}`} replace />} />
          <Route path="/perps/:marketKey"
            element={
              <Perps
                layoutSettings={perpsLayoutSettings}
                orderbookPosition={perpsOrderbookPosition}
                windowWidth={windowWidth}
                mobileView={mobileView}
                isOrderbookVisible={isOrderbookVisible}
                orderbookWidth={orderbookWidth}
                setOrderbookWidth={setOrderbookWidth}
                viewMode={viewMode}
                setViewMode={setViewMode}
                activeTab={obTab}
                setActiveTab={setOBTab}
                router={router}
                address={address}
                orderCenterHeight={orderCenterHeight}
                tokenList={memoizedTokenList}
                setSendTokenIn={setSendTokenIn}
                setpopup={setpopup}
                sortConfig={memoizedSortConfig}
                onSort={emptyFunction}
                tokenBalances={tokenBalances}
                activeSection={activeSection}
                setActiveSection={setActiveSection}
                filter={filter}
                setFilter={setFilter}
                onlyThisMarket={onlyThisMarket}
                setOnlyThisMarket={setOnlyThisMarket}
                refetch={refetch}
                sendUserOperationAsync={sendUserOperationAsync}
                setChain={handleSetChain}
                isVertDragging={isVertDragging}
                isOrderCenterVisible={isOrderCenterVisible}
                openEditOrderPopup={openEditOrderPopup}
                openEditOrderSizePopup={openEditOrderSizePopup}
                wethticker={wethticker}
                ethticker={ethticker}
                memoizedTokenList={memoizedTokenList}
                memoizedSortConfig={memoizedSortConfig}
                emptyFunction={emptyFunction}
                handleSetChain={handleSetChain}
                selectedInterval={selectedInterval}
                setSelectedInterval={setSelectedInterval}
                perpsActiveMarketKey={perpsActiveMarketKey}
                setperpsActiveMarketKey={setperpsActiveMarketKey}
                perpsMarketsData={perpsMarketsData}
                setPerpsMarketsData={setPerpsMarketsData}
                perpsFilterOptions={perpsFilterOptions}
                setPerpsFilterOptions={setPerpsFilterOptions}
                signTypedDataAsync={signMessageAsync}
                leverage={perpsLeverage}
                setLeverage={setPerpsLeverage}
                signer={perpsKeystore}
                setSigner={setPerpsKeystore}
                setOrderCenterHeight={setOrderCenterHeight}
                isMarksVisible={isMarksVisible}
                setIsMarksVisible={setIsMarksVisible}
                navigate={navigate}
              />
            } />
          <Route path="/leaderboard"
            element={
              <Leaderboard
                setpopup={setpopup}
                orders={orders}
                address={address}
                username={username}
                setIsTransitioning={setIsTransitioning}
                setTransitionDirection={setTransitionDirection}
              />
            } />
          <Route path="/launchpad"
            element={
              <Launchpad
                address={address}
                sendUserOperationAsync={sendUserOperationAsync}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                  logout: logout,
                }}
                setChain={handleSetChain}
                setpopup={setpopup}
              />
            } />
          <Route path="/lending"
            element={
              <EarnVaults
                setpopup={setpopup}
                onSelectToken={(token) => {
                  setSelectedToken(token);
                  setTimeout(() => setSelectedToken(null), 100);
                }}
                setOnSelectTokenCallback={setOnSelectTokenCallback}
                selectedToken={selectedToken}
                tokenBalances={tokenBalances}
                tokendict={tokendict}
                address={address}
                connected={connected}
                refetch={refetch}
                tradesByMarket={tradesByMarket}
                markets={markets}
                usdc={usdc}
                wethticker={wethticker}
                ethticker={ethticker}
                account={{
                  connected: connected,
                  address: address,
                  chainId: userchain,
                }}
                sendUserOperationAsync={sendUserOperationAsync}
                activechain={activechain}
                setChain={handleSetChain}
              />
            } />
          <Route path="/swap" element={TradeLayout(swap)} />
          <Route path="/market" element={TradeLayout(swap)} />
          <Route path="/limit" element={TradeLayout(limit)} />
          <Route path="/send" element={TradeLayout(send)} />
          <Route path="/scale" element={TradeLayout(scale)} />
        </Routes>
        <TransactionPopupManager
          transactions={transactions}
          setTransactions={setTransactions}
          tokendict={tokendict}
          showPreview={showPreview}
          previewPosition={previewPosition}
          previewExiting={previewExiting}
        />
{/* <TrackerWidget 
  isOpen={isTrackerWidgetOpen}
  onClose={() => setIsTrackerWidgetOpen(false)}
  onSnapChange={handleTrackerWidgetSnapChange}
/> */}
        {/* <WidgetExplorer
  isOpen={isWidgetExplorerOpen}
  onClose={handleCloseWidgetExplorer}
  setpopup={setpopup}
  appliedFilters={appliedExplorerFilters}
  activeFilterTab={activeExplorerFilterTab}
  onOpenFiltersForColumn={handleOpenFiltersForColumn}
  sendUserOperationAsync={sendUserOperationAsync}
  onSnapToSide={handleWidgetExplorerSnapToSide}
  currentSnapSide={widgetExplorerSnapSide}
  onWidgetResize={handleWidgetExplorerResize} 
/> */}
      </div>
    </div>
  );
}

export default Loader;